
#################### LLM PATCH ANALYSIS PACKAGE ####################

You are a security patch migration expert.

Your task:
1. Look at the OLD code (vulnerable).
2. Look at the NEW code (patched).
3. Look at the DIFF.
4. Decide whether the patch can be applied to the old version:
   - Yes      → applies cleanly
   - Maybe    → applies with adjustments
   - No       → cannot be applied
5. Provide a short explanation.

IMPORTANT:
Return ONLY JSON of this form:

{
  "portability": "Yes/Maybe/No",
  "reason": "<short explanation>"
}

####################################################################


### PATCH DIFF ###
commit f640aedc69c848d3d1be57f0300fc40033ff6423
Author: Glenn Matthews <glenn.matthews@networktocode.com>
Date:   Fri May 10 12:37:39 2024 -0400

    Add 'javascript' and 'css' to BRANDING_FILEPATHS options. Sanitize BANNER_ content (#5697)
    
    * Add 'javascript' and 'css' to BRANDING_FILEPATHS options. Address GHSA-r2hr-4v48-fjv3

diff --git a/changes/1858.added b/changes/1858.added
new file mode 100644
index 000000000..179792635
--- /dev/null
+++ b/changes/1858.added
@@ -0,0 +1,2 @@
+Added support in `BRANDING_FILEPATHS` configuration to specify a custom `css` and/or `javascript` file to be added to Nautobot page content.
+Added Markdown support to the `BANNER_TOP`, `BANNER_BOTTOM`, and `BANNER_LOGIN` configuration settings.
diff --git a/changes/1858.security b/changes/1858.security
new file mode 100644
index 000000000..48042c791
--- /dev/null
+++ b/changes/1858.security
@@ -0,0 +1 @@
+Added sanitization of HTML tags in the content of `BANNER_TOP`, `BANNER_BOTTOM`, and `BANNER_LOGIN` configuration to prevent against potential injection of malicious scripts (stored XSS) via these features ([GHSA-r2hr-4v48-fjv3](https://github.com/nautobot/nautobot/security/advisories/GHSA-r2hr-4v48-fjv3)).
diff --git a/nautobot/core/settings.py b/nautobot/core/settings.py
index bbef709db..289954fd6 100644
--- a/nautobot/core/settings.py
+++ b/nautobot/core/settings.py
@@ -69,7 +69,7 @@ ALLOWED_URL_SCHEMES = [
     "xmpp",
 ]
 
-# Banners to display to users. HTML is allowed.
+# Banners to display to users. Markdown and limited HTML are allowed.
 if "NAUTOBOT_BANNER_BOTTOM" in os.environ and os.environ["NAUTOBOT_BANNER_BOTTOM"] != "":
     BANNER_BOTTOM = os.environ["NAUTOBOT_BANNER_BOTTOM"]
 if "NAUTOBOT_BANNER_LOGIN" in os.environ and os.environ["NAUTOBOT_BANNER_LOGIN"] != "":
@@ -686,15 +686,15 @@ CONSTANCE_CONFIG = {
     ),
     "BANNER_BOTTOM": ConstanceConfigItem(
         default="",
-        help_text="Custom HTML to display in a banner at the bottom of all pages.",
+        help_text="Custom Markdown or limited HTML to display in a banner at the bottom of all pages.",
     ),
     "BANNER_LOGIN": ConstanceConfigItem(
         default="",
-        help_text="Custom HTML to display in a banner at the top of the login page.",
+        help_text="Custom Markdown or limited HTML to display in a banner at the top of the login page.",
     ),
     "BANNER_TOP": ConstanceConfigItem(
         default="",
-        help_text="Custom HTML to display in a banner at the top of all pages.",
+        help_text="Custom Markdown or limited HTML to display in a banner at the top of all pages.",
     ),
     "CHANGELOG_RETENTION": ConstanceConfigItem(
         default=90,
@@ -972,6 +972,8 @@ BRANDING_FILEPATHS = {
         "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET", None
     ),  # bullet image used for various view headers
     "nav_bullet": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET", None),  # bullet image used for nav menu headers
+    "css": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_CSS", None),  # Custom global CSS
+    "javascript": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT", None),  # Custom global JavaScript
 }
 
 # Title to use in place of "Nautobot"
diff --git a/nautobot/core/settings.yaml b/nautobot/core/settings.yaml
index 36dd0a129..2ba4ee583 100644
--- a/nautobot/core/settings.yaml
+++ b/nautobot/core/settings.yaml
@@ -128,24 +128,40 @@ properties:
     type: "array"
   BANNER_BOTTOM:
     default: ""
-    description: "Custom content to be displayed in a banner at the bottom of the page. HTML is allowed."
+    description: >-
+      Custom content to be displayed in a banner at the bottom of all Nautobot pages.
+    details: |-
+      +/- 2.2.4
+          Markdown formatting is supported within this message, as well as
+          [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).
     environment_variable: "NAUTOBOT_BANNER_BOTTOM"
     is_constance_config: true
     type: "string"
   BANNER_LOGIN:
     default: ""
-    description: "Custom content to be displayed on the login page above the login form. HTML is allowed."
+    description: >-
+      Custom content to be displayed in a banner on the login page above the login form.
+    details: |-
+      +/- 2.2.4
+          Markdown formatting is supported within this message, as well as
+          [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).
     environment_variable: "NAUTOBOT_BANNER_LOGIN"
     is_constance_config: true
     type: "string"
   BANNER_TOP:
     default: ""
-    description: "Custom content to be displayed in a banner at the top of the page. HTML is allowed."
+    description: >-
+      Custom content to be displayed in a banner at the top of all Nautobot pages.
+    details: |-
+      +/- 2.2.4
+          Markdown formatting is supported within this message, as well as
+          [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).
     environment_variable: "NAUTOBOT_BANNER_TOP"
     is_constance_config: true
     type: "string"
   BRANDING_FILEPATHS:
     default:
+      css: null
       favicon: null
       header_bullet: null
       icon_16: null
@@ -153,57 +169,76 @@ properties:
       icon_180: null
       icon_192: null
       icon_mask: null
+      javascript: null
       logo: null
       nav_bullet: null
     description: >-
-      A set of filepaths relative to the [`MEDIA_ROOT`](#media_root) which locate image assets used for
-      custom branding. Each of these assets takes the place of the corresponding stock Nautobot asset.
+      A set of filepaths relative to the [`MEDIA_ROOT`](#media_root) which locate assets used for
+      custom branding of your Nautobot instance.
+      With the exception of `css` and `javascript`, which provide the option to add an _additional_ file to Nautobot
+      page content, each of the other assets takes the place of the corresponding stock Nautobot asset.
       This allows for, for instance, providing your own navbar logo and favicon.
-      If a custom image asset is not provided for any of the above options, the stock Nautobot asset is used.
+      If a custom asset is not provided for any of the above options, the stock Nautobot asset is used.
+    details: |-
+      +++ 2.1.0
+          The `header_bullet` and `nav_bullet` assets were added as options.
+
+      +++ 2.2.4
+          The `css` and `javascript` assets were added as options.
     properties:
+      css:
+        "$ref": "#/definitions/relative_path"
+        default: null
+        description: "Custom global CSS file"
+        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_CSS"
       favicon:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "Browser favicon"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_FAVICON"
       header_bullet:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "Bullet image used for various view headers"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET"
       icon_16:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "16x16px icon"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_16"
       icon_180:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "180x180px icon - used for the apple-touch-icon header"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_180"
       icon_192:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "192x192px icon"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_192"
       icon_32:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "32x32px icon"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_32"
       icon_mask:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "Mono-chrome icon used for the mask-icon header"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK"
+      javascript:
+        "$ref": "#/definitions/relative_path"
+        default: null
+        description: "Custom global JavaScript file"
+        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT"
       logo:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "Navbar logo"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_LOGO"
       nav_bullet:
         "$ref": "#/definitions/relative_path"
-        default: ""
+        default: null
         description: "Bullet image used for nav menu headers"
         environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET"
     type: "object"
diff --git a/nautobot/core/templates/admin/base.html b/nautobot/core/templates/admin/base.html
index 94ffe2ec3..ab4fa07b2 100644
--- a/nautobot/core/templates/admin/base.html
+++ b/nautobot/core/templates/admin/base.html
@@ -56,7 +56,7 @@
     {% if not is_popup %}
         {% if "BANNER_TOP"|settings_or_config %}
             <div class="alert alert-info text-center" role="alert">
-                {{ "BANNER_TOP"|settings_or_config|safe }}
+                {{ "BANNER_TOP"|settings_or_config|render_markdown }}
             </div>
         {% endif %}
         {% if settings.MAINTENANCE_MODE %}
@@ -107,7 +107,7 @@
     <div class="push"></div>
     {% if "BANNER_BOTTOM"|settings_or_config %}
         <div class="alert alert-info text-center banner-bottom" role="alert">
-                {{ "BANNER_BOTTOM"|settings_or_config|safe }}
+                {{ "BANNER_BOTTOM"|settings_or_config|render_markdown }}
         </div>
     {% endif %}
 </div>
diff --git a/nautobot/core/templates/base_django.html b/nautobot/core/templates/base_django.html
index 969d71d16..9b688913c 100644
--- a/nautobot/core/templates/base_django.html
+++ b/nautobot/core/templates/base_django.html
@@ -16,7 +16,7 @@
         {% if request.user.is_authenticated %}
             {% if "BANNER_TOP"|settings_or_config %}
                 <div class="alert alert-info text-center" role="alert">
-                    {{ "BANNER_TOP"|settings_or_config|safe }}
+                    {{ "BANNER_TOP"|settings_or_config|render_markdown }}
                 </div>
             {% endif %}
         {% endif %}
@@ -42,7 +42,7 @@
         {% if request.user.is_authenticated %}
             {% if "BANNER_BOTTOM"|settings_or_config %}
                 <div class="alert alert-info text-center banner-bottom" role="alert">
-                    {{ "BANNER_BOTTOM"|settings_or_config|safe }}
+                    {{ "BANNER_BOTTOM"|settings_or_config|render_markdown }}
                 </div>
             {% endif %}
         {% endif %}
diff --git a/nautobot/core/templates/inc/javascript.html b/nautobot/core/templates/inc/javascript.html
index 7ee44f719..b2f96d21b 100644
--- a/nautobot/core/templates/inc/javascript.html
+++ b/nautobot/core/templates/inc/javascript.html
@@ -40,3 +40,6 @@
     hljs.configure({ cssSelector: '.language-graphql, .language-json, .language-xml, .language-yaml' });
     hljs.highlightAll();
 </script>
+{% if settings.BRANDING_FILEPATHS.javascript %}
+<script src="{% custom_branding_or_static 'javascript' None %}"></script>
+{% endif %}
diff --git a/nautobot/core/templates/inc/media.html b/nautobot/core/templates/inc/media.html
index 5b0f0fefb..7d7957a04 100644
--- a/nautobot/core/templates/inc/media.html
+++ b/nautobot/core/templates/inc/media.html
@@ -34,6 +34,9 @@
     <link rel="stylesheet" id="base-theme"
           href="{% versioned_static 'css/base.css' %}"
           onerror="window.location='{% url 'media_failure' %}?filename=css/base.css'">
+    {% if settings.BRANDING_FILEPATHS.css %}
+    <link rel="stylesheet" id="custom-css" href="{% custom_branding_or_static 'css' None %}">
+    {% endif %}
     <link rel="apple-touch-icon" sizes="180x180" href="{% custom_branding_or_static 'icon_180' 'img/nautobot_icon_180x180.png' %}">
     <link rel="icon" type="image/png" sizes="32x32" href="{% custom_branding_or_static 'icon_32' 'img/nautobot_icon_32x32.png' %}">
     <link rel="icon" type="image/png" sizes="16x16" href="{% custom_branding_or_static 'icon_16' 'img/nautobot_icon_16x16.png' %}">
diff --git a/nautobot/core/templates/login.html b/nautobot/core/templates/login.html
index 03b4dbb0c..5be540146 100644
--- a/nautobot/core/templates/login.html
+++ b/nautobot/core/templates/login.html
@@ -53,8 +53,8 @@
 <div class="row" style="margin-top: {% if 'BANNER_LOGIN'|settings_or_config %}100{% else %}150{% endif %}px;">
     <div class="col-sm-4 col-sm-offset-4">
         {% if "BANNER_LOGIN"|settings_or_config %}
-            <div style="margin-bottom: 25px">
-                {{ "BANNER_LOGIN"|settings_or_config|safe }}
+            <div class="alert alert-info text-center" role="alert">
+                {{ "BANNER_LOGIN"|settings_or_config|render_markdown }}
             </div>
         {% endif %}
         {% if form.non_field_errors %}
diff --git a/nautobot/core/templates/nautobot_config.py.j2 b/nautobot/core/templates/nautobot_config.py.j2
index b3e07c5a1..62ea08b28 100644
--- a/nautobot/core/templates/nautobot_config.py.j2
+++ b/nautobot/core/templates/nautobot_config.py.j2
@@ -248,6 +248,8 @@ SECRET_KEY = os.getenv("NAUTOBOT_SECRET_KEY", "{{ secret_key }}")
 #         "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET", None
 #     ),  # bullet image used for various view headers
 #     "nav_bullet": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET", None),  # bullet image used for nav menu headers
+#     "css": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_CSS", None),  # Custom global CSS
+#     "javascript": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT", None),  # Custom global JavaScript
 # }
 
 # Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)
diff --git a/nautobot/core/tests/test_views.py b/nautobot/core/tests/test_views.py
index 689c0b5a9..7f36f50a1 100644
--- a/nautobot/core/tests/test_views.py
+++ b/nautobot/core/tests/test_views.py
@@ -146,6 +146,39 @@ class HomeViewTestCase(TestCase):
         response_content = response.content.decode(response.charset).replace("\n", "")
         self.assertNotRegex(response_content, footer_hostname_version_pattern)
 
+    def test_banners_markdown(self):
+        url = reverse("home")
+        with override_settings(
+            BANNER_TOP="# Hello world",
+            BANNER_BOTTOM="[info](https://nautobot.com)",
+        ):
+            response = self.client.get(url)
+        self.assertInHTML("<h1>Hello world</h1>", response.content.decode(response.charset))
+        self.assertInHTML(
+            '<a href="https://nautobot.com" rel="noopener noreferrer">info</a>',
+            response.content.decode(response.charset),
+        )
+
+        with override_settings(BANNER_LOGIN="_Welcome to Nautobot!_"):
+            self.client.logout()
+            response = self.client.get(reverse("login"))
+        self.assertInHTML("<em>Welcome to Nautobot!</em>", response.content.decode(response.charset))
+
+    def test_banners_no_xss(self):
+        url = reverse("home")
+        with override_settings(
+            BANNER_TOP='<script>alert("Hello from above!");</script>',
+            BANNER_BOTTOM='<script>alert("Hello from below!");</script>',
+        ):
+            response = self.client.get(url)
+        self.assertNotIn("Hello from above", response.content.decode(response.charset))
+        self.assertNotIn("Hello from below", response.content.decode(response.charset))
+
+        with override_settings(BANNER_LOGIN='<script>alert("Welcome to Nautobot!");</script>'):
+            self.client.logout()
+            response = self.client.get(reverse("login"))
+        self.assertNotIn("Welcome to Nautobot!", response.content.decode(response.charset))
+
 
 @override_settings(BRANDING_TITLE="Nautobot")
 class SearchFieldsTestCase(TestCase):


### CHANGED FILES SUMMARY ###
{
  "changed_files": [
    "changes/1858.added",
    "changes/1858.security",
    "nautobot/core/settings.py",
    "nautobot/core/settings.yaml",
    "nautobot/core/templates/admin/base.html",
    "nautobot/core/templates/base_django.html",
    "nautobot/core/templates/inc/javascript.html",
    "nautobot/core/templates/inc/media.html",
    "nautobot/core/templates/login.html",
    "nautobot/core/templates/nautobot_config.py.j2",
    "nautobot/core/tests/test_views.py"
  ],
  "files_saved": [
    {
      "file": "changes/1858.added",
      "old": false,
      "new": true
    },
    {
      "file": "changes/1858.security",
      "old": false,
      "new": true
    },
    {
      "file": "nautobot/core/settings.py",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/settings.yaml",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/templates/admin/base.html",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/templates/base_django.html",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/templates/inc/javascript.html",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/templates/inc/media.html",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/templates/login.html",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/templates/nautobot_config.py.j2",
      "old": true,
      "new": true
    },
    {
      "file": "nautobot/core/tests/test_views.py",
      "old": true,
      "new": true
    }
  ]
}

### OLD VERSION FILES ###

----- FILE: nautobot_core_templates_login.html (OLD) -----
{% extends 'base.html' %}
{% load helpers %}
{% load form_helpers %}

{% block extra_styles %}
<style>
    .style-line {
        overflow: hidden;
        text-align: center;
        margin-bottom: 20px;
    }
    .style-line span {
        text-align: center;
        font-size: 15px;
        color: #acacac;
        display: inline-block;
        position: relative;
        padding: 0 25px;
        z-index: 1;
    }
    .style-line span:before {
        display: inline-block;
        content: "";
        height: 2px;
        width: 100%;
        background-color: #cfcfcf;
        left: 100%;
        top: 50%;
        -webkit-transform: translateY(-50%);
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
        position: absolute;
        z-index: 1;
    }
    .style-line span:after {
        display: inline-block;
        content: "";
        height: 2px;
        width: 100%;
        background-color: #cfcfcf;
        right: 100%;
        top: 50%;
        -webkit-transform: translateY(-50%);
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
        position: absolute;
        z-index: 1;
    }
</style>
{% endblock %}

{% block content %}
<div class="row" style="margin-top: {% if 'BANNER_LOGIN'|settings_or_config %}100{% else %}150{% endif %}px;">
    <div class="col-sm-4 col-sm-offset-4">
        {% if "BANNER_LOGIN"|settings_or_config %}
            <div style="margin-bottom: 25px">
                {{ "BANNER_LOGIN"|settings_or_config|safe }}
            </div>
        {% endif %}
        {% if form.non_field_errors %}
            <div class="panel panel-danger">
                <div class="panel-heading"><strong>Errors</strong></div>
                <div class="panel-body">
                    {{ form.non_field_errors }}
                </div>
            </div>
        {% endif %}
        <form action="{% url 'login' %}" method="post" class="form form-horizontal">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <strong>Log In</strong>
                </div>
                <div class="panel-body">
                    {% csrf_token %}
                    {% if 'next' in request.GET %}<input type="hidden" name="next" value="{{ request.GET.next }}" />{% endif %}
                    {% if 'next' in request.POST %}<input type="hidden" name="next" value="{{ request.POST.next }}" />{% endif %}
                    {% render_form form %}
                </div>
                <div class="panel-footer text-right">
                    <button type="submit" class="btn btn-primary">Log In</button>
                </div>
            </div>
        </form>
        {% if SSO_AUTH_ENABLED %}
        <div class="style-line">
            <span>Or</span>
        </div>
        <a href="{% url 'social:begin' backends.backends.0 %}?next={{ request.get_full_path | urlencode }}&{{ SAML_IDP }}" class="btn btn-primary btn-block">Continue with SSO</a>
        {% endif %}
    </div>
</div>
{% endblock %}



----- FILE: nautobot_core_templates_inc_media.html (OLD) -----
{% load static %}
{% load helpers %}
{% load plugins %}

    <link rel="stylesheet" id="template-theme"
          href="{% url 'template_css' %}">
    <link rel="stylesheet"
          href="{% static 'bootstrap-3.4.1-dist/css/bootstrap.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=bootstrap-3.4.1-dist/css/bootstrap.min.css'">
    <link rel="stylesheet"
          href="{% static 'materialdesignicons-6.5.95/css/materialdesignicons.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=materialdesignicons-6.5.95/css/materialdesignicons.min.css'">
    <link rel="stylesheet"
          href="{% static 'jquery-ui-1.13.2/jquery-ui.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=jquery-ui-1.13.2/jquery-ui.min.css'">
    <link rel="stylesheet"
          href="{% static 'select2-4.0.13/select2.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=select2-4.0.13/select2.min.css'">
    <link rel="stylesheet"
          href="{% static 'select2-bootstrap-0.1.0-beta.10/select2-bootstrap.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=select2-bootstrap-0.1.0-beta.10/select2-bootstrap.min.css'">
    <link rel="stylesheet"
          href="{% static 'flatpickr-4.6.9/themes/light.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=flatpickr-4.6.9/themes/light.min.css'">
    <link rel="stylesheet"
          href="{% static 'highlight.js-11.9.0/github.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=highlight.js-11.9.0/github.min.css'"{% if request.COOKIES|get_item:"theme" == 'dark' %} disabled="disabled"{% endif %} >
    <link rel="stylesheet"
          href="{% static 'highlight.js-11.9.0/github-dark.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=highlight.js-11.9.0/github-dark.min.css'"{% if request.COOKIES|get_item:"theme" != 'dark' %} disabled="disabled"{% endif %} />
    <link rel="stylesheet" id="dark-theme"
          href="{% versioned_static 'css/dark.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=css/dark.css'"{% if request.COOKIES|get_item:"theme" != 'dark' %} disabled="disabled"{% endif %} />
    <link rel="stylesheet" id="base-theme"
          href="{% versioned_static 'css/base.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=css/base.css'">
    <link rel="apple-touch-icon" sizes="180x180" href="{% custom_branding_or_static 'icon_180' 'img/nautobot_icon_180x180.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% custom_branding_or_static 'icon_32' 'img/nautobot_icon_32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% custom_branding_or_static 'icon_16' 'img/nautobot_icon_16x16.png' %}">
    <link rel="icon" type="image/png" sizes="192x192" href="{% custom_branding_or_static 'icon_192' 'img/nautobot_icon_192x192.png' %}">
    <link rel="mask-icon" type="image/png" color="#0097ff" href="{% custom_branding_or_static 'icon_mask' 'img/nautobot_icon_monochrome.png' %}">
    <link rel="shortcut icon" href="{% custom_branding_or_static 'favicon' 'img/favicon.ico' %}">
    <meta name="msapplication-TileColor" content="#2d89ef">
    <meta name="theme-color" content="#ffffff">
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">



----- FILE: nautobot_core_templates_inc_javascript.html (OLD) -----
{% load helpers %}
{% load plugins %}
{% load static %}

<script src="{% static 'jquery/jquery-3.7.1.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=jquery/jquery-3.7.1.min.js'"></script>
<script src="{% static 'jquery-ui-1.13.2/jquery-ui.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=jquery-ui-1.13.2/jquery-ui.min.js'"></script>
<script src="{% static 'bootstrap-3.4.1-dist/js/bootstrap.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=bootstrap-3.4.1-dist/js/bootstrap.min.js'"></script>
<script src="{% static 'select2-4.0.13/select2.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=select2-4.0.13/select2.min.js'"></script>
<script src="{% static 'clipboard.js-2.0.9/clipboard.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=clipboard.js-2.0.9/clipboard.min.js'"></script>
<script src="{% static 'flatpickr-4.6.9/flatpickr.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=flatpickr-4.6.9/flatpickr.min.js'"></script>
<script src="{% static 'highlight.js-11.9.0/highlight.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=highlight.js-11.9.0/highlight.min.js'"></script>
<script src="{% versioned_static 'js/forms.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=js/forms.js'"></script>
<script src="{% versioned_static 'js/theme.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=js/theme.js'"></script>
<script type="text/javascript">
    var nautobot_api_path = "{% url 'api-root' %}";
    var nautobot_csrf_token = "{{ csrf_token }}";
    var loading = $(".loading");
    $(document).ajaxStart(function() {
        loading.show();
    }).ajaxStop(function() {
        loading.hide();
    });
    // Applies bootstrap tooltip to all elements with the title attribute.
    // Button groups are "special" and require child tooltips to have
    // `{ container: 'body' }` option not to break their styles:
    // https://getbootstrap.com/docs/3.4/javascript/#markup-1
    $("*:not(.btn-group) > [title]").tooltip();
    $(".btn-group > [title]").tooltip({ container: 'body' });
</script>
<script type="text/javascript">
    hljs.configure({ cssSelector: '.language-graphql, .language-json, .language-xml, .language-yaml' });
    hljs.highlightAll();
</script>



----- FILE: nautobot_core_settings.py (OLD) -----
import os
import os.path
import platform
import re
import sys
import tempfile

from django.contrib.messages import constants as messages
import django.forms
from django.utils.safestring import mark_safe

from nautobot import __version__
from nautobot.core.constants import CONFIG_SETTING_SEPARATOR as _CONFIG_SETTING_SEPARATOR
from nautobot.core.settings_funcs import ConstanceConfigItem, is_truthy, parse_redis_connection

#
# Environment setup
#

# This is used for display in the UI. There are also VERSION_MAJOR and VERSION_MINOR derived from this later.
VERSION = __version__

# Hostname of the system. This is displayed in the web UI footers along with the
# version.
HOSTNAME = platform.node()

# Set the base directory two levels up (i.e. the base nautobot/ directory)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Set the swapable User model to the Nautobot custom User model
AUTH_USER_MODEL = "users.User"

# Set the default AutoField for 3rd party apps
# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions
#      we can't do that yet
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


###############################################################
# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #
###############################################################

#
# Nautobot optional settings/defaults
#

# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)
NAUTOBOT_ROOT = os.getenv("NAUTOBOT_ROOT", os.path.expanduser("~/.nautobot"))

# Allow users to enable request profiling via django-silk for admins to inspect.
if "NAUTOBOT_ALLOW_REQUEST_PROFILING" in os.environ and os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"] != "":
    ALLOW_REQUEST_PROFILING = is_truthy(os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"])

# URL schemes that are allowed within links in Nautobot
ALLOWED_URL_SCHEMES = [
    "file",
    "ftp",
    "ftps",
    "http",
    "https",
    "irc",
    "mailto",
    "sftp",
    "ssh",
    "tel",
    "telnet",
    "tftp",
    "vnc",
    "xmpp",
]

# Banners to display to users. HTML is allowed.
if "NAUTOBOT_BANNER_BOTTOM" in os.environ and os.environ["NAUTOBOT_BANNER_BOTTOM"] != "":
    BANNER_BOTTOM = os.environ["NAUTOBOT_BANNER_BOTTOM"]
if "NAUTOBOT_BANNER_LOGIN" in os.environ and os.environ["NAUTOBOT_BANNER_LOGIN"] != "":
    BANNER_LOGIN = os.environ["NAUTOBOT_BANNER_LOGIN"]
if "NAUTOBOT_BANNER_TOP" in os.environ and os.environ["NAUTOBOT_BANNER_TOP"] != "":
    BANNER_TOP = os.environ["NAUTOBOT_BANNER_TOP"]

# Number of days to retain changelog entries. Set to 0 to retain changes indefinitely. Defaults to 90 if not set here.
if "NAUTOBOT_CHANGELOG_RETENTION" in os.environ and os.environ["NAUTOBOT_CHANGELOG_RETENTION"] != "":
    CHANGELOG_RETENTION = int(os.environ["NAUTOBOT_CHANGELOG_RETENTION"])

# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts
# when a large number of dynamic groups are present
CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv("NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED", "False"))

# UUID uniquely but anonymously identifying this Nautobot deployment.
if "NAUTOBOT_DEPLOYMENT_ID" in os.environ and os.environ["NAUTOBOT_DEPLOYMENT_ID"] != "":
    DEPLOYMENT_ID = os.environ["NAUTOBOT_DEPLOYMENT_ID"]

# Device names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to True to use the device name alone as the natural key for Device objects.
# Set this to False to use the sequence (name, tenant, location) as the natural key instead.
#
if "NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"] != "":
    DEVICE_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"])

# The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.
if (
    "NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT" in os.environ
    and os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"] != ""
):
    DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT = int(os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"])

# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted
# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.
EXEMPT_EXCLUDE_MODELS = (
    ("auth", "group"),
    ("users", "user"),
    ("users", "objectpermission"),
)

# Models to exempt from the enforcement of view permissions
EXEMPT_VIEW_PERMISSIONS = []

# The file path to a directory where cloned Git repositories will be located
GIT_ROOT = os.getenv("NAUTOBOT_GIT_ROOT", os.path.join(NAUTOBOT_ROOT, "git").rstrip("/"))

# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)
HTTP_PROXIES = None

# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run
INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_INSTALLATION_METRICS_ENABLED", "True"))

# Maximum file size (in bytes) that as running Job can create in a call to `Job.create_file()`. Default is 10 << 20
if "NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE" in os.environ and os.environ["NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE"] != "":
    JOB_CREATE_FILE_MAX_SIZE = int(os.environ["NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE"])

# The storage backend to use for Job input files and Job output files
JOB_FILE_IO_STORAGE = os.getenv("NAUTOBOT_JOB_FILE_IO_STORAGE", "db_file_storage.storage.DatabaseFileStorage")

# The file path to a directory where locally installed Jobs can be discovered
JOBS_ROOT = os.getenv("NAUTOBOT_JOBS_ROOT", os.path.join(NAUTOBOT_ROOT, "jobs").rstrip("/"))

# `Location` names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to `True` to use the location `name` alone as the natural key for `Location` objects.
# Set this to `False` to use the sequence `(name, parent__name, parent__parent__name, ...)` as the natural key instead.
if "NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"] != "":
    LOCATION_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"])


# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True
LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv("NAUTOBOT_LOG_DEPRECATION_WARNINGS", "False"))

# Setting this to True will display a "maintenance mode" banner at the top of every page.
MAINTENANCE_MODE = is_truthy(os.getenv("NAUTOBOT_MAINTENANCE_MODE", "False"))

# Maximum number of objects that the UI and API will retrieve in a single request. Default is 1000
if "NAUTOBOT_MAX_PAGE_SIZE" in os.environ and os.environ["NAUTOBOT_MAX_PAGE_SIZE"] != "":
    MAX_PAGE_SIZE = int(os.environ["NAUTOBOT_MAX_PAGE_SIZE"])

# Metrics
METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_METRICS_ENABLED", "False"))
METRICS_AUTHENTICATED = is_truthy(os.getenv("NAUTOBOT_METRICS_AUTHENTICATED", "False"))
METRICS_DISABLED_APPS = []
if "NAUTOBOT_METRICS_DISABLED_APPS" in os.environ and os.environ["NAUTOBOT_METRICS_DISABLED_APPS"] != "":
    METRICS_DISABLED_APPS = os.getenv("NAUTOBOT_METRICS_DISABLED_APPS", "").split(_CONFIG_SETTING_SEPARATOR)

# Napalm
NAPALM_ARGS = {}
NAPALM_PASSWORD = os.getenv("NAUTOBOT_NAPALM_PASSWORD", "")
NAPALM_TIMEOUT = int(os.getenv("NAUTOBOT_NAPALM_TIMEOUT", "30"))
NAPALM_USERNAME = os.getenv("NAUTOBOT_NAPALM_USERNAME", "")

# Default number of objects to display per page of the UI and REST API. Default is 50
if "NAUTOBOT_PAGINATE_COUNT" in os.environ and os.environ["NAUTOBOT_PAGINATE_COUNT"] != "":
    PAGINATE_COUNT = int(os.environ["NAUTOBOT_PAGINATE_COUNT"])

# The options displayed in the web interface dropdown to limit the number of objects per page.
# Default is [25, 50, 100, 250, 500, 1000]
if "NAUTOBOT_PER_PAGE_DEFAULTS" in os.environ and os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"] != "":
    PER_PAGE_DEFAULTS = [int(val) for val in os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"].split(_CONFIG_SETTING_SEPARATOR)]

# Plugins
PLUGINS = []
PLUGINS_CONFIG = {}

# Prefer IPv6 addresses or IPv4 addresses in selecting a device's primary IP address? Default False
if "NAUTOBOT_PREFER_IPV4" in os.environ and os.environ["NAUTOBOT_PREFER_IPV4"] != "":
    PREFER_IPV4 = is_truthy(os.environ["NAUTOBOT_PREFER_IPV4"])

# Default height and width in pixels of a single rack unit in rendered rack elevations. Defaults are 22 and 220
if (
    "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT" in os.environ
    and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"] != ""
):
    RACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"])
if (
    "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH" in os.environ
    and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"] != ""
):
    RACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"])

# Enable two-digit format for the rack unit numbering in rack elevations.
if (
    "NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT" in os.environ
    and os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"] != ""
):
    RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT = is_truthy(os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"])

# How frequently to check for a new Nautobot release on GitHub, and the URL to check for this information.
# Defaults to disabled (no URL) and check every 24 hours when enabled
if "NAUTOBOT_RELEASE_CHECK_TIMEOUT" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"] != "":
    RELEASE_CHECK_TIMEOUT = int(os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"])
if "NAUTOBOT_RELEASE_CHECK_URL" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_URL"] != "":
    RELEASE_CHECK_URL = os.environ["NAUTOBOT_RELEASE_CHECK_URL"]

# Global 3rd-party authentication settings
EXTERNAL_AUTH_DEFAULT_GROUPS = []
EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}

# Remote auth backend settings
REMOTE_AUTH_AUTO_CREATE_USER = False
REMOTE_AUTH_HEADER = "HTTP_REMOTE_USER"

# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html
SOCIAL_AUTH_POSTGRES_JSONFIELD = False
# Nautobot related - May be overridden if using custom social auth backend
SOCIAL_AUTH_BACKEND_PREFIX = "social_core.backends"

# Job log entry sanitization and similar
SANITIZER_PATTERNS = [
    # General removal of username-like and password-like tokens
    (re.compile(r"(https?://)?\S+\s*@", re.IGNORECASE), r"\1{replacement}@"),
    (
        re.compile(r"(username|password|passwd|pwd|secret|secrets)([\"']?(?:\s+is.?|:)?\s+)\S+[\"']?", re.IGNORECASE),
        r"\1\2{replacement}",
    ),
]

# Storage
STORAGE_BACKEND = None
STORAGE_CONFIG = {}

# Custom message to display on 4xx and 5xx error pages. Markdown and HTML are supported.
# Default message directs the user to #nautobot on NTC's Slack community.
if "NAUTOBOT_SUPPORT_MESSAGE" in os.environ and os.environ["NAUTOBOT_SUPPORT_MESSAGE"] != "":
    SUPPORT_MESSAGE = os.environ["NAUTOBOT_SUPPORT_MESSAGE"]

# Test runner that is aware of our use of "integration" tags and only runs
# integration tests if explicitly passed in with `nautobot-server test --tag integration`.
TEST_RUNNER = "nautobot.core.tests.runner.NautobotTestRunner"
# Disable test data factories by default so as not to cause issues for plugins.
# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.
TEST_USE_FACTORIES = is_truthy(os.getenv("NAUTOBOT_TEST_USE_FACTORIES", "False"))
# Pseudo-random number generator seed, for reproducibility of test results.
TEST_FACTORY_SEED = os.getenv("NAUTOBOT_TEST_FACTORY_SEED", None)

#
# django-slowtests
#

# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.
# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command
# will automatically opt to NautobotPerformanceTestRunner to run the tests.

# The baseline file that the performance test is running against
# TODO we need to replace the baselines in this file with more consistent results at least for CI
TEST_PERFORMANCE_BASELINE_FILE = os.getenv(
    "NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE", "nautobot/core/tests/performance_baselines.yml"
)

#
# Django Prometheus
#

PROMETHEUS_EXPORT_MIGRATIONS = False


#
# Django filters
#

FILTERS_NULL_CHOICE_LABEL = "None"
FILTERS_NULL_CHOICE_VALUE = "null"

STRICT_FILTERING = is_truthy(os.getenv("NAUTOBOT_STRICT_FILTERING", "True"))

#
# Django REST framework (API)
#

REST_FRAMEWORK_VERSION = VERSION.rsplit(".", 1)[0]  # Use major.minor as API version
VERSION_MAJOR, VERSION_MINOR = [int(v) for v in REST_FRAMEWORK_VERSION.split(".")]
# We support all major.minor API versions from 2.0 to the present latest version.
# Similar logic exists in tasks.py, please keep them in sync!
if VERSION_MAJOR != 2:
    raise RuntimeError(f"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {VERSION_MAJOR}")
REST_FRAMEWORK_ALLOWED_VERSIONS = [f"{VERSION_MAJOR}.{minor}" for minor in range(0, VERSION_MINOR + 1)]

REST_FRAMEWORK = {
    "ALLOWED_VERSIONS": REST_FRAMEWORK_ALLOWED_VERSIONS,
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework.authentication.SessionAuthentication",
        "nautobot.core.api.authentication.TokenAuthentication",
    ),
    "DEFAULT_FILTER_BACKENDS": (
        "nautobot.core.api.filter_backends.NautobotFilterBackend",
        "nautobot.core.api.filter_backends.NautobotOrderingFilter",
    ),
    "DEFAULT_METADATA_CLASS": "nautobot.core.api.metadata.NautobotMetadata",
    "DEFAULT_PAGINATION_CLASS": "nautobot.core.api.pagination.OptionalLimitOffsetPagination",
    "DEFAULT_PERMISSION_CLASSES": ("nautobot.core.api.authentication.TokenPermissions",),
    "DEFAULT_RENDERER_CLASSES": (
        "nautobot.core.api.renderers.NautobotJSONRenderer",
        "nautobot.core.api.renderers.FormlessBrowsableAPIRenderer",
        "nautobot.core.api.renderers.NautobotCSVRenderer",
    ),
    "DEFAULT_PARSER_CLASSES": (
        "rest_framework.parsers.JSONParser",
        "nautobot.core.api.parsers.NautobotCSVParser",
    ),
    "DEFAULT_SCHEMA_CLASS": "nautobot.core.api.schema.NautobotAutoSchema",
    # Version to use if the client doesn't request otherwise. Default to current (i.e. latest)
    "DEFAULT_VERSION": REST_FRAMEWORK_VERSION,
    "DEFAULT_VERSIONING_CLASS": "nautobot.core.api.versioning.NautobotAPIVersioning",
    "ORDERING_PARAM": "sort",  # This is not meant to be changed by users, but is used internally by the API
    "PAGE_SIZE": None,
    "SCHEMA_COERCE_METHOD_NAMES": {
        # Default mappings
        "retrieve": "read",
        "destroy": "delete",
        # Custom operations
        "bulk_destroy": "bulk_delete",
    },
    "VIEW_NAME_FUNCTION": "nautobot.core.api.utils.get_view_name",
}


#
# drf_spectacular (OpenAPI/Swagger)
#

SPECTACULAR_SETTINGS = {
    "TITLE": "API Documentation",
    "DESCRIPTION": "Source of truth and network automation platform",
    "LICENSE": {"name": "Apache v2 License"},
    "VERSION": VERSION,
    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where "/api" was a common "basePath"
    # in the schema.
    # OpenAPI 3.0 removes "basePath" in favor of "servers", so we now declare "/api" as the server relative URL and
    # trim it from all of the individual paths correspondingly.
    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.
    "SERVERS": [{"url": "/api"}],
    "SERVE_PERMISSIONS": ["rest_framework.permissions.IsAuthenticated"],
    "SCHEMA_PATH_PREFIX": "/api",
    "SCHEMA_PATH_PREFIX_TRIM": True,
    # use sidecar - locally packaged UI files, not CDN
    "SWAGGER_UI_DIST": "SIDECAR",
    "SWAGGER_UI_FAVICON_HREF": "SIDECAR",
    "SWAGGER_UI_SETTINGS": {
        "deepLinking": True,
        "displayOperationId": True,
    },
    "REDOC_DIST": "SIDECAR",
    # Do not list all possible enum values in the description of filter fields and the like
    # In addition to being highly verbose, it's inaccurate for filter fields like *__ic and *__re
    "ENUM_GENERATE_CHOICE_DESCRIPTION": False,
    "ENUM_NAME_OVERRIDES": {
        # These choice enums need to be overridden because they get assigned to the `type` field and
        # result in this error:
        #    enum naming encountered a non-optimally resolvable collision for fields named "type".
        "CableTypeChoices": "nautobot.dcim.choices.CableTypeChoices",
        "ConsolePortTypeChoices": "nautobot.dcim.choices.ConsolePortTypeChoices",
        "CustomFieldTypeChoices": "nautobot.extras.choices.CustomFieldTypeChoices",
        "InterfaceTypeChoices": "nautobot.dcim.choices.InterfaceTypeChoices",
        "IPAddressTypeChoices": "nautobot.ipam.choices.IPAddressTypeChoices",
        "PortTypeChoices": "nautobot.dcim.choices.PortTypeChoices",
        "PowerFeedTypeChoices": "nautobot.dcim.choices.PowerFeedTypeChoices",
        "PowerOutletTypeChoices": "nautobot.dcim.choices.PowerOutletTypeChoices",
        "PowerPortTypeChoices": "nautobot.dcim.choices.PowerPortTypeChoices",
        "PrefixTypeChoices": "nautobot.ipam.choices.PrefixTypeChoices",
        "RackTypeChoices": "nautobot.dcim.choices.RackTypeChoices",
        "RelationshipTypeChoices": "nautobot.extras.choices.RelationshipTypeChoices",
        # These choice enums need to be overridden because they get assigned to different names with the same choice set and
        # result in this error:
        #   encountered multiple names for the same choice set
        "JobExecutionTypeIntervalChoices": "nautobot.extras.choices.JobExecutionType",
        # These choice enums need to be overridden because they get assigned to the `protocol` field and
        # result in this error:
        #    enum naming encountered a non-optimally resolvable collision for fields named "protocol".
        "InterfaceRedundancyGroupProtocolChoices": "nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices",
        "ServiceProtocolChoices": "nautobot.ipam.choices.ServiceProtocolChoices",
    },
    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)
    "COMPONENT_SPLIT_PATCH": True,
    # Create separate schema components for request vs response where appropriate
    "COMPONENT_SPLIT_REQUEST": True,
}


##############################################
# DJANGO - Core settings required for Django #
##############################################

#
# Databases
#

DATABASES = {
    "default": {
        "NAME": os.getenv("NAUTOBOT_DB_NAME", "nautobot"),
        "USER": os.getenv("NAUTOBOT_DB_USER", ""),
        "PASSWORD": os.getenv("NAUTOBOT_DB_PASSWORD", ""),
        "HOST": os.getenv("NAUTOBOT_DB_HOST", "localhost"),
        "PORT": os.getenv("NAUTOBOT_DB_PORT", ""),
        "CONN_MAX_AGE": int(os.getenv("NAUTOBOT_DB_TIMEOUT", "300")),
        "ENGINE": os.getenv(
            "NAUTOBOT_DB_ENGINE",
            "django_prometheus.db.backends.postgresql" if METRICS_ENABLED else "django.db.backends.postgresql",
        ),
    }
}

# Ensure proper Unicode handling for MySQL
if DATABASES["default"]["ENGINE"] == "django.db.backends.mysql":
    DATABASES["default"]["OPTIONS"] = {"charset": "utf8mb4"}

# The secret key is used to encrypt session keys and salt passwords.
SECRET_KEY = os.getenv("NAUTOBOT_SECRET_KEY", "")

# Default overrides
if "NAUTOBOT_ALLOWED_HOSTS" in os.environ and os.environ["NAUTOBOT_ALLOWED_HOSTS"] != "":
    ALLOWED_HOSTS = os.environ["NAUTOBOT_ALLOWED_HOSTS"].split(" ")
else:
    ALLOWED_HOSTS = []
CSRF_TRUSTED_ORIGINS = []
CSRF_FAILURE_VIEW = "nautobot.core.views.csrf_failure"
DATE_FORMAT = os.getenv("NAUTOBOT_DATE_FORMAT", "N j, Y")
DATETIME_FORMAT = os.getenv("NAUTOBOT_DATETIME_FORMAT", "N j, Y g:i a")
DEBUG = is_truthy(os.getenv("NAUTOBOT_DEBUG", "False"))
INTERNAL_IPS = ["127.0.0.1", "::1"]
FORCE_SCRIPT_NAME = None

TESTING = "test" in sys.argv

LOG_LEVEL = "DEBUG" if DEBUG else "INFO"

if TESTING:
    # Log to null handler instead of stderr during testing
    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "handlers": {"console": {"level": "INFO", "class": "logging.NullHandler"}},
        "loggers": {"nautobot": {"handlers": ["console"], "level": "INFO"}},
    }
else:
    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "normal": {
                "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s",
                "datefmt": "%H:%M:%S",
            },
            "verbose": {
                "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s",
                "datefmt": "%H:%M:%S",
            },
        },
        "handlers": {
            "normal_console": {
                "level": "INFO",
                "class": "logging.StreamHandler",
                "formatter": "normal",
            },
            "verbose_console": {
                "level": "DEBUG",
                "class": "logging.StreamHandler",
                "formatter": "verbose",
            },
        },
        "loggers": {
            "django": {"handlers": ["normal_console"], "level": "INFO"},
            "nautobot": {
                "handlers": ["verbose_console" if DEBUG else "normal_console"],
                "level": LOG_LEVEL,
            },
        },
    }

MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, "media").rstrip("/")
SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv("NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE", "False"))
SESSION_COOKIE_AGE = int(os.getenv("NAUTOBOT_SESSION_COOKIE_AGE", "1209600"))  # 2 weeks, in seconds
SESSION_FILE_PATH = os.getenv("NAUTOBOT_SESSION_FILE_PATH", None)
SHORT_DATE_FORMAT = os.getenv("NAUTOBOT_SHORT_DATE_FORMAT", "Y-m-d")
SHORT_DATETIME_FORMAT = os.getenv("NAUTOBOT_SHORT_DATETIME_FORMAT", "Y-m-d H:i")
TIME_FORMAT = os.getenv("NAUTOBOT_TIME_FORMAT", "g:i a")
TIME_ZONE = os.getenv("NAUTOBOT_TIME_ZONE", "UTC")

# Disable importing the WSGI module before starting the server application. This is required for
# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.
WEBSERVER_WARMUP = False

# Installed apps and Django plugins. Nautobot plugins will be appended here later.
INSTALLED_APPS = [
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.humanize",
    "corsheaders",
    "django_filters",
    "django_jinja",
    "django_tables2",
    "django_prometheus",
    "social_django",
    "taggit",
    "timezone_field",
    "nautobot.core.apps.NautobotConstanceConfig",  # overridden form of "constance" AppConfig
    "nautobot.core",
    "django.contrib.admin",  # Must be after `nautobot.core` for template overrides
    "django_celery_beat",  # Must be after `nautobot.core` for template overrides
    "django_celery_results",
    "rest_framework",  # Must be after `nautobot.core` for template overrides
    "db_file_storage",
    "nautobot.circuits",
    "nautobot.dcim",
    "nautobot.ipam",
    "nautobot.extras",
    "nautobot.tenancy",
    "nautobot.users",
    "nautobot.virtualization",
    "drf_spectacular",
    "drf_spectacular_sidecar",
    "graphene_django",
    "health_check",
    "health_check.storage",
    # We have custom implementations of these in nautobot.extras.health_checks:
    # "health_check.db",
    # "health_check.contrib.migrations",
    # "health_check.contrib.redis",
    "django_extensions",
    "constance.backends.database",
    "django_ajax_tables",
    "silk",
]

# Middleware
MIDDLEWARE = [
    "django_prometheus.middleware.PrometheusBeforeMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "silk.middleware.SilkyMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "nautobot.core.middleware.ExceptionHandlingMiddleware",
    "nautobot.core.middleware.RemoteUserMiddleware",
    "nautobot.core.middleware.ExternalAuthMiddleware",
    "nautobot.core.middleware.ObjectChangeMiddleware",
    "django_prometheus.middleware.PrometheusAfterMiddleware",
]

ROOT_URLCONF = "nautobot.core.urls"

TEMPLATES = [
    {
        "NAME": "django",
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.template.context_processors.media",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "social_django.context_processors.backends",
                "social_django.context_processors.login_redirect",
                "nautobot.core.context_processors.settings",
                "nautobot.core.context_processors.sso_auth",
            ],
        },
    },
    {
        "NAME": "jinja",
        "BACKEND": "django_jinja.backend.Jinja2",
        "DIRS": [],
        "APP_DIRS": False,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.template.context_processors.media",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "social_django.context_processors.backends",
                "social_django.context_processors.login_redirect",
                "nautobot.core.context_processors.settings",
                "nautobot.core.context_processors.sso_auth",
            ],
            "environment": "jinja2.sandbox.SandboxedEnvironment",
        },
    },
]

# Set up authentication backends
AUTHENTICATION_BACKENDS = [
    # Always check object permissions
    "nautobot.core.authentication.ObjectPermissionBackend",
]

# Internationalization
LANGUAGE_CODE = "en-us"
USE_I18N = True
USE_TZ = True

# WSGI
WSGI_APPLICATION = "nautobot.core.wsgi.application"
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
USE_X_FORWARDED_HOST = True
X_FRAME_OPTIONS = "DENY"

# Static files (CSS, JavaScript, Images)
STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, "static")
STATIC_URL = "static/"
STATICFILES_DIRS = (os.path.join(BASE_DIR, "project-static"),)

# Media
MEDIA_URL = "media/"

# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)
DATA_UPLOAD_MAX_NUMBER_FIELDS = None

# Messages
MESSAGE_TAGS = {
    messages.ERROR: "danger",
}

# Authentication URLs
# This is the URL route name for the login view.
LOGIN_URL = "login"

# This is the URL route name for the home page (index) view.
LOGIN_REDIRECT_URL = "home"

#
# django-constance
#

CONSTANCE_BACKEND = "constance.backends.database.DatabaseBackend"
CONSTANCE_DATABASE_PREFIX = "constance:nautobot:"
CONSTANCE_DATABASE_CACHE_BACKEND = "default"
CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment

CONSTANCE_ADDITIONAL_FIELDS = {
    "per_page_defaults_field": [
        "nautobot.core.forms.fields.JSONArrayFormField",
        {
            "widget": "django.forms.TextInput",
            "base_field": django.forms.IntegerField(min_value=1),
        },
    ],
    "release_check_timeout_field": [
        "django.forms.IntegerField",
        {
            "min_value": 3600,
        },
    ],
    "release_check_url_field": [
        "django.forms.URLField",
        {
            "required": False,
        },
    ],
    "optional_json_field": [
        "django.forms.fields.JSONField",
        {
            "required": False,
        },
    ],
}

CONSTANCE_CONFIG = {
    "ALLOW_REQUEST_PROFILING": ConstanceConfigItem(
        default=False,
        help_text="Allow users to enable request profiling on their login session.",
        field_type=bool,
    ),
    "BANNER_BOTTOM": ConstanceConfigItem(
        default="",
        help_text="Custom HTML to display in a banner at the bottom of all pages.",
    ),
    "BANNER_LOGIN": ConstanceConfigItem(
        default="",
        help_text="Custom HTML to display in a banner at the top of the login page.",
    ),
    "BANNER_TOP": ConstanceConfigItem(
        default="",
        help_text="Custom HTML to display in a banner at the top of all pages.",
    ),
    "CHANGELOG_RETENTION": ConstanceConfigItem(
        default=90,
        help_text="Number of days to retain object changelog history.\nSet this to 0 to retain changes indefinitely.",
        field_type=int,
    ),
    "DEVICE_NAME_AS_NATURAL_KEY": ConstanceConfigItem(
        default=False,
        help_text="Device names are not guaranteed globally-unique by Nautobot but in practice they often are. "
        "Set this to True to use the device name alone as the natural key for Device objects. "
        "Set this to False to use the sequence (name, tenant, location) as the natural key instead.",
        field_type=bool,
    ),
    "DEPLOYMENT_ID": ConstanceConfigItem(
        default="",
        help_text="Randomly generated UUID used to identify this installation.\n"
        "Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.",
        field_type=str,
    ),
    "DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT": ConstanceConfigItem(
        default=0,
        help_text="Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list "
        "will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very "
        "expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the "
        "member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.",
        field_type=int,
    ),
    "JOB_CREATE_FILE_MAX_SIZE": ConstanceConfigItem(
        default=10 << 20,
        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe
            "Maximum size (in bytes) of any single file generated by a <code>Job.create_file()</code> call."
        ),
        field_type=int,
    ),
    "LOCATION_NAME_AS_NATURAL_KEY": ConstanceConfigItem(
        default=False,
        help_text="Location names are not guaranteed globally-unique by Nautobot but in practice they often are. "
        "Set this to True to use the location name alone as the natural key for Location objects. "
        "Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) "
        "as the natural key instead.",
        field_type=bool,
    ),
    "MAX_PAGE_SIZE": ConstanceConfigItem(
        default=1000,
        help_text="Maximum number of objects that a user can list in one UI page or one API call.\n"
        "If set to 0, a user can retrieve an unlimited number of objects.",
        field_type=int,
    ),
    "PAGINATE_COUNT": ConstanceConfigItem(
        default=50,
        help_text="Default number of objects to display per page when listing objects in the UI and/or REST API.",
        field_type=int,
    ),
    "PER_PAGE_DEFAULTS": ConstanceConfigItem(
        default=[25, 50, 100, 250, 500, 1000],
        help_text="Pagination options to present to the user to choose amongst.\n"
        "For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.",
        # Use custom field type defined above
        field_type="per_page_defaults_field",
    ),
    "NETWORK_DRIVERS": ConstanceConfigItem(
        default={},
        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe
            "Extend or override default Platform.network_driver translations provided by "
            '<a href="https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/">netutils</a>. '
            "Enter a dictionary in JSON format, for example:\n"
            '<pre><code class="language-json">{\n'
            '    "netmiko": {"my_network_driver": "cisco_ios"},\n'
            '    "pyats": {"my_network_driver": "iosxe"} \n'
            "}</code></pre>",
        ),
        # Use custom field type defined above
        field_type="optional_json_field",
    ),
    "PREFER_IPV4": ConstanceConfigItem(
        default=False,
        help_text="Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.",
        field_type=bool,
    ),
    "RACK_ELEVATION_DEFAULT_UNIT_HEIGHT": ConstanceConfigItem(
        default=22, help_text="Default height (in pixels) of a rack unit in a rack elevation diagram", field_type=int
    ),
    "RACK_ELEVATION_DEFAULT_UNIT_WIDTH": ConstanceConfigItem(
        default=230, help_text="Default width (in pixels) of a rack unit in a rack elevation diagram", field_type=int
    ),
    "RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT": ConstanceConfigItem(
        default=False,
        help_text="Enables two-digit format for the rack unit numbering in a rack elevation diagram",
        field_type=bool,
    ),
    "RELEASE_CHECK_TIMEOUT": ConstanceConfigItem(
        default=24 * 3600,
        help_text="Number of seconds (must be at least 3600, or one hour) to cache the result of a release check "
        "before checking again for a new release.",
        # Use custom field type defined above
        field_type="release_check_timeout_field",
    ),
    "RELEASE_CHECK_URL": ConstanceConfigItem(
        default="",
        help_text="URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\n"
        'This can be set to the official repository "https://api.github.com/repos/nautobot/nautobot/releases" or '
        "a custom fork.\nSet this to an empty string to disable automatic update checks.",
        # Use custom field type defined above
        field_type="release_check_url_field",
    ),
    "SUPPORT_MESSAGE": ConstanceConfigItem(
        default="",
        help_text="Help message to include on 4xx and 5xx error pages. "
        "Markdown is supported, as are some HTML tags and attributes.\n"
        "If unspecified, instructions to join Network to Code's Slack community will be provided.",
    ),
}

CONSTANCE_CONFIG_FIELDSETS = {
    "Banners": ["BANNER_LOGIN", "BANNER_TOP", "BANNER_BOTTOM"],
    "Change Logging": ["CHANGELOG_RETENTION"],
    "Device Connectivity": ["NETWORK_DRIVERS", "PREFER_IPV4"],
    "Installation Metrics": ["DEPLOYMENT_ID"],
    "Natural Keys": ["DEVICE_NAME_AS_NATURAL_KEY", "LOCATION_NAME_AS_NATURAL_KEY"],
    "Pagination": ["PAGINATE_COUNT", "MAX_PAGE_SIZE", "PER_PAGE_DEFAULTS"],
    "Performance": ["DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT", "JOB_CREATE_FILE_MAX_SIZE"],
    "Rack Elevation Rendering": [
        "RACK_ELEVATION_DEFAULT_UNIT_HEIGHT",
        "RACK_ELEVATION_DEFAULT_UNIT_WIDTH",
        "RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT",
    ],
    "Release Checking": ["RELEASE_CHECK_URL", "RELEASE_CHECK_TIMEOUT"],
    "User Interface": ["SUPPORT_MESSAGE"],
    "Debugging": ["ALLOW_REQUEST_PROFILING"],
}

#
# From django-cors-headers
#

# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.
# Defaults to False. Setting this to True can be dangerous, as it allows any website to make
# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with
# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.
CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv("NAUTOBOT_CORS_ALLOW_ALL_ORIGINS", "False"))

# A list of strings representing regexes that match Origins that are authorized to make cross-site
# HTTP requests. Defaults to [].
CORS_ALLOWED_ORIGIN_REGEXES = []

# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].
CORS_ALLOWED_ORIGINS = []

#
# GraphQL
#

GRAPHENE = {
    "SCHEMA": "nautobot.core.graphql.schema_init.schema",
    "DJANGO_CHOICE_FIELD_ENUM_V3_NAMING": True,  # any field with a name of type will break in Graphene otherwise.
}
GRAPHQL_CUSTOM_FIELD_PREFIX = "cf"
GRAPHQL_RELATIONSHIP_PREFIX = "rel"
GRAPHQL_COMPUTED_FIELD_PREFIX = "cpf"


#
# Caching
#

# The django-redis cache is used to establish concurrent locks using Redis.
CACHES = {
    "default": {
        "BACKEND": os.getenv(
            "NAUTOBOT_CACHES_BACKEND",
            "django_prometheus.cache.backends.redis.RedisCache" if METRICS_ENABLED else "django_redis.cache.RedisCache",
        ),
        "LOCATION": parse_redis_connection(redis_database=1),
        "TIMEOUT": 300,
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            "PASSWORD": "",
        },
    }
}

# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.
CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv("NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT", "0"))

#
# Celery (used for background processing)
#

# Celery Beat heartbeat file path - will be touched by Beat each time it wakes up as a proof-of-health.
CELERY_BEAT_HEARTBEAT_FILE = os.getenv(
    "NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE",
    os.path.join(tempfile.gettempdir(), "nautobot_celery_beat_heartbeat"),
)

# Celery broker URL used to tell workers where queues are located
CELERY_BROKER_URL = os.getenv("NAUTOBOT_CELERY_BROKER_URL", parse_redis_connection(redis_database=0))

# Celery results backend URL to tell workers where to publish task results - DO NOT CHANGE THIS
CELERY_RESULT_BACKEND = "nautobot.core.celery.backends.NautobotDatabaseBackend"

# Enables extended task result attributes (name, args, kwargs, worker, retries, queue, delivery_info) to be written to backend.
CELERY_RESULT_EXTENDED = True

# A value of None or 0 means results will never expire (depending on backend specifications).
CELERY_RESULT_EXPIRES = None

# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`
CELERY_TASK_TRACK_STARTED = True

# If enabled, a `task-sent` event will be sent for every task so tasks can be tracked before they're consumed by a worker.
CELERY_TASK_SEND_SENT_EVENT = True

# If enabled stdout and stderr of running jobs will be redirected to the task logger.
CELERY_WORKER_REDIRECT_STDOUTS = is_truthy(os.getenv("NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS", "True"))

# The log level of log messages generated by redirected job stdout and stderr. Can be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`.
CELERY_WORKER_REDIRECT_STDOUTS_LEVEL = os.getenv("NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL", "WARNING")

# Send task-related events so that tasks can be monitored using tools like flower. Sets the default value for the workers -E argument.
CELERY_WORKER_SEND_TASK_EVENTS = True

# Default celery queue name that will be used by workers and tasks if no queue is specified
CELERY_TASK_DEFAULT_QUEUE = os.getenv("NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE", "default")

# Global task time limits (seconds)
# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,
# while exceeding the hard limit will result in a SIGKILL.
CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT", str(5 * 60)))
CELERY_TASK_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_TIME_LIMIT", str(10 * 60)))

# Ports for prometheus metric HTTP server running on the celery worker.
# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.
# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the
# highest amount of workers you are running on a single machine (comma-separated, like "8080,8081,8082"). You can then
# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in
# that case. Set this to an empty string to disable it.
CELERY_WORKER_PROMETHEUS_PORTS = []
if os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS"):
    CELERY_WORKER_PROMETHEUS_PORTS = [
        int(value) for value in os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS").split(_CONFIG_SETTING_SEPARATOR)
    ]

# These settings define the custom nautobot serialization encoding as an accepted data encoding format
# and register that format for task input and result serialization
CELERY_ACCEPT_CONTENT = ["nautobot_json"]
CELERY_RESULT_ACCEPT_CONTENT = ["nautobot_json"]
CELERY_TASK_SERIALIZER = "nautobot_json"
CELERY_RESULT_SERIALIZER = "nautobot_json"

CELERY_BEAT_SCHEDULER = "nautobot.core.celery.schedulers:NautobotDatabaseScheduler"

# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added
# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`
REDIS_LOCK_TIMEOUT = int(os.getenv("NAUTOBOT_REDIS_LOCK_TIMEOUT", "600"))

#
# Custom branding (logo and title)
#

# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.
# The filepath should be relative to the `MEDIA_ROOT`.
BRANDING_FILEPATHS = {
    "logo": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_LOGO", None),  # Navbar logo
    "favicon": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_FAVICON", None),  # Browser favicon
    "icon_16": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_16", None),  # 16x16px icon
    "icon_32": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_32", None),  # 32x32px icon
    "icon_180": os.getenv(
        "NAUTOBOT_BRANDING_FILEPATHS_ICON_180", None
    ),  # 180x180px icon - used for the apple-touch-icon header
    "icon_192": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_192", None),  # 192x192px icon
    "icon_mask": os.getenv(
        "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK", None
    ),  # mono-chrome icon used for the mask-icon header
    "header_bullet": os.getenv(
        "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET", None
    ),  # bullet image used for various view headers
    "nav_bullet": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET", None),  # bullet image used for nav menu headers
}

# Title to use in place of "Nautobot"
BRANDING_TITLE = os.getenv("NAUTOBOT_BRANDING_TITLE", "Nautobot")

# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)
BRANDING_PREPENDED_FILENAME = os.getenv("NAUTOBOT_BRANDING_PREPENDED_FILENAME", "nautobot_")

# Branding URLs (links in the bottom right of the footer)
BRANDING_URLS = {
    "code": os.getenv("NAUTOBOT_BRANDING_URLS_CODE", "https://github.com/nautobot/nautobot"),
    "docs": os.getenv("NAUTOBOT_BRANDING_URLS_DOCS", None),
    "help": os.getenv("NAUTOBOT_BRANDING_URLS_HELP", "https://github.com/nautobot/nautobot/wiki"),
}

# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.
BRANDING_POWERED_BY_URL = "https://docs.nautobot.com/"

#
# Django extensions settings
#

# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models
SHELL_PLUS_DONT_LOAD = ["taggit"]

#
# UI settings
#


# UI_RACK_VIEW_TRUNCATE_FUNCTION
def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):
    """Given device display name, truncate to fit the rack elevation view.

    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.
    :type device_display_name: str

    :return: Truncated device name
    :type: str
    """
    return str(device_display_name).split(".")[0]


# Custom JSON schema serializer field type mappingss. These will be added to
# `NautobotProcessingMixin.TYPE_MAP`.
# Format: `{serializer_field_class.__name__}` => `{json_schema_type}`
# See: https://github.com/yoyowallet/drf-react-template-framework#settings
DRF_REACT_TEMPLATE_TYPE_MAP = {
    "ContentTypeField": {"type": "string", "enum": "choices"},
    "CustomFieldsDataField": {"type": "object", "widget": "textarea"},
    "DateTimeField": {"type": "string", "format": "date-time", "widget": "date-time"},
    "ImageField": {"type": "string", "format": "data-url"},
    "IPFieldSerializer": {"type": "string"},
    "JSONField": {"type": "string", "widget": "textarea"},
    "MultipleChoiceJSONField": {"type": "array", "required": [], "enum": "choices"},
    "ManyRelatedField": {"type": "array", "required": []},
    #
    # Foreign Key fields
    #
    # enum=choices is the one that works in the UI as a related field but it
    # includes ALL related objects in the schema.
    # "NautobotHyperlinkedRelatedField": {"type": "string", "enum": "choices"},
    # readOnly=True disables the fields in the UI; not what we want.
    # "NautobotHyperlinkedRelatedField": {"type": "string", "readOnly": True},
    # type=string results in a free text field; also not what we want. For now,
    # however, this will keep things moving so the unit tests pass.
    "NautobotHyperlinkedRelatedField": {"type": "object"},
    "PrimaryKeyRelatedField": {"type": "string", "enum": "choices"},
    "RelationshipsDataField": {"type": "object"},
    "SlugField": {"type": "string"},
    "TimeZoneSerializerField": {"type": "string"},
    "UUIDField": {"type": "string", "format": "uuid"},
}


#
# django-silk is used for optional request profiling for debugging purposes
#

SILKY_PYTHON_PROFILER = True
SILKY_PYTHON_PROFILER_BINARY = True
SILKY_PYTHON_PROFILER_EXTENDED_FILE_NAME = True
SILKY_ANALYZE_QUERIES = False  # See the docs for the implications of turning this on https://github.com/jazzband/django-silk?tab=readme-ov-file#enable-query-analysis
SILKY_AUTHENTICATION = True  # User must login
SILKY_AUTHORISATION = True  # User must have permissions


# This makes it so that only superusers can access the silk UI
def silk_user_permissions(user):
    return user.is_superuser


SILKY_PERMISSIONS = silk_user_permissions


# This ensures profiling only happens when enabled on the sessions. Users are able
# to turn this on or off in their user profile. It also ignores health-check requests.
def silk_request_logging_intercept_logic(request):
    if request.path != "/health/":
        if request.session.get("silk_record_requests", False):
            return True
    return False


SILKY_INTERCEPT_FUNC = silk_request_logging_intercept_logic



----- FILE: nautobot_core_templates_admin_base.html (OLD) -----
{% load bootstrapped_goodies_tags %}
{% load helpers %}
{% load i18n %}
{% load plugins %}
{% load static%}

<!DOCTYPE html>
<html lang="en"{% if request.COOKIES|get_item:"theme" == 'dark' %} data-theme="dark"{% endif %}>
<head>
    <title>{% block title %}Admin Home{% endblock %} - Nautobot</title>
    {% include 'inc/media.html' %}
    {% block extrahead %}{% endblock %}
    {% block extrastyle %}{% endblock %}

    <style>
        .description {
            padding-bottom: 20px;
        }
        .help-block {
            white-space: initial;
            word-wrap: break-word;
        }
        .related-widget-wrapper {
            float: none;
        }
        .selectfilter {
            width: 100%;
        }
        .vLargeTextField, .vXMLLargeTextField {
            width: 100%;
        }
        .vTextField {
            width: 100%;
        }
        .related-widget-wrapper > select {
            width: 100%;
        }
        .form-horizontal .control-label {
            text-align: left;
        }
        input[type="checkbox"] {
            margin-left: 0 !important;
        }
        textarea {
            width: 100%;
        }
    </style>
</head>
<body {% if is_popup %}style="padding-left: 0px;"{% endif %}>

{% if not is_popup %}
    {% include 'inc/nav_menu.html' %}
{% endif %}

<div class="container-fluid wrapper" id="main-content" {% if is_popup %}style="padding-bottom: 0px;"{% endif %}>
    {% if not is_popup %}
        {% if "BANNER_TOP"|settings_or_config %}
            <div class="alert alert-info text-center" role="alert">
                {{ "BANNER_TOP"|settings_or_config|safe }}
            </div>
        {% endif %}
        {% if settings.MAINTENANCE_MODE %}
            <div class="alert alert-warning text-center" role="alert">
                <h4><i class="mdi mdi-alert"></i> Maintenance Mode</h4>
                <p>Nautobot is currently in maintenance mode. Functionality may be limited.</p>
            </div>
        {% endif %}
        {% plugin_banners %}
    {% endif %}
    {% for message in messages %}
        <div class="alert alert-{{ message.tags }} alert-dismissable" role="alert">
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span>&times;</span>
            </button>
            {{ message }}
        </div>
    {% endfor %}
    <!-- Content -->
    <div class="container-fluid wrapper">
        {% if not is_popup %}
            <div class="row noprint">
                {% block breadcrumbs %}
                {% endblock %}
            </div>
        {% endif %}
        <div>
            <div>
                {% block pretitle %}{% endblock %}
                <div class="pull-right noprint">
                    {% block object-tools %}{% endblock %}
                </div>
                <div>
                    {% block content_title %}
                        {% if title %}
                            <h1>{% render_with_template_if_exist title|lower|add:"/admin_app_name.html" title %}</h1>
                            <ul class="nav nav-tabs"></ul>
                        {% endif %}
                    {% endblock %}
                    <br>
                </div>
            </div>
        </div>
        <div class="container-fluid wrapper">
            {% block content %}{{ content }}{% endblock %}
        </div>
    </div>
    <div class="push"></div>
    {% if "BANNER_BOTTOM"|settings_or_config %}
        <div class="alert alert-info text-center banner-bottom" role="alert">
                {{ "BANNER_BOTTOM"|settings_or_config|safe }}
        </div>
    {% endif %}
</div>
{% if not is_popup %}
    {% include 'inc/footer.html' %}
{% endif %}
{% include 'modals/modal_theme.html' with name='theme'%}

{% block javascript %}
    {% include 'inc/javascript.html' %}
{% endblock %}
</body>
</html>



----- FILE: nautobot_core_tests_test_views.py (OLD) -----
import re
from unittest import mock
import urllib.parse

from django.apps import apps
from django.contrib.contenttypes.models import ContentType
from django.core.files.uploadedfile import SimpleUploadedFile
from django.test import override_settings, RequestFactory
from django.test.utils import override_script_prefix
from django.urls import get_script_prefix, reverse
from prometheus_client.parser import text_string_to_metric_families

from nautobot.core.constants import GLOBAL_SEARCH_EXCLUDE_LIST
from nautobot.core.testing import TestCase
from nautobot.core.testing.api import APITestCase
from nautobot.core.utils.permissions import get_permission_for_model
from nautobot.core.views import NautobotMetricsView
from nautobot.core.views.mixins import GetReturnURLMixin
from nautobot.dcim.models.locations import Location
from nautobot.extras.choices import CustomFieldTypeChoices
from nautobot.extras.models import FileProxy
from nautobot.extras.models.customfields import CustomField, CustomFieldChoice
from nautobot.extras.registry import registry
from nautobot.users.models import ObjectPermission


class GetReturnURLMixinTestCase(TestCase):
    """Tests for the API of GetReturnURLMixin."""

    @classmethod
    def setUpTestData(cls):
        cls.factory = RequestFactory(SERVER_NAME="nautobot.example.com")
        cls.mixin = GetReturnURLMixin()

    def test_get_return_url_explicit(self):
        request = self.factory.get("/", {"return_url": "/dcim/devices/"})
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), "/dcim/devices/")
        self.assertEqual(self.mixin.get_return_url(request=request, obj=Location.objects.first()), "/dcim/devices/")

        request = self.factory.get("/", {"return_url": "/dcim/devices/?status=Active"})
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), "/dcim/devices/?status=Active")

    def test_get_return_url_explicit_unsafe(self):
        request = self.factory.get("/", {"return_url": "http://example.com"})
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), reverse("home"))

    def test_get_return_url_explicit_punycode(self):
        """
        Replace the 'i' in '/dcim/' with a unicode dotless 'ı' and make sure we're not fooled by it.
        """  # noqa: RUF002  # ambiguous-unicode-character-docstring -- fully intentional here!
        request = self.factory.get("/", {"return_url": "/dcım/devices/"})  # noqa: RUF001  # ambiguous-unicode-character-string -- fully intentional here!
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), "/dc%C4%B1m/devices/")

    def test_get_return_url_default_with_obj(self):
        request = self.factory.get("/")
        location = Location.objects.first()
        self.assertEqual(self.mixin.get_return_url(request=request, obj=location), location.get_absolute_url())


class HomeViewTestCase(TestCase):
    def test_home(self):
        url = reverse("home")

        response = self.client.get(url)
        self.assertHttpStatus(response, 200)

    def test_search(self):
        url = reverse("search")
        params = {
            "q": "foo",
        }

        response = self.client.get(f"{url}?{urllib.parse.urlencode(params)}")
        self.assertHttpStatus(response, 200)

    def test_appropriate_models_included_in_global_search(self):
        # Gather core app configs
        existing_models = []
        global_searchable_models = []
        for app_name in ["circuits", "dcim", "extras", "ipam", "tenancy", "virtualization"]:
            app_config = apps.get_app_config(app_name)
            existing_models += [model._meta.model_name for model in app_config.get_models()]
            global_searchable_models += app_config.searchable_models

        # Remove those models that are not searchable
        existing_models = [model for model in existing_models if model not in GLOBAL_SEARCH_EXCLUDE_LIST]
        existing_models.sort()

        # See if there are any models that are missing from global search
        difference = [model for model in existing_models if model not in global_searchable_models]
        if difference:
            self.fail(
                f'Existing model/models {",".join(difference)} are not included in the searchable_models attribute of the app config.\n'
                'If you do not want the models to be searchable, please include them in the GLOBAL_SEARCH_EXCLUDE_LIST constant in nautobot.core.constants.'
            )

    def make_request(self):
        url = reverse("home")
        response = self.client.get(url)

        # Search bar in nav
        nav_search_bar_pattern = re.compile(
            '<nav.*<form action="/search/" method="get" class="navbar-form" id="navbar_search" role="search">.*</form>.*</nav>'
        )
        nav_search_bar_result = nav_search_bar_pattern.search(
            response.content.decode(response.charset).replace("\n", "")
        )

        # Global search bar in body/container-fluid wrapper
        body_search_bar_pattern = re.compile(
            '<div class="container-fluid wrapper" id="main-content">.*<form action="/search/" method="get" class="form-inline">.*</form>.*</div>',
            re.DOTALL,
        )

        body_search_bar_result = body_search_bar_pattern.search(
            response.content.decode(response.charset).replace("\n", "")
        )

        return nav_search_bar_result, body_search_bar_result

    def test_search_bar_not_visible_if_user_not_authenticated(self):
        self.client.logout()

        nav_search_bar_result, body_search_bar_result = self.make_request()

        self.assertIsNone(nav_search_bar_result)
        self.assertIsNone(body_search_bar_result)

    def test_search_bar_visible_if_user_authenticated(self):
        nav_search_bar_result, body_search_bar_result = self.make_request()

        self.assertIsNotNone(nav_search_bar_result)
        self.assertIsNotNone(body_search_bar_result)

    @override_settings(VERSION="1.2.3")
    def test_footer_version_visible_authenticated_users_only(self):
        url = reverse("home")
        response = self.client.get(url)
        response_content = response.content.decode(response.charset).replace("\n", "")

        footer_hostname_version_pattern = re.compile(r'<p class="text-muted">\s+\S+\s+\(v1\.2\.3\)\s+</p>')
        self.assertRegex(response_content, footer_hostname_version_pattern)

        self.client.logout()
        response = self.client.get(url)
        response_content = response.content.decode(response.charset).replace("\n", "")
        self.assertNotRegex(response_content, footer_hostname_version_pattern)


@override_settings(BRANDING_TITLE="Nautobot")
class SearchFieldsTestCase(TestCase):
    def test_search_bar_redirect_to_login(self):
        self.client.logout()
        response = self.client.get(reverse("search") + "?q=prefix")
        # Assert that if the user is not logged in
        # SearchForm will redirect the user to the login Page
        self.assertEqual(response.status_code, 302)

    def test_global_and_model_search_bar(self):
        self.add_permissions("dcim.view_location", "dcim.view_device")

        # Assert model search bar present in list UI
        response = self.client.get(reverse("dcim:location_list"))
        self.assertInHTML(
            '<input type="text" name="q" class="form-control" required placeholder="Search Locations" id="id_q">',
            response.content.decode(response.charset),
        )

        response = self.client.get(reverse("dcim:device_list"))
        self.assertInHTML(
            '<input type="text" name="q" class="form-control" required placeholder="Search Devices" id="id_q">',
            response.content.decode(response.charset),
        )

        # Assert global search bar present in UI
        self.assertInHTML(
            '<input type="text" name="q" class="form-control" placeholder="Search Nautobot">',
            response.content.decode(response.charset),
        )


class FilterFormsTestCase(TestCase):
    def test_support_for_both_default_and_dynamic_filter_form_in_ui(self):
        self.add_permissions("dcim.view_location", "circuits.view_circuit")

        filter_tabs = """
            <ul id="tabs" class="nav nav-tabs">
                <li role="presentation" class="active">
                    <a href="#default-filter" role="tab" data-toggle="tab">
                        Default
                    </a>
                </li>
                <li role="presentation" class="">
                    <a href="#advanced-filter" role="tab" data-toggle="tab">
                        Advanced
                    </a>
                </li>
            </ul>
            """

        response = self.client.get(reverse("dcim:location_list"))
        self.assertInHTML(
            filter_tabs,
            response.content.decode(response.charset),
        )

        response = self.client.get(reverse("circuits:circuit_list"))
        self.assertInHTML(
            filter_tabs,
            response.content.decode(response.charset),
        )

    def test_filtering_on_custom_select_filter_field(self):
        """Assert CustomField select and multiple select fields can be filtered using multiple entries"""
        self.add_permissions("dcim.view_location")

        multi_select_cf = CustomField.objects.create(
            type=CustomFieldTypeChoices.TYPE_MULTISELECT, label="Multiple Choice"
        )
        select_cf = CustomField.objects.create(type=CustomFieldTypeChoices.TYPE_SELECT, label="choice")
        choices = ["Foo", "Bar", "FooBar"]
        for cf in [multi_select_cf, select_cf]:
            cf.content_types.set([ContentType.objects.get_for_model(Location)])
            CustomFieldChoice.objects.create(custom_field=cf, value=choices[0])
            CustomFieldChoice.objects.create(custom_field=cf, value=choices[1])
            CustomFieldChoice.objects.create(custom_field=cf, value=choices[2])

        locations = Location.objects.all()[:3]
        for idx, location in enumerate(locations):
            location.cf[multi_select_cf.key] = choices[:2]
            location.cf[select_cf.key] = choices[idx]
            location.save()

        query_param = (
            f"?cf_{multi_select_cf.key}={choices[0]}&cf_{multi_select_cf.key}={choices[1]}"
            f"&cf_{select_cf.key}={choices[0]}&cf_{select_cf.key}={choices[1]}"
        )
        url = reverse("dcim:location_list") + query_param
        response = self.client.get(url)
        self.assertHttpStatus(response, 200)
        response_content = response.content.decode(response.charset).replace("\n", "")
        self.assertInHTML(locations[0].name, response_content)
        self.assertInHTML(locations[1].name, response_content)

    def test_filtering_crafted_query_params(self):
        """Test for reflected-XSS vulnerability GHSA-jxgr-gcj5-cqqg."""
        self.add_permissions("dcim.view_location")
        query_param = "?location_type=1 onmouseover=alert('hi') foo=bar"
        url = reverse("dcim:location_list") + query_param
        response = self.client.get(url)
        self.assertHttpStatus(response, 200)
        response_content = response.content.decode(response.charset)
        # The important thing here is that the data-field-parent and data-field-value are correctly quoted
        self.assertInHTML(
            """
<span class="filter-selection-choice-remove remove-filter-param"
      data-field-type="child"
      data-field-parent="location_type"
      data-field-value="1 onmouseover=alert(&#x27;hi&#x27;) foo=bar"
>×</span>""",  # noqa: RUF001 - ambiguous-unicode-character-string
            response_content,
        )


class ForceScriptNameTestcase(TestCase):
    """Basic test to assert that `settings.FORCE_SCRIPT_NAME` works as intended."""

    @override_settings(
        FORCE_SCRIPT_NAME="/nautobot/",
    )
    @override_script_prefix("/nautobot/")
    def test_subdirectory_routes(self):
        # We must call `set_script_prefix()` to set the URL resolver script prefix outside of the
        # request/response cycle (e.g. in scripts/tests) to generate correct URLs when `SCRIPT_NAME`
        # is not `/`.
        #
        # We must then call it again to reset the script pefix after we're done because
        # the state is stored in the thread-local scope and will "infect" other tests.
        prefix = get_script_prefix()
        self.assertEqual(prefix, "/nautobot/")

        # And that routes will start w/ the prefix vs. just "/" (the default).
        routes = ("home", "login", "search", "api-root")
        for route in routes:
            url = reverse(route)
            self.assertTrue(url.startswith(prefix))


class NavAppsUITestCase(TestCase):
    def setUp(self):
        super().setUp()

        self.url = reverse("apps:apps_list")
        self.item_weight = 100  # TODO: not easy to introspect from the nav menu struct, so hard-code it here for now

    def make_request(self):
        response = self.client.get(reverse("home"))
        return response.content.decode(response.charset)

    def test_installed_apps_visible(self):
        """The "Installed Apps" menu item should be available to an authenticated user regardless of permissions."""
        response_content = self.make_request()
        self.assertInHTML(
            f"""
            <a href="{self.url}"
                data-item-weight="{self.item_weight}">
                Installed Apps
            </a>
            """,
            response_content,
        )


class LoginUITestCase(TestCase):
    def setUp(self):
        super().setUp()

        self.footer_elements = [
            '<a href="#theme_modal" data-toggle="modal" data-target="#theme_modal" id="btn-theme-modal"><i class="mdi mdi-theme-light-dark text-primary"></i>Theme</a>',
            '<a href="/static/docs/index.html">Docs</a>',
            '<i class="mdi mdi-cloud-braces text-primary"></i> <a href="/api/docs/">API</a>',
            '<i class="mdi mdi-graphql text-primary"></i> <a href="/graphql/">GraphQL</a>',
            '<i class="mdi mdi-xml text-primary"></i> <a href="https://github.com/nautobot/nautobot">Code</a>',
            '<i class="mdi mdi-lifebuoy text-primary"></i> <a href="https://github.com/nautobot/nautobot/wiki">Help</a>',
        ]

    def make_request(self):
        response = self.client.get(reverse("login"))
        sso_login_pattern = re.compile('<a href=".*">Continue with SSO</a>')
        return sso_login_pattern.search(response.content.decode(response.charset))

    def test_sso_login_button_not_visible(self):
        """Test Continue with SSO button not visible if SSO is enabled"""
        self.client.logout()

        sso_login_search_result = self.make_request()
        self.assertIsNone(sso_login_search_result)

    @override_settings(
        AUTHENTICATION_BACKENDS=[
            "social_core.backends.google.GoogleOAuth2",
            "nautobot.core.authentication.ObjectPermissionBackend",
        ]
    )
    def test_sso_login_button_visible(self):
        self.client.logout()
        sso_login_search_result = self.make_request()
        self.assertIsNotNone(sso_login_search_result)

    def test_graphql_redirects_back_to_login_unauthenticated(self):
        """Assert that graphql redirects to login page if user is unauthenticated."""
        self.client.logout()
        headers = {"HTTP_ACCEPT": "text/html"}
        url = reverse("graphql")
        response = self.client.get(url, follow=True, **headers)
        self.assertHttpStatus(response, 200)
        self.assertRedirects(response, f"/login/?next={url}")
        response_content = response.content.decode(response.charset).replace("\n", "")
        for footer_text in self.footer_elements:
            self.assertNotIn(footer_text, response_content)

    def test_api_docs_403_unauthenticated(self):
        """Assert that api docs return a 403 Forbidden if user is unauthenticated."""
        self.client.logout()
        urls = [
            reverse("api_docs"),
            reverse("api_redocs"),
            reverse("schema"),
            reverse("schema_json"),
            reverse("schema_yaml"),
        ]
        for url in urls:
            response = self.client.get(url)
            self.assertHttpStatus(response, 403)


class MetricsViewTestCase(TestCase):
    def query_and_parse_metrics(self):
        response = self.client.get(reverse("metrics"))
        self.assertHttpStatus(response, 200, msg="/metrics should return a 200 HTTP status code.")
        page_content = response.content.decode(response.charset)
        return text_string_to_metric_families(page_content)

    def test_metrics_extensibility(self):
        """Assert that the example metric from the Example App shows up _exactly_ when the app is enabled."""
        test_metric_name = "nautobot_example_metric_count"
        metrics_with_app = self.query_and_parse_metrics()
        metric_names_with_app = {metric.name for metric in metrics_with_app}
        self.assertIn(test_metric_name, metric_names_with_app)
        with override_settings(PLUGINS=[]):
            # Clear out the app metric registry because it is not updated when settings are changed but Nautobot is not
            # restarted.
            registry["app_metrics"].clear()
            metrics_without_app = self.query_and_parse_metrics()
            metric_names_without_app = {metric.name for metric in metrics_without_app}
            self.assertNotIn(test_metric_name, metric_names_without_app)
        metric_names_with_app.remove(test_metric_name)
        self.assertSetEqual(metric_names_with_app, metric_names_without_app)


class AuthenticateMetricsTestCase(APITestCase):
    def test_metrics_authentication(self):
        """Assert that if metrics require authentication, a user not logged in gets a 403."""
        self.client.logout()
        headers = {}
        response = self.client.get(reverse("metrics"), **headers)
        self.assertHttpStatus(response, 403, msg="/metrics should return a 403 HTTP status code.")

    def test_metrics(self):
        """Assert that if metrics don't require authentication, a user not logged in gets a 200."""
        self.factory = RequestFactory()
        self.client.logout()

        request = self.factory.get("/")
        response = NautobotMetricsView.as_view()(request)
        self.assertHttpStatus(response, 200, msg="/metrics should return a 200 HTTP status code.")


class ErrorPagesTestCase(TestCase):
    """Tests for 4xx and 5xx error page rendering."""

    @override_settings(DEBUG=False)
    def test_404_default_support_message(self):
        """Nautobot's custom 404 page should be used and should include a default support message."""
        with self.assertTemplateUsed("404.html"):
            response = self.client.get("/foo/bar")
        self.assertContains(response, "Network to Code", status_code=404)
        response_content = response.content.decode(response.charset)
        self.assertInHTML(
            "If further assistance is required, please join the <code>#nautobot</code> channel on "
            '<a href="https://slack.networktocode.com/" rel="noopener noreferrer">Network to Code\'s '
            "Slack community</a> and post your question.",
            response_content,
        )

    @override_settings(DEBUG=False, SUPPORT_MESSAGE="Hello world!")
    def test_404_custom_support_message(self):
        """Nautobot's custom 404 page should be used and should include a custom support message if defined."""
        with self.assertTemplateUsed("404.html"):
            response = self.client.get("/foo/bar")
        self.assertNotContains(response, "Network to Code", status_code=404)
        response_content = response.content.decode(response.charset)
        self.assertInHTML("Hello world!", response_content)

    @override_settings(DEBUG=False)
    @mock.patch("nautobot.core.views.HomeView.get", side_effect=Exception)
    def test_500_default_support_message(self, mock_get):
        """Nautobot's custom 500 page should be used and should include a default support message."""
        url = reverse("home")
        with self.assertTemplateUsed("500.html"):
            self.client.raise_request_exception = False
            response = self.client.get(url)
        self.assertContains(response, "Network to Code", status_code=500)
        response_content = response.content.decode(response.charset)
        self.assertInHTML(
            "If further assistance is required, please join the <code>#nautobot</code> channel on "
            '<a href="https://slack.networktocode.com/" rel="noopener noreferrer">Network to Code\'s '
            "Slack community</a> and post your question.",
            response_content,
        )

    @override_settings(DEBUG=False, SUPPORT_MESSAGE="Hello world!")
    @mock.patch("nautobot.core.views.HomeView.get", side_effect=Exception)
    def test_500_custom_support_message(self, mock_get):
        """Nautobot's custom 500 page should be used and should include a custom support message if defined."""
        url = reverse("home")
        with self.assertTemplateUsed("500.html"):
            self.client.raise_request_exception = False
            response = self.client.get(url)
        self.assertNotContains(response, "Network to Code", status_code=500)
        response_content = response.content.decode(response.charset)
        self.assertInHTML("Hello world!", response_content)


class DBFileStorageViewTestCase(TestCase):
    """Test authentication/permission enforcement for django_db_file_storage views."""

    def setUp(self):
        super().setUp()
        self.test_file_1 = SimpleUploadedFile(name="test_file_1.txt", content=b"I am content.\n")
        self.file_proxy_1 = FileProxy.objects.create(name=self.test_file_1.name, file=self.test_file_1)
        self.test_file_2 = SimpleUploadedFile(name="test_file_2.txt", content=b"I am content.\n")
        self.file_proxy_2 = FileProxy.objects.create(name=self.test_file_2.name, file=self.test_file_2)
        self.url = f"{reverse('db_file_storage.download_file')}?name={self.file_proxy_1.file.name}"

    def test_get_file_anonymous(self):
        self.client.logout()
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 403)

    def test_get_file_without_permission(self):
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 403)

    def test_get_object_with_permission(self):
        self.add_permissions(get_permission_for_model(FileProxy, "view"))
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 200)

    def test_get_object_with_constrained_permission(self):
        obj_perm = ObjectPermission(
            name="Test permission",
            constraints={"pk": self.file_proxy_1.pk},
            actions=["view"],
        )
        obj_perm.save()
        obj_perm.users.add(self.user)
        obj_perm.object_types.add(ContentType.objects.get_for_model(FileProxy))
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 200)
        url = f"{reverse('db_file_storage.download_file')}?name={self.file_proxy_2.file.name}"
        response = self.client.get(url)
        self.assertHttpStatus(response, 404)


class SilkUIAccessTestCase(TestCase):
    """Test access control related to the django-silk UI"""

    def test_access_for_non_superuser(self):
        # Login as non-superuser
        self.user.is_superuser = False
        self.user.save()
        self.client.force_login(self.user)

        # Attempt to access the view
        response = self.client.get(reverse("silk:summary"))

        # Check for redirect or forbidden status code (302 or 403)
        self.assertIn(response.status_code, [302, 403])

    def test_access_for_superuser(self):
        # Login as superuser
        self.user.is_superuser = True
        self.user.save()
        self.client.force_login(self.user)

        # Attempt to access the view
        response = self.client.get(reverse("silk:summary"))

        # Check for success status code (e.g., 200)
        self.assertEqual(response.status_code, 200)



----- FILE: nautobot_core_settings.yaml (OLD) -----
---
"$schema": "https://json-schema.org/draft/2020-12/schema"
title: "Nautobot Settings"
definitions:
  absolute_path:
    type: "string"
  callable:
    type: "string"
  regex:
    type: "string"
  relative_path:
    type: "string"
type: "object"
properties:
  ADMINS:
    default: []
    description: >-
      Administrators' names and emails as a list of (name, email) tuples.
      Nautobot will email details about critical errors to any administrators listed here.
    details: |
      For example:

      ```python
      ADMINS = [
          ['Hank Hill', 'hhill@example.com'],
          ['Dale Gribble', 'dgribble@example.com'],
      ]
      ```
    items:
      items:
        type: "string"
      type: "array"
    see_also:
      "Django documentation for `ADMINS`": "https://docs.djangoproject.com/en/stable/ref/settings/#admins"
    type: "array"
  ALLOW_REQUEST_PROFILING:
    default: false
    description: "Global setting to allow or deny users from enabling request profiling on their login session."
    environment_variable: "NAUTOBOT_ALLOW_REQUEST_PROFILING"
    is_constance_config: true
    see_also:
      "Administration guide to request profiling": "../guides/request-profiling.md"
    type: "boolean"
    version_added: "2.2.0"
  ALLOWED_HOSTS:
    default: []
    description: >-
      A list of valid fully-qualified domain names (FQDNs) and/or IP addresses that can be used to reach the
      Nautobot service. (If provided as an environment variable, it should be a space-separated string, for example
      `NAUTOBOT_ALLOWED_HOSTS="localhost 127.0.0.1 example.com"`)
    details: |-
      Usually this is the same as the hostname for the Nautobot server, but can also be different; for example,
      when using a reverse proxy serving the Nautobot website under a different FQDN than the hostname of the
      Nautobot server. To help guard against [HTTP Host header attacks](https://docs.djangoproject.com/en/stable/topics/security/#host-headers-virtual-hosting),
      Nautobot will not permit access to the server via any other hostnames or IPs.

      Keep in mind that by default Nautobot sets
      [`USE_X_FORWARDED_HOST`](https://docs.djangoproject.com/en/stable/ref/settings/#use-x-forwarded-host)
      to `True`, which means that if you're using a reverse proxy, the FQDN used to reach that reverse proxy needs
      to be in this list.

      !!! warning
          This parameter must always be defined as a list or tuple, even if only a single value is provided.

      Example:

      ```python
      ALLOWED_HOSTS = ['nautobot.example.com', '192.0.2.123']
      ```

      !!! tip
          If there is more than one hostname in this list, you may also need to set
          [CSRF_TRUSTED_ORIGINS](optional-settings.md#csrf_trusted_origins) as well.

      If you are not yet sure what the domain name and/or IP address of the Nautobot installation will be,
      and are comfortable accepting the risks in doing so, you can set this to a wildcard (asterisk) to
      allow all host values:

      ```python
      ALLOWED_HOSTS = ['*']
      ```

      !!! warning
          It is not recommended to leave this value as `['*']` for production deployments.
    environment_variable: "NAUTOBOT_ALLOWED_HOSTS"
    is_required_setting: true
    items:
      type: "string"
    see_also:
      "Django documentation for `ALLOWED_HOSTS`": "https://docs.djangoproject.com/en/stable/ref/settings/#allowed-hosts"
    type: "array"
  ALLOWED_URL_SCHEMES:
    default:
    - "file"
    - "ftp"
    - "ftps"
    - "http"
    - "https"
    - "irc"
    - "mailto"
    - "sftp"
    - "ssh"
    - "tel"
    - "telnet"
    - "tftp"
    - "vnc"
    - "xmpp"
    description: >-
      A list of permitted URL schemes referenced when rendering links within Nautobot.
      Note that only the schemes specified in this list will be accepted; if adding your own,
      be sure to replicate all of the default values as well (excluding those schemes which are not desirable).
    items:
      type: "string"
    type: "array"
  AUTHENTICATION_BACKENDS:
    default:
    - "nautobot.core.authentication.ObjectPermissionBackend"
    description: >-
      A list of authentication backend classes (as strings) to use when attempting to authenticate a user.
      The entry `"nautobot.core.authentication.ObjectPermissionBackend"` **must** always be the last in this list.
    items:
      type: "string"
    see_also:
      "Django documentation for `AUTHENTICATION_BACKENDS`": "https://docs.djangoproject.com/en/stable/ref/settings/#std-setting-AUTHENTICATION_BACKENDS"
      "LDAP Authentication": "./authentication/ldap.md"
      "Remote User Authentication": "./authentication/remote.md"
      "Single Sign On (SSO)": "./authentication/sso.md"
    type: "array"
  BANNER_BOTTOM:
    default: ""
    description: "Custom content to be displayed in a banner at the bottom of the page. HTML is allowed."
    environment_variable: "NAUTOBOT_BANNER_BOTTOM"
    is_constance_config: true
    type: "string"
  BANNER_LOGIN:
    default: ""
    description: "Custom content to be displayed on the login page above the login form. HTML is allowed."
    environment_variable: "NAUTOBOT_BANNER_LOGIN"
    is_constance_config: true
    type: "string"
  BANNER_TOP:
    default: ""
    description: "Custom content to be displayed in a banner at the top of the page. HTML is allowed."
    environment_variable: "NAUTOBOT_BANNER_TOP"
    is_constance_config: true
    type: "string"
  BRANDING_FILEPATHS:
    default:
      favicon: null
      header_bullet: null
      icon_16: null
      icon_32: null
      icon_180: null
      icon_192: null
      icon_mask: null
      logo: null
      nav_bullet: null
    description: >-
      A set of filepaths relative to the [`MEDIA_ROOT`](#media_root) which locate image assets used for
      custom branding. Each of these assets takes the place of the corresponding stock Nautobot asset.
      This allows for, for instance, providing your own navbar logo and favicon.
      If a custom image asset is not provided for any of the above options, the stock Nautobot asset is used.
    properties:
      favicon:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "Browser favicon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_FAVICON"
      header_bullet:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "Bullet image used for various view headers"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET"
      icon_16:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "16x16px icon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_16"
      icon_180:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "180x180px icon - used for the apple-touch-icon header"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_180"
      icon_192:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "192x192px icon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_192"
      icon_32:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "32x32px icon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_32"
      icon_mask:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "Mono-chrome icon used for the mask-icon header"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK"
      logo:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "Navbar logo"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_LOGO"
      nav_bullet:
        "$ref": "#/definitions/relative_path"
        default: ""
        description: "Bullet image used for nav menu headers"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET"
    type: "object"
    version_added: "1.2.0"
  BRANDING_PREPENDED_FILENAME:
    default: "nautobot_"
    description: "Defines the prefix of the filename when exporting to CSV/YAML or export templates."
    environment_variable: "NAUTOBOT_BRANDING_PREPENDED_FILENAME"
    type: "string"
    version_added: "1.3.4"
  BRANDING_TITLE:
    default: "Nautobot"
    description: >-
      Defines the custom branding title that should be used in place of 'Nautobot' within user facing areas
      of the application, such as the HTML title of web pages.
    environment_variable: "NAUTOBOT_BRANDING_TITLE"
    type: "string"
    version_added: "1.2.0"
  BRANDING_URLS:
    default:
      code: "https://github.com/nautobot/nautobot"
      docs: null
      help: "https://github.com/nautobot/nautobot/wiki"
    description: >-
      A set of URLs that correspond to helpful links in the right of the footer on every web page.
      If a custom URL is not provided for any of the links, the default link within the Nautobot community is used.
    properties:
      code:
        default: "https://github.com/nautobot/nautobot"
        description: "Code link in the footer"
        environment_variable: "NAUTOBOT_BRANDING_URLS_CODE"
        format: "uri"
        type: "string"
      docs:
        "$ref": "#/definitions/relative_path"
        default: "static/docs/index.html"
        description: "Docs link in the footer"
        environment_variable: "NAUTOBOT_BRANDING_URLS_DOCS"
      help:
        default: "https://github.com/nautobot/nautobot/wiki"
        description: "Help link in the footer"
        environment_variable: "NAUTOBOT_BRANDING_URLS_HELP"
        format: "uri"
        type: "string"
    type: "object"
    version_added: "1.2.0"
  CACHES:
    additionalProperties: true
    default:
      default:
        BACKEND: "django_redis.cache.RedisCache"
        LOCATION: "redis://localhost:6379/1"
        OPTIONS:
          CLIENT_CLASS: "django_redis.client.DefaultClient"
          PASSWORD: ""
        TIMEOUT: 300
    description: "The `CACHES` setting is required to simplify the configuration for `django-redis`."
    details: |-
      The [`django-redis`](https://github.com/jazzband/django-redis) Django plugin is used to enable Redis
      as a concurrent write lock for preventing race conditions when allocating IP address objects.

      !!! important
          Nautobot also utilizes the built-in
          [Django cache framework](https://docs.djangoproject.com/en/stable/topics/cache/)
          (which also relies on the `CACHES` setting) to perform caching.

      +/- 2.0.0
          The default value of `CACHES["default"]["LOCATION"]` has changed from `redis://localhost:6379/0`
          to `redis://localhost:6379/1`, as Django's native caching is now taking the role previously occupied by
          `django-cacheops`.
    is_required_setting: true
    properties:
      default:
        properties:
          BACKEND:
            default: "django_redis.cache.RedisCache"
            enum:
            - "django_redis.cache.RedisCache"
            - "django_prometheus.cache.backends.redis.RedisCache"
            environment_variable: "NAUTOBOT_CACHES_BACKEND"
            type: "string"
          LOCATION:
            default: "redis://localhost:6379/1"
            format: "uri"
            type: "string"
          OPTIONS:
            additionalProperties: true
            properties:
              CLIENT_CLASS:
                default: "django_redis.client.DefaultClient"
                type: "string"
              PASSWORD:
                default: ""
                type: "string"
            type: "object"
          TIMEOUT:
            default: 300
            type: "integer"
        type: "object"
    see_also:
      "Guide to Nautobot Caching, including TLS and HA configuration": "../../administration/guides/caching.md"
    type: "object"
  CELERY_BEAT_HEARTBEAT_FILE:
    default: "/tmp/nautobot_celery_beat_heartbeat"
    description: "A file touched by Celery Beat during health check."
    environment_variable: "NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE"
    type: "string"
  CELERY_BROKER_TRANSPORT_OPTIONS:
    additionalProperties: true
    default: {}
    description: "A dict of additional options passed to the Celery broker transport."
    details: >-
      This is only required when
      [configuring Celery to utilize Redis Sentinel](../../administration/guides/caching.md#celery-sentinel-configuration).
    properties:
      master_name:
        type: "string"
      sentinel_kwargs:
        additionalProperties: true
        properties:
          password:
            type: "string"
        type: "object"
    type: "object"
  CELERY_BROKER_URL:
    default: "redis://localhost:6379/0"
    description: "Celery broker URL used to tell workers where queues are located."
    environment_variable: "NAUTOBOT_CELERY_BROKER_URL"
    format: "uri"
    type: "string"
  CELERY_BROKER_USE_SSL:
    default: null
    description: "Optional configuration for Celery to use custom SSL certificates to connect to Redis."
    properties:
      ssl_ca_certs:
        "$ref": "#/definitions/absolute_path"
      ssl_cert_reqs:
        type: "boolean"
      ssl_certfile:
        "$ref": "#/definitions/absolute_path"
      ssl_keyfile:
        "$ref": "#/definitions/absolute_path"
    see_also:
      "Celery documentation": "https://docs.celeryq.dev/en/stable/userguide/configuration.html#std-setting-broker_use_ssl"
    type: "object"
  CELERY_REDIS_BACKEND_USE_SSL:
    default: false
    description: "Optional configuration for Celery to use custom SSL certificates to connect to Redis."
    properties:
      ssl_ca_certs:
        "$ref": "#/definitions/absolute_path"
      ssl_cert_reqs:
        type: "boolean"
      ssl_certfile:
        "$ref": "#/definitions/absolute_path"
      ssl_keyfile:
        "$ref": "#/definitions/absolute_path"
    see_also:
      "Celery documentation": "https://docs.celeryq.dev/en/stable/userguide/configuration.html#std-setting-redis_backend_use_ssl"
    type: "object"
  CELERY_TASK_DEFAULT_QUEUE:
    default: "default"
    description: >-
      The default celery queue name that will be used by workers if no queue is specified in the
      `nautobot-server celery worker` command. This queue will also be used by celery tasks
      if no queue is specified when a task is run.
    environment_variable: "NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE"
    type: "string"
    version_added: "1.5.0"
  CELERY_TASK_SOFT_TIME_LIMIT:
    default: 300
    description: "The global Celery task soft timeout (in seconds)."
    details: >-
      Any background task that exceeds this duration will receive a `SoftTimeLimitExceeded` exception and is
      responsible for handling this exception and performing any necessary cleanup or final operations before ending.
    environment_variable: "NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT"
    see_also:
      "`CELERY_TASK_TIME_LIMIT`": "#celery_task_time_limit"
    type: "integer"
  CELERY_TASK_TIME_LIMIT:
    default: 600
    description: "The global Celery task hard timeout (in seconds)."
    details: "Any background task that exceeds this duration will be forcibly killed with a `SIGKILL` signal."
    environment_variable: "NAUTOBOT_CELERY_TASK_TIME_LIMIT"
    see_also:
      "`CELERY_TASK_SOFT_TIME_LIMIT`": "#celery_task_soft_time_limit"
    type: "integer"
  CELERY_WORKER_PROMETHEUS_PORTS:
    default: []
    description: "Ports for Prometheus metric HTTP server running on the celery worker(s)."
    details: >-
      Normally this should be set to a single port, unless you have multiple workers running on a single machine,
      i.e.  sharing the same available ports. In that case you need to specify a range of ports greater than or
      equal to the highest amount of workers you are running on a single machine (comma-separated, like
      "8080,8081,8082"). You can then use the `target_limit` parameter to the Prometheus `scrape_config`
      to ensure you are not getting duplicate metrics in that case. Set this to an empty list to disable it.
    environment_variable: "NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS"
    items:
      type: "integer"
    type: "array"
    version_added: "1.5.10"
  CELERY_WORKER_REDIRECT_STDOUTS:
    default: true
    description: "If enabled stdout and stderr of running jobs will be redirected to the task logger."
    environment_variable: "NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS"
    type: "boolean"
    version_added: "2.0.0"
  CELERY_WORKER_REDIRECT_STDOUTS_LEVEL:
    default: "WARNING"
    description: "The log level of log messages generated by redirected job stdout and stderr."
    enum:
    - "DEBUG"
    - "INFO"
    - "WARNING"
    - "ERROR"
    - "CRITICAL"
    environment_variable: "NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL"
    type: "string"
    version_added: "2.0.0"
  CHANGELOG_RETENTION:
    default: 90
    description: >-
      The number of days to retain logged changes (object creations, updates, and deletions).
      Set this to `0` to retain changes in the database indefinitely.
    details: |-
      !!! warning
          If enabling indefinite changelog retention, it is recommended to periodically delete old entries.
          Otherwise, the database may eventually exceed capacity.
    environment_variable: "NAUTOBOT_CHANGELOG_RETENTION"
    is_constance_config: true
    type: "integer"
  CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:
    default: false
    description: >-
      If `True`, it will be possible to apply Config Context objects to Devices and Virtual Machines
      via Dynamic Group membership. When set to `False` this behavior will not be available.
    details: |-
      !!! warning
          With a large number of dynamic groups, enabling this could invoke a performance penalty when
          processing Config Contexts.
    environment_variable: "NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED"
    type: "boolean"
  CONTENT_TYPE_CACHE_TIMEOUT:
    default: 0
    description: >-
      The number of seconds to cache the content type accessible via a object's class property
      `Object._content_type_cached`. This can save frequent calls to `ContentType.objects.get_for_model(model)`.
      Set this to `0` to disable caching.
    environment_variable: "NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT"
    type: "integer"
    version_added: "1.6.0"
  CORS_ALLOW_ALL_ORIGINS:
    default: false
    description: "If `True`, all origins will be allowed. Other settings restricting allowed origins will be ignored."
    details: >-
      Setting this to `True` can be dangerous, as it allows any website to make cross-origin requests to yours.
      Generally you'll want to restrict the list of allowed origins with
      [`CORS_ALLOWED_ORIGINS`](#cors_allowed_origins) or
      [`CORS_ALLOWED_ORIGIN_REGEXES`](#cors_allowed_origin_regexes).
    environment_variable: "NAUTOBOT_CORS_ALLOW_ALL_ORIGINS"
    type: "boolean"
  CORS_ALLOWED_ORIGIN_REGEXES:
    default: []
    description: >-
      A list of strings representing regexes that match Origins that are authorized to make cross-site HTTP requests.
    details: |-
      Useful when [`CORS_ALLOWED_ORIGINS`](#cors_allowed_origins) is impractical, such as when you have a
      large number of subdomains.

      Example:

      ```python
      CORS_ALLOWED_ORIGIN_REGEXES = [r"^https://\w+\.example\.com$"]
      ```
    items:
      "$ref": "#/definitions/regex"
    type: "array"
  CORS_ALLOWED_ORIGINS:
    default: []
    description: "A list of origins that are authorized to make cross-site HTTP requests."
    details: |-
      An Origin is defined by [the CORS RFC Section 3.2](https://tools.ietf.org/html/rfc6454#section-3.2) as a
      URI `scheme + hostname + port`, or one of the special values `'null'` or `'file://'`.
      Default ports (HTTPS = 443, HTTP = 80) are optional here.

      The special value `null` is sent by the browser in
      ["privacy-sensitive contexts"](https://tools.ietf.org/html/rfc6454#section-6), such as when the client
      is running from a `file://` domain.
      The special value `file://` is sent accidentally by some versions of Chrome on Android as per this bug.

      Example:

      ```python
      CORS_ALLOWED_ORIGINS = [
          'https://example.com',
          'https://sub.example.com',
          'http://localhost:8080',
          'http://127.0.0.1:9000'
      ]
      ```
    items:
      format: "uri"
      type: "string"
    type: "array"
  CSRF_TRUSTED_ORIGINS:
    default: []
    description: >-
      A list of hosts (fully-qualified domain names (FQDNs) or subdomains) that are considered trusted origins
      for cross-site secure requests such as HTTPS POST.
    items:
      type: "string"
    see_also:
      "Django documentation for `CSRF_TRUSTED_ORIGINS`": "https://docs.djangoproject.com/en/stable/ref/settings/#csrf-trusted-origins"
      "Django documentation for CSRF protection": "https://docs.djangoproject.com/en/stable/ref/csrf/#how-it-works"
    type: "array"
  DATABASE_ROUTERS:
    default: []
    description: >-
      Custom database router to generate the before & after queries for generating diffs.
      Used for Nautobot Version Control App.
    items:
      type: "string"
    type: "array"
  DATABASES:
    additionalProperties: true
    default:
      default:
        CONN_MAX_AGE: 300
        ENGINE: "django.db.backends.postgresql"
        HOST: "localhost"
        NAME: "nautobot"
        PASSWORD: ""
        PORT: ""
        USER: ""
    description: |-
      Nautobot requires access to a supported database service to store data.
      This service can run locally on the Nautobot server or on a remote system.

      Nautobot supports either MySQL or PostgreSQL as a database backend. You must make sure that the `ENGINE`
      setting matches your selected database backend or **you will be unable to connect to the database**.
    details: |-
      !!! note
          Nautobot supports all database options supported by the underlying Django framework.
          For a complete list of available parameters, please see the
          [official Django documentation on `DATABASES`](https://docs.djangoproject.com/en/stable/ref/settings/#databases).

      !!! warning
          By default, MySQL is case-insensitive in its handling of text strings. This is different from
          PostgreSQL which is case-sensitive by default. We strongly recommend that you configure MySQL to be
          case-sensitive for use with Nautobot, either when you enable the MySQL server, or when you create the
          Nautobot database in MySQL. If you follow the provided installation instructions for CentOS or Ubuntu,
          the recommended steps there will include the appropriate database configuration.

      !!! tip
          When using MySQL as a database backend, and you want to enable support for Unicode characters like
          the beloved poop emoji, you'll need to update your settings.

          If you try to use emojis without this setting, you will encounter a server error along the lines of
          `Incorrect string value`, because you are running afoul of the legacy implementation of Unicode
          (aka `utf8`) encoding in MySQL. The `utf8` encoding in MySQL is limited to 3-bytes per character.
          Newer Unicode emoji require 4-bytes.

          To properly support using such characters, you will need to create an entry in
          `DATABASES` -> `default` -> `OPTIONS` with the value `{"charset": "utf8mb4"}` in your `nautobot_config.py`
          and restart all Nautobot services. This will tell MySQL to always use `utf8mb4` character set
          for database client connections.

          As of Nautobot 1.1.5 and later, if you have generated a new `nautobot_config.py` using
          `nautobot-server init`, this line is already present in your config and no action is required.
    is_required_setting: true
    properties:
      default:
        additionalProperties: true
        properties:
          CONN_MAX_AGE:
            default: 300
            description: >-
              Lifetime of a
              [persistent database connection](https://docs.djangoproject.com/en/stable/ref/databases/#persistent-connections)
              in seconds
            details: "https://docs.djangoproject.com/en/stable/ref/databases/#persistent-connections"
            environment_variable: "NAUTOBOT_DB_TIMEOUT"
            type: "integer"
          ENGINE:
            default: "django.db.backends.postgresql"
            description: >-
              The database backend to use. Use the `django_prometheus` backends when `METRICS_ENABLED` is `True`.
            enum:
            - "django.db.backends.postgresql"
            - "django.db.backends.mysql"
            - "django_prometheus.db.backends.postgresql"
            - "django_prometheus.db.backends.mysql"
            environment_variable: "NAUTOBOT_DB_ENGINE"
            type: "string"
          HOST:
            default: "localhost"
            description: "Name or IP addrress of the database server (use `localhost` if running locally)"
            environment_variable: "NAUTOBOT_DB_HOST"
            type: "string"
          NAME:
            default: "nautobot"
            description: "Database name"
            environment_variable: "NAUTOBOT_DB_NAME"
            type: "string"
          PASSWORD:
            default: ""
            description: "Database password"
            environment_variable: "NAUTOBOT_DB_PASSWORD"
            type: "string"
          PORT:
            default: ""
            description: >-
              The port to use when connecting to the database.
              An empty string means the default port for your selected backend (PostgreSQL: `5432`, MySQL: `3306`).
            environment_variable: "NAUTOBOT_DB_PORT"
            type: "string"
          USER:
            default: ""
            description: "Database username"
            environment_variable: "NAUTOBOT_DB_USER"
            type: "string"
        type: "object"
    see_also:
      "Django documentation for `DATABASES`": "https://docs.djangoproject.com/en/stable/ref/settings/#databases"
    type: "object"
  DATE_FORMAT:
    default: "N j, Y"
    description: "Custom format for dates. The default results in strings like \"January 22, 2024\"."
    environment_variable: "NAUTOBOT_DATE_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  DATETIME_FORMAT:
    default: "N j, Y g:i a"
    description: "Custom format for date-times. The default results in strings like \"January 22, 2024 1:22 p.m.\"."
    environment_variable: "NAUTOBOT_DATETIME_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  DEBUG:
    default: false
    description: >-
      This setting enables debugging. Debugging should be enabled only during development or troubleshooting.
    details: |-
      Note that only clients which access Nautobot from a recognized [internal IP address](#internal_ips)
      will see debugging tools in the user interface.

      !!! warning
          Never enable debugging on a production system, as it can expose sensitive data to unauthenticated users
          and imposes a substantial performance penalty.
    environment_variable: "NAUTOBOT_DEBUG"
    see_also:
      "Django documentation for `DEBUG`": "https://docs.djangoproject.com/en/stable/ref/settings/#debug"
    type: "boolean"
  DEPLOYMENT_ID:
    default: ""
    description: >-
      Setting to uniquely but anonymously identify Nautobot deployments when sending installation metrics.
    details: |-
      Defaults to a random UUID generated at installation time.

      This setting is used to uniquely but anonymously identify Nautobot deployments when sending
      installation metrics. This setting is not generally intended to be user-serviceable.
    environment_variable: "NAUTOBOT_DEPLOYMENT_ID"
    is_constance_config: true
    see_also:
      "`nautobot-server send_installation_metrics`": "../tools/nautobot-server.md#send_installation_metrics"
    type: "string"
    version_added: "1.6.0"
  DEVICE_NAME_AS_NATURAL_KEY:
    default: false
    description: >-
      `Device` names are not guaranteed globally-unique by Nautobot but in practice they often are.
      Set this to `True` to use the device `name` alone as the natural key for `Device` objects.
      Set this to `False` to use the sequence `(name, tenant, location)` as the natural key instead.
    environment_variable: "NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"
    is_constance_config: true
    type: "boolean"
    version_added: "2.0.0"
  DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT:
    default: 0
    description: >-
      The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.
    details: >-
      With large datasets (those in scope of a Dynamic Group and number of Dynamic Groups themselves),
      users will encounter a performance penalty using or accessing the membership lists.
      This setting allows users to accept a cached list for common use cases (particularly in the UI)
      that expires after the configured time."
    environment_variable: "NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"
    is_constance_config: true
    type: "integer"
    version_added: "1.6.0"
  EXEMPT_VIEW_PERMISSIONS:
    default: []
    description: "A list of Nautobot models to exempt from the enforcement of view permissions."
    details: |-
      Models listed here will be viewable by all users, both authenticated and anonymous.
      List models in the form `<app>.<model>`.

      Example:

      ```python
      EXEMPT_VIEW_PERMISSIONS = [
          'dcim.location',
          'dcim.location_type',
          'ipam.prefix',
      ]
      ```

      To exempt _all_ models from view permission enforcement, set the following.
      (Note that `EXEMPT_VIEW_PERMISSIONS` must be an iterable.)

      ```python
      EXEMPT_VIEW_PERMISSIONS = ['*']
      ```

      !!! note
          Using a wildcard will not affect certain potentially sensitive models, such as user permissions.
          If there is a need to exempt these models, they must be specified individually.
    items:
      type: "string"
    type: "array"
  EXTERNAL_AUTH_DEFAULT_GROUPS:
    default: []
    description: "The list of group names to assign a new user account when created using 3rd-party authentication."
    items:
      type: "string"
    type: "array"
  EXTERNAL_AUTH_DEFAULT_PERMISSIONS:
    additionalProperties: true
    default: {}
    description: "A mapping of permissions to assign a new user account when created using SSO authentication."
    details: |-
      Each key in the dictionary will be the permission name specified as `<app_label>.<action>_<model>`,
      and the value should be set to the permission [constraints](../guides/permissions.md#constraints),
      or `None` to allow all objects.

      Example:

      | Permission | Description |
      |---|---|
      | `{'dcim.view_device': {}}` or `{'dcim.view_device': None}` | Users can view all devices |
      | `{'dcim.add_device': {}}` | Users can add devices, see note below |
      | `{'dcim.view_device': {'location__name__in': ['HQ'], 'location__location_type__name__in': ['Building']}}` | Users can view all devices in the HQ Building |

      !!! warning
          Permissions can be complicated! Be careful when restricting permissions to also add any required
          prerequisite permissions.

          For example, when adding Devices the Role, Device Type, Location, and Status fields are all required fields
          in order for the UI to function properly. Users will also need view permissions for those models or the
          corresponding field selections in the UI will be unavailable and potentially prevent objects from being
          able to be created or edited.

      The following example gives a user a reasonable amount of access to add devices to a single location
      (Building HQ in this case):

      ```python
      {
          'dcim.add_device': {'location__name__in':  ['HQ'], 'location__location_type__name__in': ['Building']},
          'dcim.view_device': {'location__name__in':  ['HQ'], 'location__location_type__name__in': ['Building']},
          'dcim.view_devicetype': None,
          'extras.view_role': None,
          'extras.view_status': None,
          'dcim.view_location': {'name__in':  ['HQ'], 'location_type__name__in': ['Building']},
          'dcim.view_manufacturer': None,
          'dcim.view_region': None,
          'dcim.view_rack': None,
          'dcim.view_rackgroup': None,
          'dcim.view_platform': None,
          'virtualization.view_cluster': None,
          'virtualization.view_clustergroup': None,
          'tenancy.view_tenant': None,
          'tenancy.view_tenantgroup': None,
      }
      ```
    see_also:
      "Guide to object permissions": "../guides/permissions.md"
    type: "object"
  FORCE_SCRIPT_NAME:
    default: null
    description: >-
      If not None, this will be used as the value of the SCRIPT_NAME environment variable in any HTTP request.
    details: |-
      This setting can be used to override the server-provided value of `SCRIPT_NAME`, which is most commonly used
      for hosting Nautobot in a subdirectory (e.g. _example.com/nautobot/_).

      !!! important
          To host Nautobot under a subdirectory you must set this value to match the same prefix configured on
          your HTTP server. For example, if you configure NGINX to serve Nautobot at `/nautobot/`, you must
          set `FORCE_SCRIPT_NAME = "/nautobot/"`.
    see_also:
      "Django documentation for `FORCE_SCRIPT_NAME`": "https://docs.djangoproject.com/en/stable/ref/settings/#force-script-name"
    type: "string"
  GIT_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/git"
    description: >-
      The file path to a directory where cloned [Git repositories](../../platform-functionality/gitrepository.md)
      will be located.
    environment_variable: "NAUTOBOT_GIT_ROOT"
  GRAPHQL_COMPUTED_FIELD_PREFIX:
    default: "cpf"
    description: "The prefix used for all computed fields in GraphQL. e.g. `my_field` => `cpf_my_field`"
    type: "string"
  GRAPHQL_CUSTOM_FIELD_PREFIX:
    default: "cf"
    description: "The prefix used for all custom fields in GraphQL. e.g. `my_field` => `cf_my_field`"
    type: "string"
  GRAPHQL_RELATIONSHIP_PREFIX:
    default: "rel"
    description: >-
      The prefix used for all relationship associations in GraphQL. e.g. `my_relationship` => `rel_my_relationship`.
    type: "string"
  HTTP_PROXIES:
    default: null
    description: >-
      A dictionary of HTTP proxies to use for outbound requests originating from Nautobot
      (such as when sending webhook requests).
    details: |-
      Proxies should be specified by schema (HTTP and HTTPS) as per the
      [Python `requests` library documentation](https://2.python-requests.org/en/master/user/advanced/).

      Example:

      ```python
      HTTP_PROXIES = {
          'http': 'http://10.10.1.10:3128',
          'https': 'http://10.10.1.10:1080',
      }
      ```

      !!! note
          When using Git repositories within Nautobot the Python library `GitPython` needs extra proxy configuration:

          ```bash
              git config --global http.proxy http://192.0.2.1:3128
              git config --global https.proxy http://192.0.2.1:3128
          ```
    properties:
      http:
        type: "string"
      https:
        type: "string"
    type: "object"
  INSTALLATION_METRICS_ENABLED:
    default: true
    description: "Controls sending of anonymized installation metrics to the Nautobot maintainers."
    details: >-
      Default value is user-specified when running `nautobot-server init` for a new deployment.
      Defaults to `True` when upgrading pre-1.6.0 deployments without configuring a value.

      When set to `True`, Nautobot will send anonymized installation metrics to the Nautobot maintainers
      when running the [`post_upgrade`](../tools/nautobot-server.md#post_upgrade) or
      [`send_installation_metrics`](../tools/nautobot-server.md#send_installation_metrics) management commands.
    environment_variable: "NAUTOBOT_INSTALLATION_METRICS_ENABLED"
    see_also:
      "`nautobot-server send_installation_metrics`": "../tools/nautobot-server.md#send_installation_metrics"
    type: "boolean"
    version_added: "1.6.0"
  INTERNAL_IPS:
    default:
    - "127.0.0.1"
    - "::1"
    description: >-
      A list of IP addresses recognized as internal to the system, used to control the display of debugging output.
    details: >-
      For example, the [Django debugging toolbar](https://django-debug-toolbar.readthedocs.io/), if installed,
      will be viewable only when a client is accessing Nautobot from one of the listed IP addresses
      (and [`DEBUG`](#debug) is true).
    items:
      type: "string"
    type: "array"
  JOB_CREATE_FILE_MAX_SIZE:
    default: 10485760
    description: >-
      The maximum file size (in bytes) that a running Job will be allowed to create in a single call
      to `Job.create_file()`.
    environment_variable: "NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE"
    is_constance_config: true
    see_also:
      "`JOB_FILE_IO_STORAGE`": "#job_file_io_storage"
    type: "integer"
    version_added: "2.1.0"
  JOB_FILE_IO_STORAGE:
    default: "db_file_storage.storage.DatabaseFileStorage"
    description: >-
      The backend storage engine for handling files provided as input to Jobs and files generated as output by Jobs.
    details: |-
      !!! warning
          For backwards compatibility with storage of Job inputs in prior versions of Nautobot, this
          currently defaults to using `DatabaseFileStorage` to store such files directly in Nautobot's database;
          however this is not typically the best option (see below) and may change in a future major release.

      If your Nautobot server instance(s) and your Celery worker instance(s) share a common
      [`MEDIA_ROOT`](#media_root) filesystem (as would typically be the case in a single-server installation of
      Nautobot) then we recommend changing this to `"django.core.files.storage.FileSystemStorage"` to store
      Job files on the filesystem (which will place them into a `files/` subdirectory under
      [`MEDIA_ROOT`](#media_root)) instead of in the database.

      If your Nautobot server instance(s) and Celery worker instance(s) do _not_ share a common filesystem,
      we recommend using one of the [`django-storages`](https://django-storages.readthedocs.io/en/stable/) options
      such as S3 to provide a storage backend that can be accessed by the server(s) and worker(s) alike.

      !!! tip
          For an example of using `django-storages` with AWS S3 buckets, visit the
          [django-storages with S3](../guides/s3-django-storage.md) user-guide.

      If you have neither a common `MEDIA_ROOT` filesystem nor an appropriate remote storage option, then
      it's permissible to leave this at its default, but know that storing files in the database is provided here
      as a "least-worst" option only.

      !!! caution
          It's typically safe to change this setting when initially updating to Nautobot 2.1.0 or later, as
          there should be no pre-existing Job output files, although any existing scheduled Jobs that have
          file _inputs_ may need to be deleted and recreated after doing so. However, once you've run any Jobs
          that output to a file, changing storage backends will of course break any existing links to
          Job output files in the previous storage backend.
          Migrating Job stored files from one backend to another is out of scope for this document.
    environment_variable: "NAUTOBOT_JOB_FILE_IO_STORAGE"
    see_also:
      "`STORAGE_BACKEND`": "#storage_backend"
      "`JOB_CREATE_FILE_MAX_SIZE`": "#job_create_file_max_size"
    type: "string"
    version_added: "2.1.0"
  JOBS_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/jobs"
    description: "The file path to a directory where Jobs can be discovered."
    details: |-
      +/- 2.0.0
          This directory no longer requires an `__init__.py` file.
    environment_variable: "NAUTOBOT_JOBS_ROOT"
  LOCATION_NAME_AS_NATURAL_KEY:
    default: false
    description: >-
      `Location` names are not guaranteed globally-unique by Nautobot but in practice they often are.
      Set this to `True` to use the location `name` alone as the natural key for `Location` objects.
      Set this to `False` to use the sequence `(name, parent__name, parent__parent__name, ...)` as
      the natural key instead.
    environment_variable: "NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"
    is_constance_config: true
    type: "boolean"
    version_added: "2.0.0"
  LOG_DEPRECATION_WARNINGS:
    default: false
    description: >-
      Set the environment variable `NAUTOBOT_LOG_DEPRECATION_WARNINGS` to change this setting.
      This can be set to `True` to allow deprecation warnings raised by Nautobot to (additionally)
      be logged as `WARNING` level log messages.
    details: |-
      !!! warning
          This setting cannot be effectively configured in `nautobot_config.py` due to the order of code evaluation
          at startup time. To enable this setting, always use the `NAUTOBOT_LOG_DEPRECATION_WARNINGS`
          environment variable.

      Deprecation warnings are normally silent in Python, but can be enabled globally by
      [various means](https://docs.python.org/3/library/warnings.html) such as setting the `PYTHONWARNINGS`
      environment variable. However, doing so can be rather noisy, as it will also include warnings from within
      Django about various code in various package dependencies of Nautobot's, etc.

      This configuration setting allows a more targeted enablement of only warnings from within Nautobot itself,
      which can be useful when vetting various Nautobot Apps for future-proofness against upcoming changes to Nautobot.
    environment_variable: "NAUTOBOT_LOG_DEPRECATION_WARNINGS"
    type: "boolean"
    version_added: "1.5.2"
  LOGGING:
    additionalProperties: true
    default:
      version: 1
      disable_existing_loggers: false
      formatters:
        normal:
          datefmt: "%H:%M:%S"
          format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s"
        verbose:
          datefmt: "%H:%M:%S"
          format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s"
      handlers:
        normal_console:
          class: "logging.StreamHandler"
          formatter: "normal"
          level: "INFO"
        verbose_console:
          class: "logging.StreamHandler"
          formatter: "verbose"
          level: "DEBUG"
      loggers:
        django:
          handlers:
          - "normal_console"
          level: "INFO"
        nautobot:
          handlers:
          - "normal_console"
          level: "INFO"
    default_literal: |-
      ```python
      {
          'version': 1,
          'disable_existing_loggers': False,
          'formatters': {
              'normal': {
                  'datefmt': '%H:%M:%S',
                  'format': '%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s',
              },
              'verbose': {
                  'datefmt': '%H:%M:%S',
                  'format': '%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s '
                            '%(funcName)30s() :\n  %(message)s',
              },
          },
          'handlers': {
              'normal_console': {
                  'class': 'logging.StreamHandler',
                  'formatter': 'normal',
                  'level': 'INFO',
              },
              'verbose_console': {
                  'class': 'logging.StreamHandler',
                  'formatter': 'verbose',
                  'level': 'DEBUG',
              },
          },
          'loggers': {
              'django': {'handlers': ['normal_console'], 'level': 'INFO'},
              'nautobot': {'handlers': ['normal_console'], 'level': 'INFO'},
          },
      }
      ```
    description: "A dictionary containing the configuration settings for logging in Nautobot."
    details: |-
      The default translates to:

      * All messages from Django and from Nautobot of INFO severity or higher will be logged to the console.
      * If [`DEBUG`](#debug) is True, Nautobot DEBUG messages will also be logged, and all Nautobot messages
        will be logged with a more verbose format including the filename and function name that originated
        each log message.

      The default log formatters split each log message across two lines of output for greater readability,
      which is useful for local observation and troubleshooting, but you may find it impractical to use in
      production environments that expect one line per log message. Fortunately, the Django framework allows for
      extensive customization of logging format and destination.

      Below is an example configuration extension which will additionally write all INFO and higher messages to
      a local file:

      ```python
      LOGGING["handlers"]["file"] = {
          "level": "INFO",
          "class": "logging.FileHandler",
          "filename": "/var/log/nautobot.log",
          "formatter": "normal",
      }
      LOGGING["loggers"]["django"]["handlers"] += ["file"]
      LOGGING["loggers"]["nautobot"]["handlers"] += ["file"]
      ```

      #### Available Loggers

      * `django.*` - Generic Django operations (HTTP requests/responses, etc.)
      * `nautobot.<app>.<module>` - Generic form for model- or module-specific log messages
      * `nautobot.auth.*` - Authentication events
      * `nautobot.extras.jobs.*` - Job execution (`* = JobClassName`)
      * `nautobot.core.graphql.*` - [GraphQL](../../platform-functionality/graphql.md) initialization and operation.
      * `nautobot.extras.plugins.*` - App loading and activity
      * `nautobot.core.views.generic.*` - Generic views which handle business logic for the web UI
    properties:
      additionalProperties: true
      disable_existing_loggers:
        default: false
        type: "boolean"
      formatters:
        additionalProperties: true
        default:
          normal:
            datefmt: "%H:%M:%S"
            format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s"
          verbose:
            datefmt: "%H:%M:%S"
            format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s"
        type: "object"
      handlers:
        additionalProperties: true
        default:
          normal_console:
            class: "logging.StreamHandler"
            formatter: "normal"
            level: "INFO"
          verbose_console:
            class: "logging.StreamHandler"
            formatter: "verbose"
            level: "DEBUG"
        type: "object"
      loggers:
        additionalProperties: true
        default:
          django:
            handlers:
            - "normal_console"
            level: "INFO"
          nautobot:
            handlers:
            - "normal_console"
            level: "INFO"
        type: "object"
      version:
        default: 1
        type: "integer"
    see_also:
      "Additional Nautobot logging examples": "https://github.com/nautobot/nautobot/tree/develop/examples/logging"
      "Django documentation for logging": "https://docs.djangoproject.com/en/stable/topics/logging/"
    type: "object"
  MAINTENANCE_MODE:
    default: false
    description: "Setting this to true causes Nautobot to go into maintenance mode."
    details: |-
      Setting this to `True` will display a "maintenance mode" banner at the top of every page.
      Additionally, Nautobot will no longer update a user's "last active" time upon login.
      This is to allow new logins when the database is in a read-only state.
      Recording of login times will resume when maintenance mode is disabled.

      !!! note
          The default [`SESSION_ENGINE`](#session_engine) configuration will store sessions in the database,
          but this obviously will not work when `MAINTENANCE_MODE` is `True` and the database is in
          a read-only state for maintenance.  Consider setting `SESSION_ENGINE` to
          `django.contrib.sessions.backends.cache` when enabling `MAINTENANCE_MODE`.

      !!! note
          The Docker container normally attempts to run migrations on startup; however, if the database is
          in a read-only state the Docker container will fail to start. Setting the environment variable
          [`NAUTOBOT_DOCKER_SKIP_INIT`](../installation/docker.md#nautobot_docker_skip_init) to `true`
          will prevent the migrations from occurring.

      !!! note
          If you are using `django-auth-ldap` for LDAP authentication, `django-auth-ldap` by default will
          try to update a user object on every log in.  If the database is in a read-only state `django-auth-ldap`
          will fail. You will also need to set `AUTH_LDAP_ALWAYS_UPDATE_USER=False` and `AUTH_LDAP_NO_NEW_USERS=True`
          to avoid this.
    environment_variable: "NAUTOBOT_MAINTENANCE_MODE"
    see_also:
      "`django-auth-ldap` documentation": "https://django-auth-ldap.readthedocs.io/en/stable/reference.html"
    type: "boolean"
  MAX_PAGE_SIZE:
    default: 1000
    description: >-
      A web user or API consumer can request an arbitrary number of objects by appending the `limit` parameter
      to the URL (e.g. `?limit=1000`). This parameter defines the maximum acceptable limit.
      Setting this to `0` or `None` will allow a client to retrieve _all_ matching objects at once with no limit
      by specifying `?limit=0`.
    environment_variable: "NAUTOBOT_MAX_PAGE_SIZE"
    is_constance_config: true
    type: "integer"
  MEDIA_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/media"
    description: "The file path to the location where media files (such as image attachments) are stored."
    see_also:
      "Django documentation for `MEDIA_ROOT`": "https://docs.djangoproject.com/en/stable/ref/settings/#media-root"
  METRICS_AUTHENTICATED:
    default: false
    description: "Toggle requiring authentication to view `/metrics`."
    environment_variable: "NAUTOBOT_METRICS_AUTHENTICATED"
    see_also:
      "Guide to Nautobot Prometheus metrics": "../guides/prometheus-metrics.md"
    type: "boolean"
    version_added: "2.1.5"
  METRICS_DISABLED_APPS:
    default: []
    description: >-
      A list of app names for which Prometheus metrics should be disabled.
      (If provided as an environment variable, it should be a comma-separated string, for example
      `NAUTOBOT_METRICS_DISABLED_APPS="nautobot_ssot, nautobot_device_lifecycle_mgmt"`.)
    environment_variable: "NAUTOBOT_METRICS_DISABLED_APPS"
    items:
      type: "string"
    see_also:
      "Guide to Nautobot Prometheus metrics": "../guides/prometheus-metrics.md"
    type: "array"
    version_added: "2.2.1"
  METRICS_ENABLED:
    default: false
    description: "Toggle the availability of Prometheus-compatible metrics at `/metrics`."
    environment_variable: "NAUTOBOT_METRICS_ENABLED"
    see_also:
      "Guide to Nautobot Prometheus metrics": "../guides/prometheus-metrics.md"
    type: "boolean"
  NAPALM_ARGS:
    additionalProperties: true
    default: {}
    description: "A dictionary of optional arguments to pass to NAPALM when instantiating a network driver."
    details: |-
      Example:

      ```python
      NAPALM_ARGS = {
          'api_key': '472071a93b60a1bd1fafb401d9f8ef41',
          'port': 2222,
      }
      ```

      Some platforms (e.g. Cisco IOS) require an enable password to be passed in addition to the normal password.
      If desired, you can use the configured `NAPALM_PASSWORD` as the value for this argument:

      ```python
      NAPALM_USERNAME = 'username'
      NAPALM_PASSWORD = 'MySecretPassword'
      NAPALM_ARGS = {
          'secret': NAPALM_PASSWORD,          # ios and nxos_ssh
          'enable_password': NAPALM_PASSWORD, # eos
          # Include any additional args here
      }
      ```

      !!! note
          If a given device has an appropriately populated
          [secrets group](../../platform-functionality/secret.md#secrets-groups) assigned to it,
          a [secret](../../platform-functionality/secret.md) defined in that group can override the
          `NAPALM_ARGS['secret']` or `NAPALM_ARGS['enable_password']` default value defined here.
    properties:
      secret:
        type: "string"
      enable_password:
        type: "string"
    see_also:
      "NAPALM Optional Arguments": "https://napalm.readthedocs.io/en/latest/support/#optional-arguments"
    type: "object"
  NAPALM_PASSWORD:
    default: ""
    description: >-
      Nautobot will use this optional credential with `NAPALM_USERNAME` when authenticating to remote devices
      via the NAPALM library, if installed.
    details: |-
      !!! note
          If SSH public key authentication has been set up on the remote device(s) for the system account
          under which Nautobot runs, this parameter is not needed.

      !!! note
          If a given device has an appropriately populated
          [secrets group](../../platform-functionality/secret.md#secretsgroup) assigned to it,
          the [secrets](../../platform-functionality/secret.md) defined in that group will take precedence
          over these default values.
    environment_variable: "NAUTOBOT_NAPALM_PASSWORD"
    type: "string"
  NAPALM_TIMEOUT:
    default: 30
    description: "The amount of time (in seconds) to wait for NAPALM to connect to a device."
    environment_variable: "NAUTOBOT_NAPALM_TIMEOUT"
    type: "integer"
  NAPALM_USERNAME:
    default: ""
    description: >-
      Nautobot will use this optional credential with `NAPALM_PASSWORD` when authenticating to remote devices
      via the NAPALM library, if installed.
    details: |-
      !!! note
          If SSH public key authentication has been set up on the remote device(s) for the system account
          under which Nautobot runs, this parameter is not needed.

      !!! note
          If a given device has an appropriately populated
          [secrets group](../../platform-functionality/secret.md#secretsgroup) assigned to it,
          the [secrets](../../platform-functionality/secret.md) defined in that group will take precedence
          over these default values.
    environment_variable: "NAUTOBOT_NAPALM_USERNAME"
    type: "string"
  NAUTOBOT_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/"
    description: >-
      The filesystem path to use to store Nautobot files (Jobs, uploaded images, Git repositories, etc.).
    details: |-
      This setting is used internally in the core settings to provide default locations for
      [features that require file storage](index.md#file-storage), and the
      [default location of the `nautobot_config.py`](index.md#specifying-your-configuration).

      !!! warning
          Do not override `NAUTOBOT_ROOT` in your `nautobot_config.py`. It will not work as expected.
          If you need to customize this setting, please always set the `NAUTOBOT_ROOT` environment variable.
    environment_variable: "NAUTOBOT_ROOT"
  NETWORK_DRIVERS:
    additionalProperties: true
    default: {}
    description: >-
      An optional dictionary to extend or override the default `Platform.network_driver` translations provided
      by [netutils](https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/).
    details: |-
      For example, to add support for a custom `Platform.network_driver` value of `"my_network_driver"`
      for Netmiko and PyATS drivers:

      ```python
      NETWORK_DRIVERS = {
          'netmiko': {'my_network_driver': 'cisco_ios'},
          'pyats': {'my_network_driver': 'iosxe'},
      }
      ```

      The default top-level keys are `ansible`, `hier_config`, `napalm`, `netmiko`, `netutils_parser`,
      `ntc_templates`, `pyats`, `pyntc`, and `scrapli`, but you can also add additional keys if you have
      an alternative network driver that you want your Nautobot instance to include.
    is_constance_config: true
    type: "object"
    version_added: "1.6.0"
  PAGINATE_COUNT:
    default: 50
    description: >-
      The default maximum number of objects to display per page within each list of objects.
      Applies to both the UI and the REST API.
    environment_variable: "NAUTOBOT_PAGINATE_COUNT"
    is_constance_config: true
    type: "integer"
  PER_PAGE_DEFAULTS:
    default:
    - 25
    - 50
    - 100
    - 250
    - 500
    - 1000
    description: "The options displayed in the web interface dropdown to limit the number of objects per page."
    details: >-
      For proper user experience, this list should include the [`PAGINATE_COUNT`](#paginate_count) and
      [`MAX_PAGE_SIZE`](#max_page_size) values as options.
    environment_variable: "NAUTOBOT_PER_PAGE_DEFAULTS"
    is_constance_config: true
    items:
      type: "integer"
    type: "array"
  PLUGINS:
    default: []
    description: >-
      A list of installed [Nautobot Apps](../../../apps/index.md) to enable.
      Apps will not take effect unless they are listed here.
    details: |-
      !!! warning
          Apps extend Nautobot by allowing external code to run with the same access and privileges as
          Nautobot itself. Only install Apps from trusted sources. The Nautobot maintainers make
          absolutely no guarantees about the integrity or security of your installation with Apps enabled.
    items:
      type: "string"
    type: "array"
  PLUGINS_CONFIG:
    default: {}
    description: "This parameter holds configuration settings for individual Nautobot Apps."
    details: |-
      It is defined as a dictionary, with each key using the name of an installed App.
      The specific parameters supported are unique to each App; reference the App's documentation to determine
      the supported parameters. An example configuration is shown below:

      ```python
      PLUGINS_CONFIG = {
          'app1': {
              'foo': 123,
              'bar': True
          },
          'app2': {
              'foo': 456,
          },
      }
      ```

      Note that an App must be listed in `PLUGINS` for its configuration to take effect.
    type: "object"
  PREFER_IPV4:
    default: false
    description: >-
      When determining the primary IP address for a device, IPv6 is preferred over IPv4 by default.
      Set this to True to prefer IPv4 instead.
    environment_variable: "NAUTOBOT_PREFER_IPV4"
    is_constance_config: true
    type: "boolean"
  RACK_ELEVATION_DEFAULT_UNIT_HEIGHT:
    default: 22
    description: >-
      Default height (in pixels) of a unit within a rendered rack elevation.
      For best results, this should be approximately one tenth of `RACK_ELEVATION_DEFAULT_UNIT_WIDTH.
    environment_variable: "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"
    is_constance_config: true
    type: "integer"
  RACK_ELEVATION_DEFAULT_UNIT_WIDTH:
    default: 230
    description: "Default width (in pixels) of a unit within a rendered rack elevation."
    environment_variable: "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"
    is_constance_config: true
    type: "integer"
  RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT:
    default: false
    description: "Enables two-digit format for the rack unit numbering in a rack elevation diagram."
    environment_variable: "NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"
    is_constance_config: true
    type: "boolean"
    version_added: "2.2.1"
  REDIS_LOCK_TIMEOUT:
    default: 600
    description: >-
      Maximum duration of a Redis lock created when calling `/api/ipam/prefixes/{id}/available-prefixes/` or
      `/api/ipam/prefixes/{id}/available-ips/` to avoid inadvertently allocating the same prefix or IP to
      multiple simultaneous callers.
    details: >-
      Default is set to 600 seconds (10 minutes) to be longer than any theoretical API call time.
      This is to prevent a deadlock scenario where the server did not gracefully exit the `with` block
      when acquiring the Redis lock.
    environment_variable: "NAUTOBOT_REDIS_LOCK_TIMEOUT"
    type: "integer"
  RELEASE_CHECK_TIMEOUT:
    default: 86400
    description: >-
      The number of seconds to retain the latest version that is fetched from the GitHub API before
      automatically invalidating it and fetching it from the API again.
    details: |-
      !!! warning
          This must be set to at least one hour (`3600` seconds). Setting it to a value lower than this is an error.
    environment_variable: "NAUTOBOT_RELEASE_CHECK_TIMEOUT"
    is_constance_config: true
    type: "integer"
  RELEASE_CHECK_URL:
    default: ""
    description: >-
      This parameter defines the URL of the repository that will be checked periodically for new Nautobot releases.
      When a new release is detected, a message will be displayed to administrative users on the home page.
    details: |-
      This can be set to the official repository (`'https://api.github.com/repos/nautobot/nautobot/releases'`)
      or a custom fork. Set this to `None` to disable automatic update checks.

      !!! note
          The URL provided **must** be compatible with the [GitHub REST API](https://docs.github.com/en/rest).
    environment_variable: "NAUTOBOT_RELEASE_CHECK_URL"
    format: "uri"
    is_constance_config: true
    type: "string"
  REMOTE_AUTH_AUTO_CREATE_USER:
    default: false
    description: >-
      If set to `True`, local accounts will be automatically created for users authenticated via a remote service.
    see_also:
      "Remote User Authentication": "./authentication/remote.md"
    type: "boolean"
  REMOTE_AUTH_HEADER:
    default: "HTTP_REMOTE_USER"
    description: >-
      When remote user authentication is in use, this is the name of the HTTP header which informs Nautobot
      of the currently authenticated user. For example, to use the request header `X-Remote-User`, it needs to
      be set to `"HTTP_X_REMOTE_USER"`.
    see_also:
      "Remote User Authentication": "./authentication/remote.md"
    type: "string"
  SANITIZER_PATTERNS:
    default: []
    default_literal: |-
      ```python
      [
          (re.compile(r"(https?://)?\S+\s*@", re.IGNORECASE), r"\1{replacement}@"),
          (
              re.compile(r"(username|password|passwd|pwd|secret|secrets)([\"']?(?:\s+is.?|:)?\s+)\S+[\"']?", re.IGNORECASE),
              r"\1\2{replacement}",
          ),
      ]
      ```
    description: >-
      List of (regular expression, replacement pattern) tuples used by the `nautobot.core.utils.logging.sanitize()`
      function.
    details: |-
      As of Nautobot 1.3.4 this function is used primarily for sanitization of Job log entries,
      but it may be used in other scopes in the future.

      This pattern catches patterns such as:

      | Pattern Match Examples |
      | --- |
      | Password is1234 |
      | Password: is1234 |
      | Password is: is1234 |
      | Password is is1234 |
      | secret is: is1234 |
      | secret is is1234 |
      | secrets is: is1234 |
      | secrets is is1234 |
      | {"username": "is1234"} |
      | {"password": "is1234"} |
      | {"secret": "is1234"} |
      | {"secrets": "is1234"} |

      !!! info
          `is1234` would be replaced in the Job logs with `(redacted)`.
    items:
      items:
        oneOf:
        - "$ref": "#/definitions/regex"
        - "type": "string"
      type: "array"
    type: "array"
    version_added: "1.3.4"
  SECRET_KEY:
    default: ""
    description: >-
      This is a secret, random string used to assist in the creation of new cryptographic hashes for passwords
      and HTTP cookies.
    details: |-
      The key defined here should not be shared outside of the configuration file.
      `SECRET_KEY` can be changed at any time, however be aware that doing so will invalidate all existing sessions.

      `SECRET_KEY` should be at least 50 characters long and contain a random mix of letters, digits, and symbols.

      !!! note
          A unique `SECRET_KEY` is generated for you automatically when you use `nautobot-server init`
          to create a new `nautobot_config.py`.

      You may run `nautobot-server generate_secret_key` to generate a new key at any time.

      ```no-highlight
      nautobot-server generate_secret_key
      ```

      Sample output:

      ```no-highlight
      +$_kw69oq&fbkfk6&q-+ksbgzw1&061ghw%420u3(wen54w(m
      ```

      Alternatively use the following command to generate a secret even before `nautobot-server` is runnable:

      ```no-highlight
      LC_ALL=C tr -cd '[:lower:][:digit:]!@#$%^&*(\-_=+)' < /dev/urandom | fold -w50 | head -n1
      ```

      Example output:

      ```no-highlight
      9.V$@Kxkc@@Kd@z<a/=.J-Y;rYc79<y@](9o9(L(*sS)Q+ud5P
      ```

      !!! warning
          In the case of a highly available installation with multiple web servers, `SECRET_KEY` must be identical
          among all servers in order to maintain a persistent user session state.
    environment_variable: "NAUTOBOT_SECRET_KEY"
    is_required_setting: true
    type: "string"
  SESSION_CACHE_ALIAS:
    default: "default"
    description: "The Alias for the sessions cache defined in CACHES, used in Nautobot Version Control App."
    type: "string"
  SESSION_COOKIE_AGE:
    default: 1209600
    description: "The maximum age of session cookies, in seconds. The default value is 2 weeks."
    environment_variable: "NAUTOBOT_SESSION_COOKIE_AGE"
    see_also:
      "Django documentation for `SESSION_COOKIE_AGE`": "https://docs.djangoproject.com/en/stable/ref/settings/#session-cookie-age"
      SESSION_EXPIRE_AT_BROWSER_CLOSE: "#session_expire_at_browser_close"
    type: "integer"
  SESSION_ENGINE:
    default: "django.contrib.sessions.backends.db"
    description: "Controls where Nautobot stores session data."
    details: >-
      To use cache-based sessions, set this to `'django.contrib.sessions.backends.cache'`.
      To use file-based sessions, set this to `'django.contrib.sessions.backends.file'`.
    see_also:
      "Django documentation on configuring sessions": "https://docs.djangoproject.com/en/stable/topics/http/sessions/#configuring-sessions"
    type: "string"
  SESSION_EXPIRE_AT_BROWSER_CLOSE:
    default: false
    description: >-
      If this is set to True, Nautobot will use browser-length cookies - cookies that expire as soon as
      the user closes their browser. When set to False, session cookies will be stored in users' browsers for as long
      as [`SESSION_COOKIE_AGE`](#session_cookie_age).
    environment_variable: "NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE"
    see_also:
      "Django documentation for `SESSION_EXPIRE_AT_BROWSER_CLOSE`": "https://docs.djangoproject.com/en/stable/ref/settings/#session-expire-at-browser-close"
    type: "boolean"
  SESSION_FILE_PATH:
    "$ref": "#/definitions/relative_path"
    default: null
    description: >-
      HTTP session data is used to track authenticated users when they access Nautobot.
      By default, Nautobot stores session data in its database. However, this inhibits authentication to a
      standby instance of Nautobot without write access to the database. Alternatively, a local file path may be
      specified here and Nautobot will store session data as files instead of using the database.
      Note that the Nautobot system user must have read and write permissions to this path.

      If set to the default value of `None`, Nautobot will use the standard temporary directory for the system.
    details: >-
      If you set this value, you must also enable file-based sessions as explained under
      [`SESSION_ENGINE`](#session_engine).
    environment_variable: "NAUTOBOT_SESSION_FILE_PATH"
  SHORT_DATE_FORMAT:
    default: "Y-m-d"
    description: "Custom short format for dates. The default results in strings like \"2024-01-22\"."
    environment_variable: "NAUTOBOT_SHORT_DATE_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  SHORT_DATETIME_FORMAT:
    default: "Y-m-d H:i"
    description: "Custom short format for date-times. The default results in strings like \"2024-01-22 13:23\"."
    environment_variable: "NAUTOBOT_SHORT_DATETIME_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  SOCIAL_AUTH_BACKEND_PREFIX:
    default: "social_core.backends"
    description: "Configuration of a custom external authentication backend with python-social-auth."
    see_also:
      "Single Sign On": "./authentication/sso.md"
      "`social-auth-app-django`": "https://python-social-auth.readthedocs.io/en/latest/configuration/django.html"
    type: "string"
  STATIC_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/static"
    description: >-
      The location where static files (such as CSS, JavaScript, fonts, or images) used to serve the web interface
      will be staged by the `nautobot-server collectstatic` command.
    see_also:
      "Django documentation for `STATIC_ROOT`": "https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-STATIC_ROOT"
  STORAGE_BACKEND:
    default: null
    description: "The backend storage engine for handling uploaded files (e.g. image attachments)."
    details: |-
      Nautobot supports integration with the [`django-storages`](https://django-storages.readthedocs.io/en/stable/)
      package, which provides backends for several popular file storage services.
      If not configured, local filesystem storage will be used.

      !!! tip
          For an example of using `django-storages` with AWS S3 buckets, visit the
          [django-storages with S3](../guides/s3-django-storage.md) user-guide.

      The configuration parameters for the specified storage backend are defined under the
      [`STORAGE_CONFIG`](#storage_config) setting.
    see_also:
      "`JOB_FILE_IO_STORAGE`": "#job_file_io_storage"
    type: "string"
  STORAGE_CONFIG:
    default: {}
    description: "A dictionary of configuration parameters for the storage backend configured as STORAGE_BACKEND."
    details: |-
      The specific parameters to be used here are specific to each backend.

      If [`STORAGE_BACKEND`](#storage_backend) is not defined, this setting will be ignored.
    see_also:
      "`django-storages` documentation": "https://django-storages.readthedocs.io/en/stable/"
    type: "object"
  STRICT_FILTERING:
    default: true
    description: >-
      If set to `True` (default), UI and REST API filtering of object lists will fail if an unknown/unrecognized
      filter parameter is provided as a URL parameter.
      (For example, `/dcim/devices/?ice_cream_flavor=chocolate` or `/api/dcim/locations/?ice_cream_flavor=chocolate`)
    details: |-
      UI list (table) views will report an error message in this case and display no filtered objects;
      REST API list endpoints will return a 400 Bad Request response with an explanatory error message.

      If set to `False`, unknown/unrecognized filter parameters will be discarded and ignored,
      although Nautobot will log a warning message.

      !!! warning
          Setting this to `False` can result in unexpected filtering results in the case of user error,
          for example `/dcim/devices/?has_primry_ip=false` (note the typo `primry`) will result in a list of
          _all_ devices, rather than the intended list of only devices that lack a primary IP address.
          In the case of Jobs or external automation making use of such a filter, this could have
          wide-ranging consequences.
    environment_variable: "NAUTOBOT_STRICT_FILTERING"
    type: "boolean"
    version_added: "1.4.0"
  SUPPORT_MESSAGE:
    default: ""
    description: "A message to include on error pages (status code 403, 404, 500, etc.) when an error occurs."
    details: |-
      You can configure this to direct users to the appropriate contact(s) within your organization that
      provide support for Nautobot. Markdown formatting is supported within this message, as well as
      [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).

      If unset, the default message that will appear is
      `If further assistance is required, please join the #nautobot channel on
      [Network to Code's Slack community](https://slack.networktocode.com) and post your question.`
    environment_variable: "NAUTOBOT_SUPPORT_MESSAGE"
    is_constance_config: true
    type: "string"
    version_added: "2.0.2"
  TEST_FACTORY_SEED:
    default: null
    description: >-
      This configuration provides a fixed seed string for the pseudo-random generator used to populate test data
      into the database, providing for reproducible randomness across consecutive test runs.
      If unset, a random seed will be used each time.
    environment_variable: "NAUTOBOT_TEST_FACTORY_SEED"
    type: "string"
    version_added: "1.5.0"
    see_also:
      "`TEST_USE_FACTORIES`": "#test_use_factories"
  TEST_PERFORMANCE_BASELINE_FILE:
    default: "nautobot/core/tests/performance_baselines.yml"
    description: "File path of a YAML file providing baseline times for all performance-related tests."
    details: |-
      The YAML file should conform to the following format:

      ```yaml
      tests:
          - name: >-
                test_run_job_with_sensitive_variables_and_requires_approval
                (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 4.799533
          - name: test_run_missing_schedule (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 4.367563
          - name: test_run_now_missing_args (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 4.363194
          - name: >-
                test_create_object_with_constrained_permission
                (nautobot.extras.tests.test_views.GraphQLQueriesTestCase)
            execution_time: 3.474244
          - name: >-
                test_run_now_constrained_permissions
                (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 2.727531
      ```
    environment_variable: "NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE"
    type: "string"
    version_added: "1.5.0"
  TEST_USE_FACTORIES:
    default: false
    description: >-
      If set to `True`, the Nautobot test runner will call `nautobot-server generate_test_data ...` before
      executing any test cases, pre-populating the test database with various pseudo-random instances of
      many of Nautobot's data models.
    details: |-
      !!! warning
          This functionality requires the installation of the [`factory-boy`](https://pypi.org/project/factory-boy/)
          Python package, which is present in Nautobot's own development environment, but is _not_ an inherent
          dependency of the Nautobot package when installed otherwise, such as into an App's development
          environment.

      !!! info
          Setting this to `True` is a requirement for all Nautobot core tests as of 1.5.0, and it is set accordingly
          in `nautobot/core/tests/nautobot_config.py`, but defaults to `False` otherwise so as to remain
          backwards-compatible with Apps that also may use the Nautobot test runner in their own test environments,
          but have not yet updated their tests to account for the presence of this test data.

      Because this test data can obviate the need to manually construct complex test data, and the random factor
      can improve test robustness, App developers are encouraged to set this to `True` in their configuration,
      ensure that their development environments include the `factory-boy` Python package as a test dependency,
      and update their tests as needed.
    environment_variable: "NAUTOBOT_TEST_USE_FACTORIES"
    type: "boolean"
    version_added: "1.5.0"
    see_also:
      "`TEST_FACTORY_SEED`": "#test_factory_seed"
  TIME_FORMAT:
    default: "g:i a"
    description: "Custom format for times. The default results in strings like \"1:23 p.m.\"."
    environment_variable: "NAUTOBOT_TIME_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  TIME_ZONE:
    default: "UTC"
    description: >-
      The time zone Nautobot will use when dealing with dates and times. It is recommended to use UTC time unless you have a specific need to use a local time zone. Please see the [list of available time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
    details: |-
      !!! warning
          Scheduled jobs will run in the time zone configured in this setting. If you change this setting from the
          default UTC, you must change it on the Celery Beat server and all Nautobot web servers or your scheduled
          jobs may run in the wrong time zone.
    environment_variable: "NAUTOBOT_TIME_ZONE"
    see_also:
      "Time Zones documentation": "./time-zones.md"
      "Django documentation for `TIME_ZONE`": "https://docs.djangoproject.com/en/stable/ref/settings/#time-zone"
    type: "string"
  UI_RACK_VIEW_TRUNCATE_FUNCTION:
    "$ref": "#/definitions/callable"
    default: "UI_RACK_VIEW_TRUNCATE_FUNCTION"
    default_literal: |-
      ```py
      def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):
          return str(device_display_name).split(".")[0]
      ```
    description: "This setting function is used to perform the rack elevation truncation feature."
    details: >-
      This provides a way to tailor the truncation behavior to best suit the needs of the installation.

      The function must take only one argument: the device display name, as a string, attempting to be rendered
      on the rack elevation.

      The function must return only one argument: a string of the truncated device display name.
    version_added: "1.4.0"
...



----- FILE: nautobot_core_templates_nautobot_config.py.j2 (OLD) -----
import os
import sys

from nautobot.core.settings import *  # noqa F401,F403
from nautobot.core.settings_funcs import is_truthy, parse_redis_connection

#########################
#                       #
#   Required settings   #
#                       #
#########################

# This is a list of valid fully-qualified domain names (FQDNs) for the Nautobot server. Nautobot will not permit write
# access to the server via any other hostnames. The first FQDN in the list will be treated as the preferred name.
#
# Example: ALLOWED_HOSTS = ['nautobot.example.com', 'nautobot.internal.local']
#
# ALLOWED_HOSTS = os.getenv("NAUTOBOT_ALLOWED_HOSTS", "").split(" ")

# The django-redis cache is used to establish concurrent locks using Redis.
#
# CACHES = {
#     "default": {
#         "BACKEND": os.getenv(
#             "NAUTOBOT_CACHES_BACKEND",
#             "django_prometheus.cache.backends.redis.RedisCache" if METRICS_ENABLED else "django_redis.cache.RedisCache",
#         ),
#         "LOCATION": parse_redis_connection(redis_database=1),
#         "TIMEOUT": 300,
#         "OPTIONS": {
#             "CLIENT_CLASS": "django_redis.client.DefaultClient",
#             "PASSWORD": "",
#         },
#     }
# }

# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.
# CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv("NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT", "0"))

# Celery Beat heartbeat file path - will be touched by Beat each time it wakes up as a proof-of-health.
# CELERY_BEAT_HEARTBEAT_FILE = os.getenv(
#     "NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE",
#     os.path.join(tempfile.gettempdir(), "nautobot_celery_beat_heartbeat"),
# )

# Celery broker URL used to tell workers where queues are located
#
# CELERY_BROKER_URL = os.getenv("NAUTOBOT_CELERY_BROKER_URL", parse_redis_connection(redis_database=0))

# Optional configuration dict for Celery to use custom SSL certificates to connect to Redis.
#
# CELERY_BROKER_USE_SSL = None

# Database configuration. See the Django documentation for a complete list of available parameters:
#   https://docs.djangoproject.com/en/stable/ref/settings/#databases
#
# DATABASES = {
#     "default": {
#         "NAME": os.getenv("NAUTOBOT_DB_NAME", "nautobot"),  # Database name
#         "USER": os.getenv("NAUTOBOT_DB_USER", ""),  # Database username
#         "PASSWORD": os.getenv("NAUTOBOT_DB_PASSWORD", ""),  # Database password
#         "HOST": os.getenv("NAUTOBOT_DB_HOST", "localhost"),  # Database server
#         "PORT": os.getenv("NAUTOBOT_DB_PORT", ""),  # Database port (leave blank for default)
#         "CONN_MAX_AGE": int(os.getenv("NAUTOBOT_DB_TIMEOUT", "300")),  # Database timeout
#         "ENGINE": os.getenv(
#             "NAUTOBOT_DB_ENGINE",
#             "django_prometheus.db.backends.postgresql" if METRICS_ENABLED else "django.db.backends.postgresql",
#         ),  # Database driver ("mysql" or "postgresql")
#     }
# }

# Ensure proper Unicode handling for MySQL
#
if DATABASES["default"]["ENGINE"].endswith("mysql"):
    DATABASES["default"]["OPTIONS"] = {"charset": "utf8mb4"}

# This key is used for secure generation of random numbers and strings. It must never be exposed outside of this file.
# For optimal security, SECRET_KEY should be at least 50 characters in length and contain a mix of letters, numbers, and
# symbols. Nautobot will not run without this defined. For more information, see
# https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-SECRET_KEY
SECRET_KEY = os.getenv("NAUTOBOT_SECRET_KEY", "{{ secret_key }}")

#####################################
#                                   #
#   Optional Django core settings   #
#                                   #
#####################################

# Specify one or more (name, email address) tuples representing Nautobot administrators.
# These people will be notified of application errors (assuming correct email settings are provided).
#
# ADMINS = []

# FQDNs that are considered trusted origins for secure, cross-domain, requests such as HTTPS POST.
# If running Nautobot under a single domain, you may not need to set this variable;
# if running on multiple domains, you *may* need to set this variable to more or less the same as ALLOWED_HOSTS above.
# https://docs.djangoproject.com/en/stable/ref/settings/#csrf-trusted-origins
#
# CSRF_TRUSTED_ORIGINS = []

# Date/time formatting. See the following link for supported formats:
# https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date
#
# DATE_FORMAT = os.getenv("NAUTOBOT_DATE_FORMAT", "N j, Y")
# SHORT_DATE_FORMAT = os.getenv("NAUTOBOT_SHORT_DATE_FORMAT", "Y-m-d")
# TIME_FORMAT = os.getenv("NAUTOBOT_TIME_FORMAT", "g:i a")
# DATETIME_FORMAT = os.getenv("NAUTOBOT_DATETIME_FORMAT", "N j, Y g:i a")
# SHORT_DATETIME_FORMAT = os.getenv("NAUTOBOT_SHORT_DATETIME_FORMAT", "Y-m-d H:i")

# Set to True to enable server debugging. WARNING: Debugging introduces a substantial performance penalty and may reveal
# sensitive information about your installation. Only enable debugging while performing testing. Never enable debugging
# on a production system.
#
# DEBUG = is_truthy(os.getenv("NAUTOBOT_DEBUG", "False"))

# If hosting Nautobot in a subdirectory, you must set this value to match the base URL prefix configured in your
# HTTP server (e.g. `/nautobot/`). When not set, URLs will default to being prefixed by `/`.
#
# FORCE_SCRIPT_NAME = None

# IP addresses recognized as internal to the system.
#
# INTERNAL_IPS = ("127.0.0.1", "::1")

# Enable custom logging. Please see the Django documentation for detailed guidance on configuring custom logs:
#   https://docs.djangoproject.com/en/stable/topics/logging/
#
# LOGGING = {
#     "version": 1,
#     "disable_existing_loggers": False,
#     "formatters": {
#         "normal": {
#             "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s",
#             "datefmt": "%H:%M:%S",
#         },
#         "verbose": {
#             "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s",
#             "datefmt": "%H:%M:%S",
#         },
#     },
#     "handlers": {
#         "normal_console": {
#             "level": "INFO",
#             "class": "logging.StreamHandler",
#             "formatter": "normal",
#         },
#         "verbose_console": {
#             "level": "DEBUG",
#             "class": "logging.StreamHandler",
#             "formatter": "verbose",
#         },
#     },
#     "loggers": {
#         "django": {"handlers": ["normal_console"], "level": "INFO"},
#         "nautobot": {
#             "handlers": ["verbose_console" if DEBUG else "normal_console"],
#             "level": "DEBUG" if DEBUG else "INFO",
#         },
#     },
# }

# The file path where uploaded media such as image attachments are stored. A trailing slash is not needed.
#
# MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, "media").rstrip("/")

# Set to True to use session cookies instead of persistent cookies.
# Session cookies will expire when a browser is closed.
#
# SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv("NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE", "False"))

# The length of time (in seconds) for which a user will remain logged into the web UI before being prompted to
# re-authenticate. (Default: 1209600 [14 days])
#
# SESSION_COOKIE_AGE = int(os.getenv("NAUTOBOT_SESSION_COOKIE_AGE", "1209600"))  # 2 weeks, in seconds

# Where Nautobot stores user session data.
#
# SESSION_ENGINE = "django.contrib.sessions.backends.db"

# By default, Nautobot will store session data in the database. Alternatively, a file path can be specified here to use
# local file storage instead. (This can be useful for enabling authentication on a standby instance with read-only
# database access.) Note that the user as which Nautobot runs must have read and write permissions to this path.
#
# SESSION_FILE_PATH = os.getenv("NAUTOBOT_SESSION_FILE_PATH", None)

# Where static files (CSS, JavaScript, etc.) are stored
#
# STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, "static")

# Time zone (default: UTC)
#
# TIME_ZONE = os.getenv("NAUTOBOT_TIME_ZONE", "UTC")

###################################################################
#                                                                 #
#   Optional settings specific to Nautobot and its related apps   #
#                                                                 #
###################################################################

# Allow users to enable request profiling via django-silk for admins to inspect.
# if "NAUTOBOT_ALLOW_REQUEST_PROFILING" in os.environ and os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"] != "":
#     ALLOW_REQUEST_PROFILING = is_truthy(os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"])

# URL schemes that are allowed within links in Nautobot
#
# ALLOWED_URL_SCHEMES = (
#     "file",
#     "ftp",
#     "ftps",
#     "http",
#     "https",
#     "irc",
#     "mailto",
#     "sftp",
#     "ssh",
#     "tel",
#     "telnet",
#     "tftp",
#     "vnc",
#     "xmpp",
# )

# Banners (HTML is permitted) to display at the top and/or bottom of all Nautobot pages, and on the login page itself.
#
# if "NAUTOBOT_BANNER_BOTTOM" in os.environ and os.environ["NAUTOBOT_BANNER_BOTTOM"] != "":
#     BANNER_BOTTOM = os.environ["NAUTOBOT_BANNER_BOTTOM"]
# if "NAUTOBOT_BANNER_LOGIN" in os.environ and os.environ["NAUTOBOT_BANNER_LOGIN"] != "":
#     BANNER_LOGIN = os.environ["NAUTOBOT_BANNER_LOGIN"]
# if "NAUTOBOT_BANNER_TOP" in os.environ and os.environ["NAUTOBOT_BANNER_TOP"] != "":
#     BANNER_TOP = os.environ["NAUTOBOT_BANNER_TOP"]

# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.
# The filepath should be relative to the `MEDIA_ROOT`.
#
# BRANDING_FILEPATHS = {
#     "logo": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_LOGO", None),  # Navbar logo
#     "favicon": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_FAVICON", None),  # Browser favicon
#     "icon_16": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_16", None),  # 16x16px icon
#     "icon_32": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_32", None),  # 32x32px icon
#     "icon_180": os.getenv(
#         "NAUTOBOT_BRANDING_FILEPATHS_ICON_180", None
#     ),  # 180x180px icon - used for the apple-touch-icon header
#     "icon_192": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_192", None),  # 192x192px icon
#     "icon_mask": os.getenv(
#         "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK", None
#     ),  # mono-chrome icon used for the mask-icon header
#     "header_bullet": os.getenv(
#         "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET", None
#     ),  # bullet image used for various view headers
#     "nav_bullet": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET", None),  # bullet image used for nav menu headers
# }

# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)
#
# BRANDING_PREPENDED_FILENAME = os.getenv("NAUTOBOT_BRANDING_PREPENDED_FILENAME", "nautobot_")

# Title to use in place of "Nautobot"
#
# BRANDING_TITLE = os.getenv("NAUTOBOT_BRANDING_TITLE", "Nautobot")

# Branding URLs (links in the bottom right of the footer)
#
# BRANDING_URLS = {
#     "code": os.getenv("NAUTOBOT_BRANDING_URLS_CODE", "https://github.com/nautobot/nautobot"),
#     "docs": os.getenv("NAUTOBOT_BRANDING_URLS_DOCS", None),
#     "help": os.getenv("NAUTOBOT_BRANDING_URLS_HELP", "https://github.com/nautobot/nautobot/wiki"),
# }

# Options to pass to the Celery broker transport, for example when using Celery with Redis Sentinel.
#
# CELERY_BROKER_TRANSPORT_OPTIONS = {}

# Default celery queue name that will be used by workers and tasks if no queue is specified
# CELERY_TASK_DEFAULT_QUEUE = os.getenv("NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE", "default")

# Global task time limits (seconds)
# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,
# while exceeding the hard limit will result in a SIGKILL.
#
# CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT", str(5 * 60)))
# CELERY_TASK_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_TIME_LIMIT", str(10 * 60)))

# Ports for prometheus metric HTTP server running on the celery worker.
# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.
# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the
# highest amount of workers you are running on a single machine (comma-separated, like "8080,8081,8082"). You can then
# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in
# that case. Set this to an empty string to disable it.
# CELERY_WORKER_PROMETHEUS_PORTS = []
# if os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS"):
#     CELERY_WORKER_PROMETHEUS_PORTS = [
#         int(value) for value in os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS").split(",")
#     ]


# Number of days to retain changelog entries. Set to 0 to retain changes indefinitely. Defaults to 90 if not set here.
#
# if "NAUTOBOT_CHANGELOG_RETENTION" in os.environ and os.environ["NAUTOBOT_CHANGELOG_RETENTION"] != "":
#     CHANGELOG_RETENTION = int(os.environ["NAUTOBOT_CHANGELOG_RETENTION"])

# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.
# Defaults to False. Setting this to True can be dangerous, as it allows any website to make
# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with
# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.
#
# CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv("NAUTOBOT_CORS_ALLOW_ALL_ORIGINS", "False"))

# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].
#
# CORS_ALLOWED_ORIGINS = [
#     'https://hostname.example.com',
# ]

# A list of strings representing regexes that match Origins that are authorized to make cross-site
# HTTP requests. Defaults to [].
#
# CORS_ALLOWED_ORIGIN_REGEXES = [
#     r'^(https?://)?(\w+\.)?example\.com$',
# ]

# UUID uniquely but anonymously identifying this Nautobot deployment.
#
# if "NAUTOBOT_DEPLOYMENT_ID" in os.environ and os.environ["NAUTOBOT_DEPLOYMENT_ID"] != "":
#     DEPLOYMENT_ID = os.environ["NAUTOBOT_DEPLOYMENT_ID"]

# Device names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to True to use the device name alone as the natural key for Device objects.
# Set this to False to use the sequence (name, tenant, location) as the natural key instead.
#
# if "NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"] != "":
#     DEVICE_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"])

# The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.
#
# if (
#     "NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT" in os.environ
#     and os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"] != ""
# ):
#     DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT = int(os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"])

# Exempt certain models from the enforcement of view permissions. Models listed here will be viewable by all users and
# by anonymous users. List models in the form `<app>.<model>`. Add '*' to this list to exempt all models.
# Defaults to [].
#
# EXEMPT_VIEW_PERMISSIONS = [
#     'dcim.location',
#     'ipam.prefix',
# ]

# Global 3rd-party authentication settings
#
# EXTERNAL_AUTH_DEFAULT_GROUPS = []
# EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}

# Directory where cloned Git repositories will be stored.
#
# GIT_ROOT = os.getenv("NAUTOBOT_GIT_ROOT", os.path.join(NAUTOBOT_ROOT, "git").rstrip("/"))

# Prefixes to use for custom fields, relationships, and computed fields in GraphQL representation of data.
#
# GRAPHQL_COMPUTED_FIELD_PREFIX = "cpf"
# GRAPHQL_CUSTOM_FIELD_PREFIX = "cf"
# GRAPHQL_RELATIONSHIP_PREFIX = "rel"

# HTTP proxies Nautobot should use when sending outbound HTTP requests (e.g. for webhooks).
#
# HTTP_PROXIES = {
#     'http': 'http://10.10.1.10:3128',
#     'https': 'http://10.10.1.10:1080',
# }

# Send anonymized installation metrics when `nautobot-server post_upgrade` command is run.
#
INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_INSTALLATION_METRICS_ENABLED", "{{ installation_metrics_enabled | default(True) }}"))

# Storage backend to use for Job input files and Job output files.
#
# Note: the default is for backwards compatibility and it is recommended to change it if possible for your deployment.
#
# JOB_FILE_IO_STORAGE = os.getenv("NAUTOBOT_JOB_FILE_IO_STORAGE", "db_file_storage.storage.DatabaseFileStorage")

# Maximum size in bytes of any single file created by Job.create_file().
#
# JOB_CREATE_FILE_MAX_SIZE = 10 << 20

# Directory where Jobs can be discovered.
#
# JOBS_ROOT = os.getenv("NAUTOBOT_JOBS_ROOT", os.path.join(NAUTOBOT_ROOT, "jobs").rstrip("/"))

# Location names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to True to use the location name alone as the natural key for Location objects.
# Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) as the natural key instead.
#
# if "NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"] != "":
#     LOCATION_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"])

# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True
#
# LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv("NAUTOBOT_LOG_DEPRECATION_WARNINGS", "False"))

# Setting this to True will display a "maintenance mode" banner at the top of every page.
#
# MAINTENANCE_MODE = is_truthy(os.getenv("NAUTOBOT_MAINTENANCE_MODE", "False"))

# Maximum number of objects that the UI and API will retrieve in a single request. Default is 1000
#
# if "NAUTOBOT_MAX_PAGE_SIZE" in os.environ and os.environ["NAUTOBOT_MAX_PAGE_SIZE"] != "":
#     MAX_PAGE_SIZE = int(os.environ["NAUTOBOT_MAX_PAGE_SIZE"])

# Expose Prometheus monitoring metrics at the HTTP endpoint '/metrics'
#
# METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_METRICS_ENABLED", "False"))

# Require API Authentication to HTTP endpoint '/metrics'
#
# METRICS_AUTHENTICATED = is_truthy(os.getenv("NAUTOBOT_METRICS_AUTHENTICATED", "False"))

# Disable app metrics for specific apps
#
# if "NAUTOBOT_METRICS_DISABLED_APPS" in os.environ and os.environ["NAUTOBOT_METRICS_DISABLED_APPS"] != "":
#     METRICS_DISABLED_APPS = os.getenv("NAUTOBOT_METRICS_DISABLED_APPS", "").split(",")

# Credentials that Nautobot will uses to authenticate to devices when connecting via NAPALM.
#
# NAPALM_USERNAME = os.getenv("NAUTOBOT_NAPALM_USERNAME", "")
# NAPALM_PASSWORD = os.getenv("NAUTOBOT_NAPALM_PASSWORD", "")

# NAPALM timeout (in seconds). (Default: 30)
#
# NAPALM_TIMEOUT = int(os.getenv("NAUTOBOT_NAPALM_TIMEOUT", "30"))

# NAPALM optional arguments (see https://napalm.readthedocs.io/en/latest/support/#optional-arguments). Arguments must
# be provided as a dictionary.
#
# NAPALM_ARGS = {}

# Default number of objects to display per page of the UI and REST API. Default is 50
#
# if "NAUTOBOT_PAGINATE_COUNT" in os.environ and os.environ["NAUTOBOT_PAGINATE_COUNT"] != "":
#     PAGINATE_COUNT = int(os.environ["NAUTOBOT_PAGINATE_COUNT"])

# Options given in the web UI for the number of objects to display per page.
# Default is [25, 50, 100, 250, 500, 1000]
#
# if "NAUTOBOT_PER_PAGE_DEFAULTS" in os.environ and os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"] != "":
#     PER_PAGE_DEFAULTS = [int(val) for val in os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"].split(",")]

# Enable installed plugins. Add the name of each plugin to the list.
#
# PLUGINS = []

# Plugins configuration settings. These settings are used by various plugins that the user may have installed.
# Each key in the dictionary is the name of an installed plugin and its value is a dictionary of settings.
#
# PLUGINS_CONFIG = {
#     'my_plugin': {
#         'foo': 'bar',
#         'buzz': 'bazz'
#     }
# }

# Prefer IPv6 addresses or IPv4 addresses in selecting a device's primary IP address? Default False
#
# if "NAUTOBOT_PREFER_IPV4" in os.environ and os.environ["NAUTOBOT_PREFER_IPV4"] != "":
#     PREFER_IPV4 = is_truthy(os.environ["NAUTOBOT_PREFER_IPV4"])

# Default height and width in pixels of a single rack unit in rendered rack elevations. Defaults are 22 and 230
#
# if (
#     "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT" in os.environ
#     and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"] != ""
# ):
#     RACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"])
# if (
#     "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH" in os.environ
#     and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"] != ""
# ):
#     RACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"])

# Enable two-digit format for the rack unit numbering in rack elevations.
#
# if (
#     "NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT" in os.environ
#      and os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"] != ""
# ):
#     RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT = is_truthy(os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"])

# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added
# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`
#
# REDIS_LOCK_TIMEOUT = int(os.getenv("NAUTOBOT_REDIS_LOCK_TIMEOUT", "600"))

# How frequently to check for a new Nautobot release on GitHub, and the URL to check for this information.
# Defaults to disabled (no URL) and check every 24 hours when enabled
#
# if "NAUTOBOT_RELEASE_CHECK_TIMEOUT" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"] != "":
#     RELEASE_CHECK_TIMEOUT = int(os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"])
# if "NAUTOBOT_RELEASE_CHECK_URL" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_URL"] != "":
#     RELEASE_CHECK_URL = os.environ["NAUTOBOT_RELEASE_CHECK_URL"]

# Remote auth backend settings
#
# REMOTE_AUTH_AUTO_CREATE_USER = False
# REMOTE_AUTH_HEADER = "HTTP_REMOTE_USER"

# Job log entry sanitization and similar
#
# SANITIZER_PATTERNS = [
#     # General removal of username-like and password-like tokens
#     (re.compile(r"(https?://)?\S+\s*@", re.IGNORECASE), r"\1{replacement}@"),
#     (
#         re.compile(r"(username|password|passwd|pwd|secret|secrets)([\"']?(?:\s+is.?|:)?\s+)\S+[\"']?", re.IGNORECASE),
#         r"\1\2{replacement}",
#     ),
# ]

# Configure SSO, for more information see docs/configuration/authentication/sso.md
#
# SOCIAL_AUTH_POSTGRES_JSONFIELD = False

# By default uploaded media is stored on the local filesystem. Using Django-storages is also supported. Provide the
# class path of the storage driver in STORAGE_BACKEND and any configuration options in STORAGE_CONFIG.
# These default to None and {} respectively.
#
# STORAGE_BACKEND = 'storages.backends.s3.S3Storage'
# STORAGE_CONFIG = {
#     'AWS_ACCESS_KEY_ID': 'Key ID',
#     'AWS_SECRET_ACCESS_KEY': 'Secret',
#     'AWS_STORAGE_BUCKET_NAME': 'nautobot',
#     'AWS_S3_REGION_NAME': 'eu-west-1',
# }

# Reject invalid UI/API filter parameters, or discard them while logging a warning?
#
# STRICT_FILTERING = is_truthy(os.getenv("NAUTOBOT_STRICT_FILTERING", "True"))

# Custom message to display on 4xx and 5xx error pages. Markdown and HTML are supported.
# Default message directs the user to #nautobot on NTC's Slack community.
#
# if "NAUTOBOT_SUPPORT_MESSAGE" in os.environ and os.environ["NAUTOBOT_SUPPORT_MESSAGE"] != "":
#     SUPPORT_MESSAGE = os.environ["NAUTOBOT_SUPPORT_MESSAGE"]

# UI_RACK_VIEW_TRUNCATE_FUNCTION
#
# def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):
#     """Given device display name, truncate to fit the rack elevation view.
#
#     :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.
#     :type device_display_name: str
#
#     :return: Truncated device name
#     :type: str
#     """
#     return str(device_display_name).split(".")[0]

# A list of strings designating all applications that are enabled in this Django installation.
# Each string should be a dotted Python path to an application configuration class (preferred),
# or a package containing an application.
# https://docs.nautobot.com/projects/core/en/latest/configuration/optional-settings/#extra-applications
# EXTRA_INSTALLED_APPS = []

# Allow users to enable request profiling on their login session
# ALLOW_REQUEST_PROFILING = False



----- FILE: nautobot_core_templates_base_django.html (OLD) -----
{% load static %}
{% load helpers %}
{% load plugins %}

<!DOCTYPE html>
<html lang="en"{% if request.COOKIES|get_item:"theme" == 'dark' %} data-theme="dark"{% endif %}>
<head>
    <title>{% block title %}Home{% endblock %} - {{ settings.BRANDING_TITLE }}</title>
    {% include 'inc/media.html' %}
    {% block extra_styles %}{% endblock %}
</head>
<body>
    {% include 'inc/nav_menu.html' %}
    <div class="container-fluid wrapper" id="main-content">
        <div class="banner-alert-area">
        {% if request.user.is_authenticated %}
            {% if "BANNER_TOP"|settings_or_config %}
                <div class="alert alert-info text-center" role="alert">
                    {{ "BANNER_TOP"|settings_or_config|safe }}
                </div>
            {% endif %}
        {% endif %}
        {% if settings.MAINTENANCE_MODE %}
            <div class="alert alert-warning text-center" role="alert">
                <h4><i class="mdi mdi-alert"></i> Maintenance Mode</h4>
                <p>Nautobot is currently in maintenance mode. Functionality may be limited.</p>
            </div>
        {% endif %}
        {% plugin_banners %}
        {% for message in messages %}
            <div class="alert alert-{{ message.tags }} alert-dismissable" role="alert">
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span>&times;</span>
                </button>
                {{ message }}
            </div>
        {% endfor %}
        </div>
        {% block header %}{% endblock header %}
        {% block content %}{% endblock content %}
        <div class="push"></div>
        {% if request.user.is_authenticated %}
            {% if "BANNER_BOTTOM"|settings_or_config %}
                <div class="alert alert-info text-center banner-bottom" role="alert">
                    {{ "BANNER_BOTTOM"|settings_or_config|safe }}
                </div>
            {% endif %}
        {% endif %}
    </div>
    {% include 'modals/modal_theme.html' with name='theme'%}
    {% include 'inc/footer.html' %}
    {% include 'inc/javascript.html' %}
{% block javascript %}{% endblock %}
</body>
</html>


### NEW VERSION FILES ###

----- FILE: nautobot_core_templates_login.html (NEW) -----
{% extends 'base.html' %}
{% load helpers %}
{% load form_helpers %}

{% block extra_styles %}
<style>
    .style-line {
        overflow: hidden;
        text-align: center;
        margin-bottom: 20px;
    }
    .style-line span {
        text-align: center;
        font-size: 15px;
        color: #acacac;
        display: inline-block;
        position: relative;
        padding: 0 25px;
        z-index: 1;
    }
    .style-line span:before {
        display: inline-block;
        content: "";
        height: 2px;
        width: 100%;
        background-color: #cfcfcf;
        left: 100%;
        top: 50%;
        -webkit-transform: translateY(-50%);
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
        position: absolute;
        z-index: 1;
    }
    .style-line span:after {
        display: inline-block;
        content: "";
        height: 2px;
        width: 100%;
        background-color: #cfcfcf;
        right: 100%;
        top: 50%;
        -webkit-transform: translateY(-50%);
        -ms-transform: translateY(-50%);
        transform: translateY(-50%);
        position: absolute;
        z-index: 1;
    }
</style>
{% endblock %}

{% block content %}
<div class="row" style="margin-top: {% if 'BANNER_LOGIN'|settings_or_config %}100{% else %}150{% endif %}px;">
    <div class="col-sm-4 col-sm-offset-4">
        {% if "BANNER_LOGIN"|settings_or_config %}
            <div class="alert alert-info text-center" role="alert">
                {{ "BANNER_LOGIN"|settings_or_config|render_markdown }}
            </div>
        {% endif %}
        {% if form.non_field_errors %}
            <div class="panel panel-danger">
                <div class="panel-heading"><strong>Errors</strong></div>
                <div class="panel-body">
                    {{ form.non_field_errors }}
                </div>
            </div>
        {% endif %}
        <form action="{% url 'login' %}" method="post" class="form form-horizontal">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <strong>Log In</strong>
                </div>
                <div class="panel-body">
                    {% csrf_token %}
                    {% if 'next' in request.GET %}<input type="hidden" name="next" value="{{ request.GET.next }}" />{% endif %}
                    {% if 'next' in request.POST %}<input type="hidden" name="next" value="{{ request.POST.next }}" />{% endif %}
                    {% render_form form %}
                </div>
                <div class="panel-footer text-right">
                    <button type="submit" class="btn btn-primary">Log In</button>
                </div>
            </div>
        </form>
        {% if SSO_AUTH_ENABLED %}
        <div class="style-line">
            <span>Or</span>
        </div>
        <a href="{% url 'social:begin' backends.backends.0 %}?next={{ request.get_full_path | urlencode }}&{{ SAML_IDP }}" class="btn btn-primary btn-block">Continue with SSO</a>
        {% endif %}
    </div>
</div>
{% endblock %}



----- FILE: nautobot_core_templates_inc_media.html (NEW) -----
{% load static %}
{% load helpers %}
{% load plugins %}

    <link rel="stylesheet" id="template-theme"
          href="{% url 'template_css' %}">
    <link rel="stylesheet"
          href="{% static 'bootstrap-3.4.1-dist/css/bootstrap.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=bootstrap-3.4.1-dist/css/bootstrap.min.css'">
    <link rel="stylesheet"
          href="{% static 'materialdesignicons-6.5.95/css/materialdesignicons.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=materialdesignicons-6.5.95/css/materialdesignicons.min.css'">
    <link rel="stylesheet"
          href="{% static 'jquery-ui-1.13.2/jquery-ui.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=jquery-ui-1.13.2/jquery-ui.min.css'">
    <link rel="stylesheet"
          href="{% static 'select2-4.0.13/select2.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=select2-4.0.13/select2.min.css'">
    <link rel="stylesheet"
          href="{% static 'select2-bootstrap-0.1.0-beta.10/select2-bootstrap.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=select2-bootstrap-0.1.0-beta.10/select2-bootstrap.min.css'">
    <link rel="stylesheet"
          href="{% static 'flatpickr-4.6.9/themes/light.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=flatpickr-4.6.9/themes/light.min.css'">
    <link rel="stylesheet"
          href="{% static 'highlight.js-11.9.0/github.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=highlight.js-11.9.0/github.min.css'"{% if request.COOKIES|get_item:"theme" == 'dark' %} disabled="disabled"{% endif %} >
    <link rel="stylesheet"
          href="{% static 'highlight.js-11.9.0/github-dark.min.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=highlight.js-11.9.0/github-dark.min.css'"{% if request.COOKIES|get_item:"theme" != 'dark' %} disabled="disabled"{% endif %} />
    <link rel="stylesheet" id="dark-theme"
          href="{% versioned_static 'css/dark.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=css/dark.css'"{% if request.COOKIES|get_item:"theme" != 'dark' %} disabled="disabled"{% endif %} />
    <link rel="stylesheet" id="base-theme"
          href="{% versioned_static 'css/base.css' %}"
          onerror="window.location='{% url 'media_failure' %}?filename=css/base.css'">
    {% if settings.BRANDING_FILEPATHS.css %}
    <link rel="stylesheet" id="custom-css" href="{% custom_branding_or_static 'css' None %}">
    {% endif %}
    <link rel="apple-touch-icon" sizes="180x180" href="{% custom_branding_or_static 'icon_180' 'img/nautobot_icon_180x180.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% custom_branding_or_static 'icon_32' 'img/nautobot_icon_32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% custom_branding_or_static 'icon_16' 'img/nautobot_icon_16x16.png' %}">
    <link rel="icon" type="image/png" sizes="192x192" href="{% custom_branding_or_static 'icon_192' 'img/nautobot_icon_192x192.png' %}">
    <link rel="mask-icon" type="image/png" color="#0097ff" href="{% custom_branding_or_static 'icon_mask' 'img/nautobot_icon_monochrome.png' %}">
    <link rel="shortcut icon" href="{% custom_branding_or_static 'favicon' 'img/favicon.ico' %}">
    <meta name="msapplication-TileColor" content="#2d89ef">
    <meta name="theme-color" content="#ffffff">
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">



----- FILE: changes_1858.added (NEW) -----
Added support in `BRANDING_FILEPATHS` configuration to specify a custom `css` and/or `javascript` file to be added to Nautobot page content.
Added Markdown support to the `BANNER_TOP`, `BANNER_BOTTOM`, and `BANNER_LOGIN` configuration settings.



----- FILE: nautobot_core_templates_inc_javascript.html (NEW) -----
{% load helpers %}
{% load plugins %}
{% load static %}

<script src="{% static 'jquery/jquery-3.7.1.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=jquery/jquery-3.7.1.min.js'"></script>
<script src="{% static 'jquery-ui-1.13.2/jquery-ui.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=jquery-ui-1.13.2/jquery-ui.min.js'"></script>
<script src="{% static 'bootstrap-3.4.1-dist/js/bootstrap.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=bootstrap-3.4.1-dist/js/bootstrap.min.js'"></script>
<script src="{% static 'select2-4.0.13/select2.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=select2-4.0.13/select2.min.js'"></script>
<script src="{% static 'clipboard.js-2.0.9/clipboard.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=clipboard.js-2.0.9/clipboard.min.js'"></script>
<script src="{% static 'flatpickr-4.6.9/flatpickr.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=flatpickr-4.6.9/flatpickr.min.js'"></script>
<script src="{% static 'highlight.js-11.9.0/highlight.min.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=highlight.js-11.9.0/highlight.min.js'"></script>
<script src="{% versioned_static 'js/forms.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=js/forms.js'"></script>
<script src="{% versioned_static 'js/theme.js' %}"
        onerror="window.location='{% url 'media_failure' %}?filename=js/theme.js'"></script>
<script type="text/javascript">
    var nautobot_api_path = "{% url 'api-root' %}";
    var nautobot_csrf_token = "{{ csrf_token }}";
    var loading = $(".loading");
    $(document).ajaxStart(function() {
        loading.show();
    }).ajaxStop(function() {
        loading.hide();
    });
    // Applies bootstrap tooltip to all elements with the title attribute.
    // Button groups are "special" and require child tooltips to have
    // `{ container: 'body' }` option not to break their styles:
    // https://getbootstrap.com/docs/3.4/javascript/#markup-1
    $("*:not(.btn-group) > [title]").tooltip();
    $(".btn-group > [title]").tooltip({ container: 'body' });
</script>
<script type="text/javascript">
    hljs.configure({ cssSelector: '.language-graphql, .language-json, .language-xml, .language-yaml' });
    hljs.highlightAll();
</script>
{% if settings.BRANDING_FILEPATHS.javascript %}
<script src="{% custom_branding_or_static 'javascript' None %}"></script>
{% endif %}



----- FILE: nautobot_core_settings.py (NEW) -----
import os
import os.path
import platform
import re
import sys
import tempfile

from django.contrib.messages import constants as messages
import django.forms
from django.utils.safestring import mark_safe

from nautobot import __version__
from nautobot.core.constants import CONFIG_SETTING_SEPARATOR as _CONFIG_SETTING_SEPARATOR
from nautobot.core.settings_funcs import ConstanceConfigItem, is_truthy, parse_redis_connection

#
# Environment setup
#

# This is used for display in the UI. There are also VERSION_MAJOR and VERSION_MINOR derived from this later.
VERSION = __version__

# Hostname of the system. This is displayed in the web UI footers along with the
# version.
HOSTNAME = platform.node()

# Set the base directory two levels up (i.e. the base nautobot/ directory)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Set the swapable User model to the Nautobot custom User model
AUTH_USER_MODEL = "users.User"

# Set the default AutoField for 3rd party apps
# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions
#      we can't do that yet
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


###############################################################
# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #
###############################################################

#
# Nautobot optional settings/defaults
#

# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)
NAUTOBOT_ROOT = os.getenv("NAUTOBOT_ROOT", os.path.expanduser("~/.nautobot"))

# Allow users to enable request profiling via django-silk for admins to inspect.
if "NAUTOBOT_ALLOW_REQUEST_PROFILING" in os.environ and os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"] != "":
    ALLOW_REQUEST_PROFILING = is_truthy(os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"])

# URL schemes that are allowed within links in Nautobot
ALLOWED_URL_SCHEMES = [
    "file",
    "ftp",
    "ftps",
    "http",
    "https",
    "irc",
    "mailto",
    "sftp",
    "ssh",
    "tel",
    "telnet",
    "tftp",
    "vnc",
    "xmpp",
]

# Banners to display to users. Markdown and limited HTML are allowed.
if "NAUTOBOT_BANNER_BOTTOM" in os.environ and os.environ["NAUTOBOT_BANNER_BOTTOM"] != "":
    BANNER_BOTTOM = os.environ["NAUTOBOT_BANNER_BOTTOM"]
if "NAUTOBOT_BANNER_LOGIN" in os.environ and os.environ["NAUTOBOT_BANNER_LOGIN"] != "":
    BANNER_LOGIN = os.environ["NAUTOBOT_BANNER_LOGIN"]
if "NAUTOBOT_BANNER_TOP" in os.environ and os.environ["NAUTOBOT_BANNER_TOP"] != "":
    BANNER_TOP = os.environ["NAUTOBOT_BANNER_TOP"]

# Number of days to retain changelog entries. Set to 0 to retain changes indefinitely. Defaults to 90 if not set here.
if "NAUTOBOT_CHANGELOG_RETENTION" in os.environ and os.environ["NAUTOBOT_CHANGELOG_RETENTION"] != "":
    CHANGELOG_RETENTION = int(os.environ["NAUTOBOT_CHANGELOG_RETENTION"])

# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts
# when a large number of dynamic groups are present
CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv("NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED", "False"))

# UUID uniquely but anonymously identifying this Nautobot deployment.
if "NAUTOBOT_DEPLOYMENT_ID" in os.environ and os.environ["NAUTOBOT_DEPLOYMENT_ID"] != "":
    DEPLOYMENT_ID = os.environ["NAUTOBOT_DEPLOYMENT_ID"]

# Device names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to True to use the device name alone as the natural key for Device objects.
# Set this to False to use the sequence (name, tenant, location) as the natural key instead.
#
if "NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"] != "":
    DEVICE_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"])

# The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.
if (
    "NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT" in os.environ
    and os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"] != ""
):
    DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT = int(os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"])

# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted
# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.
EXEMPT_EXCLUDE_MODELS = (
    ("auth", "group"),
    ("users", "user"),
    ("users", "objectpermission"),
)

# Models to exempt from the enforcement of view permissions
EXEMPT_VIEW_PERMISSIONS = []

# The file path to a directory where cloned Git repositories will be located
GIT_ROOT = os.getenv("NAUTOBOT_GIT_ROOT", os.path.join(NAUTOBOT_ROOT, "git").rstrip("/"))

# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)
HTTP_PROXIES = None

# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run
INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_INSTALLATION_METRICS_ENABLED", "True"))

# Maximum file size (in bytes) that as running Job can create in a call to `Job.create_file()`. Default is 10 << 20
if "NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE" in os.environ and os.environ["NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE"] != "":
    JOB_CREATE_FILE_MAX_SIZE = int(os.environ["NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE"])

# The storage backend to use for Job input files and Job output files
JOB_FILE_IO_STORAGE = os.getenv("NAUTOBOT_JOB_FILE_IO_STORAGE", "db_file_storage.storage.DatabaseFileStorage")

# The file path to a directory where locally installed Jobs can be discovered
JOBS_ROOT = os.getenv("NAUTOBOT_JOBS_ROOT", os.path.join(NAUTOBOT_ROOT, "jobs").rstrip("/"))

# `Location` names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to `True` to use the location `name` alone as the natural key for `Location` objects.
# Set this to `False` to use the sequence `(name, parent__name, parent__parent__name, ...)` as the natural key instead.
if "NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"] != "":
    LOCATION_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"])


# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True
LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv("NAUTOBOT_LOG_DEPRECATION_WARNINGS", "False"))

# Setting this to True will display a "maintenance mode" banner at the top of every page.
MAINTENANCE_MODE = is_truthy(os.getenv("NAUTOBOT_MAINTENANCE_MODE", "False"))

# Maximum number of objects that the UI and API will retrieve in a single request. Default is 1000
if "NAUTOBOT_MAX_PAGE_SIZE" in os.environ and os.environ["NAUTOBOT_MAX_PAGE_SIZE"] != "":
    MAX_PAGE_SIZE = int(os.environ["NAUTOBOT_MAX_PAGE_SIZE"])

# Metrics
METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_METRICS_ENABLED", "False"))
METRICS_AUTHENTICATED = is_truthy(os.getenv("NAUTOBOT_METRICS_AUTHENTICATED", "False"))
METRICS_DISABLED_APPS = []
if "NAUTOBOT_METRICS_DISABLED_APPS" in os.environ and os.environ["NAUTOBOT_METRICS_DISABLED_APPS"] != "":
    METRICS_DISABLED_APPS = os.getenv("NAUTOBOT_METRICS_DISABLED_APPS", "").split(_CONFIG_SETTING_SEPARATOR)

# Napalm
NAPALM_ARGS = {}
NAPALM_PASSWORD = os.getenv("NAUTOBOT_NAPALM_PASSWORD", "")
NAPALM_TIMEOUT = int(os.getenv("NAUTOBOT_NAPALM_TIMEOUT", "30"))
NAPALM_USERNAME = os.getenv("NAUTOBOT_NAPALM_USERNAME", "")

# Default number of objects to display per page of the UI and REST API. Default is 50
if "NAUTOBOT_PAGINATE_COUNT" in os.environ and os.environ["NAUTOBOT_PAGINATE_COUNT"] != "":
    PAGINATE_COUNT = int(os.environ["NAUTOBOT_PAGINATE_COUNT"])

# The options displayed in the web interface dropdown to limit the number of objects per page.
# Default is [25, 50, 100, 250, 500, 1000]
if "NAUTOBOT_PER_PAGE_DEFAULTS" in os.environ and os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"] != "":
    PER_PAGE_DEFAULTS = [int(val) for val in os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"].split(_CONFIG_SETTING_SEPARATOR)]

# Plugins
PLUGINS = []
PLUGINS_CONFIG = {}

# Prefer IPv6 addresses or IPv4 addresses in selecting a device's primary IP address? Default False
if "NAUTOBOT_PREFER_IPV4" in os.environ and os.environ["NAUTOBOT_PREFER_IPV4"] != "":
    PREFER_IPV4 = is_truthy(os.environ["NAUTOBOT_PREFER_IPV4"])

# Default height and width in pixels of a single rack unit in rendered rack elevations. Defaults are 22 and 220
if (
    "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT" in os.environ
    and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"] != ""
):
    RACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"])
if (
    "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH" in os.environ
    and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"] != ""
):
    RACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"])

# Enable two-digit format for the rack unit numbering in rack elevations.
if (
    "NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT" in os.environ
    and os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"] != ""
):
    RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT = is_truthy(os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"])

# How frequently to check for a new Nautobot release on GitHub, and the URL to check for this information.
# Defaults to disabled (no URL) and check every 24 hours when enabled
if "NAUTOBOT_RELEASE_CHECK_TIMEOUT" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"] != "":
    RELEASE_CHECK_TIMEOUT = int(os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"])
if "NAUTOBOT_RELEASE_CHECK_URL" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_URL"] != "":
    RELEASE_CHECK_URL = os.environ["NAUTOBOT_RELEASE_CHECK_URL"]

# Global 3rd-party authentication settings
EXTERNAL_AUTH_DEFAULT_GROUPS = []
EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}

# Remote auth backend settings
REMOTE_AUTH_AUTO_CREATE_USER = False
REMOTE_AUTH_HEADER = "HTTP_REMOTE_USER"

# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html
SOCIAL_AUTH_POSTGRES_JSONFIELD = False
# Nautobot related - May be overridden if using custom social auth backend
SOCIAL_AUTH_BACKEND_PREFIX = "social_core.backends"

# Job log entry sanitization and similar
SANITIZER_PATTERNS = [
    # General removal of username-like and password-like tokens
    (re.compile(r"(https?://)?\S+\s*@", re.IGNORECASE), r"\1{replacement}@"),
    (
        re.compile(r"(username|password|passwd|pwd|secret|secrets)([\"']?(?:\s+is.?|:)?\s+)\S+[\"']?", re.IGNORECASE),
        r"\1\2{replacement}",
    ),
]

# Storage
STORAGE_BACKEND = None
STORAGE_CONFIG = {}

# Custom message to display on 4xx and 5xx error pages. Markdown and HTML are supported.
# Default message directs the user to #nautobot on NTC's Slack community.
if "NAUTOBOT_SUPPORT_MESSAGE" in os.environ and os.environ["NAUTOBOT_SUPPORT_MESSAGE"] != "":
    SUPPORT_MESSAGE = os.environ["NAUTOBOT_SUPPORT_MESSAGE"]

# Test runner that is aware of our use of "integration" tags and only runs
# integration tests if explicitly passed in with `nautobot-server test --tag integration`.
TEST_RUNNER = "nautobot.core.tests.runner.NautobotTestRunner"
# Disable test data factories by default so as not to cause issues for plugins.
# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.
TEST_USE_FACTORIES = is_truthy(os.getenv("NAUTOBOT_TEST_USE_FACTORIES", "False"))
# Pseudo-random number generator seed, for reproducibility of test results.
TEST_FACTORY_SEED = os.getenv("NAUTOBOT_TEST_FACTORY_SEED", None)

#
# django-slowtests
#

# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.
# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command
# will automatically opt to NautobotPerformanceTestRunner to run the tests.

# The baseline file that the performance test is running against
# TODO we need to replace the baselines in this file with more consistent results at least for CI
TEST_PERFORMANCE_BASELINE_FILE = os.getenv(
    "NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE", "nautobot/core/tests/performance_baselines.yml"
)

#
# Django Prometheus
#

PROMETHEUS_EXPORT_MIGRATIONS = False


#
# Django filters
#

FILTERS_NULL_CHOICE_LABEL = "None"
FILTERS_NULL_CHOICE_VALUE = "null"

STRICT_FILTERING = is_truthy(os.getenv("NAUTOBOT_STRICT_FILTERING", "True"))

#
# Django REST framework (API)
#

REST_FRAMEWORK_VERSION = VERSION.rsplit(".", 1)[0]  # Use major.minor as API version
VERSION_MAJOR, VERSION_MINOR = [int(v) for v in REST_FRAMEWORK_VERSION.split(".")]
# We support all major.minor API versions from 2.0 to the present latest version.
# Similar logic exists in tasks.py, please keep them in sync!
if VERSION_MAJOR != 2:
    raise RuntimeError(f"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {VERSION_MAJOR}")
REST_FRAMEWORK_ALLOWED_VERSIONS = [f"{VERSION_MAJOR}.{minor}" for minor in range(0, VERSION_MINOR + 1)]

REST_FRAMEWORK = {
    "ALLOWED_VERSIONS": REST_FRAMEWORK_ALLOWED_VERSIONS,
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework.authentication.SessionAuthentication",
        "nautobot.core.api.authentication.TokenAuthentication",
    ),
    "DEFAULT_FILTER_BACKENDS": (
        "nautobot.core.api.filter_backends.NautobotFilterBackend",
        "nautobot.core.api.filter_backends.NautobotOrderingFilter",
    ),
    "DEFAULT_METADATA_CLASS": "nautobot.core.api.metadata.NautobotMetadata",
    "DEFAULT_PAGINATION_CLASS": "nautobot.core.api.pagination.OptionalLimitOffsetPagination",
    "DEFAULT_PERMISSION_CLASSES": ("nautobot.core.api.authentication.TokenPermissions",),
    "DEFAULT_RENDERER_CLASSES": (
        "nautobot.core.api.renderers.NautobotJSONRenderer",
        "nautobot.core.api.renderers.FormlessBrowsableAPIRenderer",
        "nautobot.core.api.renderers.NautobotCSVRenderer",
    ),
    "DEFAULT_PARSER_CLASSES": (
        "rest_framework.parsers.JSONParser",
        "nautobot.core.api.parsers.NautobotCSVParser",
    ),
    "DEFAULT_SCHEMA_CLASS": "nautobot.core.api.schema.NautobotAutoSchema",
    # Version to use if the client doesn't request otherwise. Default to current (i.e. latest)
    "DEFAULT_VERSION": REST_FRAMEWORK_VERSION,
    "DEFAULT_VERSIONING_CLASS": "nautobot.core.api.versioning.NautobotAPIVersioning",
    "ORDERING_PARAM": "sort",  # This is not meant to be changed by users, but is used internally by the API
    "PAGE_SIZE": None,
    "SCHEMA_COERCE_METHOD_NAMES": {
        # Default mappings
        "retrieve": "read",
        "destroy": "delete",
        # Custom operations
        "bulk_destroy": "bulk_delete",
    },
    "VIEW_NAME_FUNCTION": "nautobot.core.api.utils.get_view_name",
}


#
# drf_spectacular (OpenAPI/Swagger)
#

SPECTACULAR_SETTINGS = {
    "TITLE": "API Documentation",
    "DESCRIPTION": "Source of truth and network automation platform",
    "LICENSE": {"name": "Apache v2 License"},
    "VERSION": VERSION,
    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where "/api" was a common "basePath"
    # in the schema.
    # OpenAPI 3.0 removes "basePath" in favor of "servers", so we now declare "/api" as the server relative URL and
    # trim it from all of the individual paths correspondingly.
    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.
    "SERVERS": [{"url": "/api"}],
    "SERVE_PERMISSIONS": ["rest_framework.permissions.IsAuthenticated"],
    "SCHEMA_PATH_PREFIX": "/api",
    "SCHEMA_PATH_PREFIX_TRIM": True,
    # use sidecar - locally packaged UI files, not CDN
    "SWAGGER_UI_DIST": "SIDECAR",
    "SWAGGER_UI_FAVICON_HREF": "SIDECAR",
    "SWAGGER_UI_SETTINGS": {
        "deepLinking": True,
        "displayOperationId": True,
    },
    "REDOC_DIST": "SIDECAR",
    # Do not list all possible enum values in the description of filter fields and the like
    # In addition to being highly verbose, it's inaccurate for filter fields like *__ic and *__re
    "ENUM_GENERATE_CHOICE_DESCRIPTION": False,
    "ENUM_NAME_OVERRIDES": {
        # These choice enums need to be overridden because they get assigned to the `type` field and
        # result in this error:
        #    enum naming encountered a non-optimally resolvable collision for fields named "type".
        "CableTypeChoices": "nautobot.dcim.choices.CableTypeChoices",
        "ConsolePortTypeChoices": "nautobot.dcim.choices.ConsolePortTypeChoices",
        "CustomFieldTypeChoices": "nautobot.extras.choices.CustomFieldTypeChoices",
        "InterfaceTypeChoices": "nautobot.dcim.choices.InterfaceTypeChoices",
        "IPAddressTypeChoices": "nautobot.ipam.choices.IPAddressTypeChoices",
        "PortTypeChoices": "nautobot.dcim.choices.PortTypeChoices",
        "PowerFeedTypeChoices": "nautobot.dcim.choices.PowerFeedTypeChoices",
        "PowerOutletTypeChoices": "nautobot.dcim.choices.PowerOutletTypeChoices",
        "PowerPortTypeChoices": "nautobot.dcim.choices.PowerPortTypeChoices",
        "PrefixTypeChoices": "nautobot.ipam.choices.PrefixTypeChoices",
        "RackTypeChoices": "nautobot.dcim.choices.RackTypeChoices",
        "RelationshipTypeChoices": "nautobot.extras.choices.RelationshipTypeChoices",
        # These choice enums need to be overridden because they get assigned to different names with the same choice set and
        # result in this error:
        #   encountered multiple names for the same choice set
        "JobExecutionTypeIntervalChoices": "nautobot.extras.choices.JobExecutionType",
        # These choice enums need to be overridden because they get assigned to the `protocol` field and
        # result in this error:
        #    enum naming encountered a non-optimally resolvable collision for fields named "protocol".
        "InterfaceRedundancyGroupProtocolChoices": "nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices",
        "ServiceProtocolChoices": "nautobot.ipam.choices.ServiceProtocolChoices",
    },
    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)
    "COMPONENT_SPLIT_PATCH": True,
    # Create separate schema components for request vs response where appropriate
    "COMPONENT_SPLIT_REQUEST": True,
}


##############################################
# DJANGO - Core settings required for Django #
##############################################

#
# Databases
#

DATABASES = {
    "default": {
        "NAME": os.getenv("NAUTOBOT_DB_NAME", "nautobot"),
        "USER": os.getenv("NAUTOBOT_DB_USER", ""),
        "PASSWORD": os.getenv("NAUTOBOT_DB_PASSWORD", ""),
        "HOST": os.getenv("NAUTOBOT_DB_HOST", "localhost"),
        "PORT": os.getenv("NAUTOBOT_DB_PORT", ""),
        "CONN_MAX_AGE": int(os.getenv("NAUTOBOT_DB_TIMEOUT", "300")),
        "ENGINE": os.getenv(
            "NAUTOBOT_DB_ENGINE",
            "django_prometheus.db.backends.postgresql" if METRICS_ENABLED else "django.db.backends.postgresql",
        ),
    }
}

# Ensure proper Unicode handling for MySQL
if DATABASES["default"]["ENGINE"] == "django.db.backends.mysql":
    DATABASES["default"]["OPTIONS"] = {"charset": "utf8mb4"}

# The secret key is used to encrypt session keys and salt passwords.
SECRET_KEY = os.getenv("NAUTOBOT_SECRET_KEY", "")

# Default overrides
if "NAUTOBOT_ALLOWED_HOSTS" in os.environ and os.environ["NAUTOBOT_ALLOWED_HOSTS"] != "":
    ALLOWED_HOSTS = os.environ["NAUTOBOT_ALLOWED_HOSTS"].split(" ")
else:
    ALLOWED_HOSTS = []
CSRF_TRUSTED_ORIGINS = []
CSRF_FAILURE_VIEW = "nautobot.core.views.csrf_failure"
DATE_FORMAT = os.getenv("NAUTOBOT_DATE_FORMAT", "N j, Y")
DATETIME_FORMAT = os.getenv("NAUTOBOT_DATETIME_FORMAT", "N j, Y g:i a")
DEBUG = is_truthy(os.getenv("NAUTOBOT_DEBUG", "False"))
INTERNAL_IPS = ["127.0.0.1", "::1"]
FORCE_SCRIPT_NAME = None

TESTING = "test" in sys.argv

LOG_LEVEL = "DEBUG" if DEBUG else "INFO"

if TESTING:
    # Log to null handler instead of stderr during testing
    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "handlers": {"console": {"level": "INFO", "class": "logging.NullHandler"}},
        "loggers": {"nautobot": {"handlers": ["console"], "level": "INFO"}},
    }
else:
    LOGGING = {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "normal": {
                "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s",
                "datefmt": "%H:%M:%S",
            },
            "verbose": {
                "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s",
                "datefmt": "%H:%M:%S",
            },
        },
        "handlers": {
            "normal_console": {
                "level": "INFO",
                "class": "logging.StreamHandler",
                "formatter": "normal",
            },
            "verbose_console": {
                "level": "DEBUG",
                "class": "logging.StreamHandler",
                "formatter": "verbose",
            },
        },
        "loggers": {
            "django": {"handlers": ["normal_console"], "level": "INFO"},
            "nautobot": {
                "handlers": ["verbose_console" if DEBUG else "normal_console"],
                "level": LOG_LEVEL,
            },
        },
    }

MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, "media").rstrip("/")
SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv("NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE", "False"))
SESSION_COOKIE_AGE = int(os.getenv("NAUTOBOT_SESSION_COOKIE_AGE", "1209600"))  # 2 weeks, in seconds
SESSION_FILE_PATH = os.getenv("NAUTOBOT_SESSION_FILE_PATH", None)
SHORT_DATE_FORMAT = os.getenv("NAUTOBOT_SHORT_DATE_FORMAT", "Y-m-d")
SHORT_DATETIME_FORMAT = os.getenv("NAUTOBOT_SHORT_DATETIME_FORMAT", "Y-m-d H:i")
TIME_FORMAT = os.getenv("NAUTOBOT_TIME_FORMAT", "g:i a")
TIME_ZONE = os.getenv("NAUTOBOT_TIME_ZONE", "UTC")

# Disable importing the WSGI module before starting the server application. This is required for
# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.
WEBSERVER_WARMUP = False

# Installed apps and Django plugins. Nautobot plugins will be appended here later.
INSTALLED_APPS = [
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.humanize",
    "corsheaders",
    "django_filters",
    "django_jinja",
    "django_tables2",
    "django_prometheus",
    "social_django",
    "taggit",
    "timezone_field",
    "nautobot.core.apps.NautobotConstanceConfig",  # overridden form of "constance" AppConfig
    "nautobot.core",
    "django.contrib.admin",  # Must be after `nautobot.core` for template overrides
    "django_celery_beat",  # Must be after `nautobot.core` for template overrides
    "django_celery_results",
    "rest_framework",  # Must be after `nautobot.core` for template overrides
    "db_file_storage",
    "nautobot.circuits",
    "nautobot.dcim",
    "nautobot.ipam",
    "nautobot.extras",
    "nautobot.tenancy",
    "nautobot.users",
    "nautobot.virtualization",
    "drf_spectacular",
    "drf_spectacular_sidecar",
    "graphene_django",
    "health_check",
    "health_check.storage",
    # We have custom implementations of these in nautobot.extras.health_checks:
    # "health_check.db",
    # "health_check.contrib.migrations",
    # "health_check.contrib.redis",
    "django_extensions",
    "constance.backends.database",
    "django_ajax_tables",
    "silk",
]

# Middleware
MIDDLEWARE = [
    "django_prometheus.middleware.PrometheusBeforeMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "silk.middleware.SilkyMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "nautobot.core.middleware.ExceptionHandlingMiddleware",
    "nautobot.core.middleware.RemoteUserMiddleware",
    "nautobot.core.middleware.ExternalAuthMiddleware",
    "nautobot.core.middleware.ObjectChangeMiddleware",
    "django_prometheus.middleware.PrometheusAfterMiddleware",
]

ROOT_URLCONF = "nautobot.core.urls"

TEMPLATES = [
    {
        "NAME": "django",
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.template.context_processors.media",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "social_django.context_processors.backends",
                "social_django.context_processors.login_redirect",
                "nautobot.core.context_processors.settings",
                "nautobot.core.context_processors.sso_auth",
            ],
        },
    },
    {
        "NAME": "jinja",
        "BACKEND": "django_jinja.backend.Jinja2",
        "DIRS": [],
        "APP_DIRS": False,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.template.context_processors.media",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "social_django.context_processors.backends",
                "social_django.context_processors.login_redirect",
                "nautobot.core.context_processors.settings",
                "nautobot.core.context_processors.sso_auth",
            ],
            "environment": "jinja2.sandbox.SandboxedEnvironment",
        },
    },
]

# Set up authentication backends
AUTHENTICATION_BACKENDS = [
    # Always check object permissions
    "nautobot.core.authentication.ObjectPermissionBackend",
]

# Internationalization
LANGUAGE_CODE = "en-us"
USE_I18N = True
USE_TZ = True

# WSGI
WSGI_APPLICATION = "nautobot.core.wsgi.application"
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
USE_X_FORWARDED_HOST = True
X_FRAME_OPTIONS = "DENY"

# Static files (CSS, JavaScript, Images)
STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, "static")
STATIC_URL = "static/"
STATICFILES_DIRS = (os.path.join(BASE_DIR, "project-static"),)

# Media
MEDIA_URL = "media/"

# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)
DATA_UPLOAD_MAX_NUMBER_FIELDS = None

# Messages
MESSAGE_TAGS = {
    messages.ERROR: "danger",
}

# Authentication URLs
# This is the URL route name for the login view.
LOGIN_URL = "login"

# This is the URL route name for the home page (index) view.
LOGIN_REDIRECT_URL = "home"

#
# django-constance
#

CONSTANCE_BACKEND = "constance.backends.database.DatabaseBackend"
CONSTANCE_DATABASE_PREFIX = "constance:nautobot:"
CONSTANCE_DATABASE_CACHE_BACKEND = "default"
CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment

CONSTANCE_ADDITIONAL_FIELDS = {
    "per_page_defaults_field": [
        "nautobot.core.forms.fields.JSONArrayFormField",
        {
            "widget": "django.forms.TextInput",
            "base_field": django.forms.IntegerField(min_value=1),
        },
    ],
    "release_check_timeout_field": [
        "django.forms.IntegerField",
        {
            "min_value": 3600,
        },
    ],
    "release_check_url_field": [
        "django.forms.URLField",
        {
            "required": False,
        },
    ],
    "optional_json_field": [
        "django.forms.fields.JSONField",
        {
            "required": False,
        },
    ],
}

CONSTANCE_CONFIG = {
    "ALLOW_REQUEST_PROFILING": ConstanceConfigItem(
        default=False,
        help_text="Allow users to enable request profiling on their login session.",
        field_type=bool,
    ),
    "BANNER_BOTTOM": ConstanceConfigItem(
        default="",
        help_text="Custom Markdown or limited HTML to display in a banner at the bottom of all pages.",
    ),
    "BANNER_LOGIN": ConstanceConfigItem(
        default="",
        help_text="Custom Markdown or limited HTML to display in a banner at the top of the login page.",
    ),
    "BANNER_TOP": ConstanceConfigItem(
        default="",
        help_text="Custom Markdown or limited HTML to display in a banner at the top of all pages.",
    ),
    "CHANGELOG_RETENTION": ConstanceConfigItem(
        default=90,
        help_text="Number of days to retain object changelog history.\nSet this to 0 to retain changes indefinitely.",
        field_type=int,
    ),
    "DEVICE_NAME_AS_NATURAL_KEY": ConstanceConfigItem(
        default=False,
        help_text="Device names are not guaranteed globally-unique by Nautobot but in practice they often are. "
        "Set this to True to use the device name alone as the natural key for Device objects. "
        "Set this to False to use the sequence (name, tenant, location) as the natural key instead.",
        field_type=bool,
    ),
    "DEPLOYMENT_ID": ConstanceConfigItem(
        default="",
        help_text="Randomly generated UUID used to identify this installation.\n"
        "Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.",
        field_type=str,
    ),
    "DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT": ConstanceConfigItem(
        default=0,
        help_text="Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list "
        "will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very "
        "expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the "
        "member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.",
        field_type=int,
    ),
    "JOB_CREATE_FILE_MAX_SIZE": ConstanceConfigItem(
        default=10 << 20,
        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe
            "Maximum size (in bytes) of any single file generated by a <code>Job.create_file()</code> call."
        ),
        field_type=int,
    ),
    "LOCATION_NAME_AS_NATURAL_KEY": ConstanceConfigItem(
        default=False,
        help_text="Location names are not guaranteed globally-unique by Nautobot but in practice they often are. "
        "Set this to True to use the location name alone as the natural key for Location objects. "
        "Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) "
        "as the natural key instead.",
        field_type=bool,
    ),
    "MAX_PAGE_SIZE": ConstanceConfigItem(
        default=1000,
        help_text="Maximum number of objects that a user can list in one UI page or one API call.\n"
        "If set to 0, a user can retrieve an unlimited number of objects.",
        field_type=int,
    ),
    "PAGINATE_COUNT": ConstanceConfigItem(
        default=50,
        help_text="Default number of objects to display per page when listing objects in the UI and/or REST API.",
        field_type=int,
    ),
    "PER_PAGE_DEFAULTS": ConstanceConfigItem(
        default=[25, 50, 100, 250, 500, 1000],
        help_text="Pagination options to present to the user to choose amongst.\n"
        "For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.",
        # Use custom field type defined above
        field_type="per_page_defaults_field",
    ),
    "NETWORK_DRIVERS": ConstanceConfigItem(
        default={},
        help_text=mark_safe(  # noqa: S308  # suspicious-mark-safe-usage, but this is a static string so it's safe
            "Extend or override default Platform.network_driver translations provided by "
            '<a href="https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/">netutils</a>. '
            "Enter a dictionary in JSON format, for example:\n"
            '<pre><code class="language-json">{\n'
            '    "netmiko": {"my_network_driver": "cisco_ios"},\n'
            '    "pyats": {"my_network_driver": "iosxe"} \n'
            "}</code></pre>",
        ),
        # Use custom field type defined above
        field_type="optional_json_field",
    ),
    "PREFER_IPV4": ConstanceConfigItem(
        default=False,
        help_text="Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.",
        field_type=bool,
    ),
    "RACK_ELEVATION_DEFAULT_UNIT_HEIGHT": ConstanceConfigItem(
        default=22, help_text="Default height (in pixels) of a rack unit in a rack elevation diagram", field_type=int
    ),
    "RACK_ELEVATION_DEFAULT_UNIT_WIDTH": ConstanceConfigItem(
        default=230, help_text="Default width (in pixels) of a rack unit in a rack elevation diagram", field_type=int
    ),
    "RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT": ConstanceConfigItem(
        default=False,
        help_text="Enables two-digit format for the rack unit numbering in a rack elevation diagram",
        field_type=bool,
    ),
    "RELEASE_CHECK_TIMEOUT": ConstanceConfigItem(
        default=24 * 3600,
        help_text="Number of seconds (must be at least 3600, or one hour) to cache the result of a release check "
        "before checking again for a new release.",
        # Use custom field type defined above
        field_type="release_check_timeout_field",
    ),
    "RELEASE_CHECK_URL": ConstanceConfigItem(
        default="",
        help_text="URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\n"
        'This can be set to the official repository "https://api.github.com/repos/nautobot/nautobot/releases" or '
        "a custom fork.\nSet this to an empty string to disable automatic update checks.",
        # Use custom field type defined above
        field_type="release_check_url_field",
    ),
    "SUPPORT_MESSAGE": ConstanceConfigItem(
        default="",
        help_text="Help message to include on 4xx and 5xx error pages. "
        "Markdown is supported, as are some HTML tags and attributes.\n"
        "If unspecified, instructions to join Network to Code's Slack community will be provided.",
    ),
}

CONSTANCE_CONFIG_FIELDSETS = {
    "Banners": ["BANNER_LOGIN", "BANNER_TOP", "BANNER_BOTTOM"],
    "Change Logging": ["CHANGELOG_RETENTION"],
    "Device Connectivity": ["NETWORK_DRIVERS", "PREFER_IPV4"],
    "Installation Metrics": ["DEPLOYMENT_ID"],
    "Natural Keys": ["DEVICE_NAME_AS_NATURAL_KEY", "LOCATION_NAME_AS_NATURAL_KEY"],
    "Pagination": ["PAGINATE_COUNT", "MAX_PAGE_SIZE", "PER_PAGE_DEFAULTS"],
    "Performance": ["DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT", "JOB_CREATE_FILE_MAX_SIZE"],
    "Rack Elevation Rendering": [
        "RACK_ELEVATION_DEFAULT_UNIT_HEIGHT",
        "RACK_ELEVATION_DEFAULT_UNIT_WIDTH",
        "RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT",
    ],
    "Release Checking": ["RELEASE_CHECK_URL", "RELEASE_CHECK_TIMEOUT"],
    "User Interface": ["SUPPORT_MESSAGE"],
    "Debugging": ["ALLOW_REQUEST_PROFILING"],
}

#
# From django-cors-headers
#

# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.
# Defaults to False. Setting this to True can be dangerous, as it allows any website to make
# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with
# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.
CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv("NAUTOBOT_CORS_ALLOW_ALL_ORIGINS", "False"))

# A list of strings representing regexes that match Origins that are authorized to make cross-site
# HTTP requests. Defaults to [].
CORS_ALLOWED_ORIGIN_REGEXES = []

# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].
CORS_ALLOWED_ORIGINS = []

#
# GraphQL
#

GRAPHENE = {
    "SCHEMA": "nautobot.core.graphql.schema_init.schema",
    "DJANGO_CHOICE_FIELD_ENUM_V3_NAMING": True,  # any field with a name of type will break in Graphene otherwise.
}
GRAPHQL_CUSTOM_FIELD_PREFIX = "cf"
GRAPHQL_RELATIONSHIP_PREFIX = "rel"
GRAPHQL_COMPUTED_FIELD_PREFIX = "cpf"


#
# Caching
#

# The django-redis cache is used to establish concurrent locks using Redis.
CACHES = {
    "default": {
        "BACKEND": os.getenv(
            "NAUTOBOT_CACHES_BACKEND",
            "django_prometheus.cache.backends.redis.RedisCache" if METRICS_ENABLED else "django_redis.cache.RedisCache",
        ),
        "LOCATION": parse_redis_connection(redis_database=1),
        "TIMEOUT": 300,
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            "PASSWORD": "",
        },
    }
}

# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.
CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv("NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT", "0"))

#
# Celery (used for background processing)
#

# Celery Beat heartbeat file path - will be touched by Beat each time it wakes up as a proof-of-health.
CELERY_BEAT_HEARTBEAT_FILE = os.getenv(
    "NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE",
    os.path.join(tempfile.gettempdir(), "nautobot_celery_beat_heartbeat"),
)

# Celery broker URL used to tell workers where queues are located
CELERY_BROKER_URL = os.getenv("NAUTOBOT_CELERY_BROKER_URL", parse_redis_connection(redis_database=0))

# Celery results backend URL to tell workers where to publish task results - DO NOT CHANGE THIS
CELERY_RESULT_BACKEND = "nautobot.core.celery.backends.NautobotDatabaseBackend"

# Enables extended task result attributes (name, args, kwargs, worker, retries, queue, delivery_info) to be written to backend.
CELERY_RESULT_EXTENDED = True

# A value of None or 0 means results will never expire (depending on backend specifications).
CELERY_RESULT_EXPIRES = None

# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`
CELERY_TASK_TRACK_STARTED = True

# If enabled, a `task-sent` event will be sent for every task so tasks can be tracked before they're consumed by a worker.
CELERY_TASK_SEND_SENT_EVENT = True

# If enabled stdout and stderr of running jobs will be redirected to the task logger.
CELERY_WORKER_REDIRECT_STDOUTS = is_truthy(os.getenv("NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS", "True"))

# The log level of log messages generated by redirected job stdout and stderr. Can be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`.
CELERY_WORKER_REDIRECT_STDOUTS_LEVEL = os.getenv("NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL", "WARNING")

# Send task-related events so that tasks can be monitored using tools like flower. Sets the default value for the workers -E argument.
CELERY_WORKER_SEND_TASK_EVENTS = True

# Default celery queue name that will be used by workers and tasks if no queue is specified
CELERY_TASK_DEFAULT_QUEUE = os.getenv("NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE", "default")

# Global task time limits (seconds)
# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,
# while exceeding the hard limit will result in a SIGKILL.
CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT", str(5 * 60)))
CELERY_TASK_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_TIME_LIMIT", str(10 * 60)))

# Ports for prometheus metric HTTP server running on the celery worker.
# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.
# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the
# highest amount of workers you are running on a single machine (comma-separated, like "8080,8081,8082"). You can then
# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in
# that case. Set this to an empty string to disable it.
CELERY_WORKER_PROMETHEUS_PORTS = []
if os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS"):
    CELERY_WORKER_PROMETHEUS_PORTS = [
        int(value) for value in os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS").split(_CONFIG_SETTING_SEPARATOR)
    ]

# These settings define the custom nautobot serialization encoding as an accepted data encoding format
# and register that format for task input and result serialization
CELERY_ACCEPT_CONTENT = ["nautobot_json"]
CELERY_RESULT_ACCEPT_CONTENT = ["nautobot_json"]
CELERY_TASK_SERIALIZER = "nautobot_json"
CELERY_RESULT_SERIALIZER = "nautobot_json"

CELERY_BEAT_SCHEDULER = "nautobot.core.celery.schedulers:NautobotDatabaseScheduler"

# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added
# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`
REDIS_LOCK_TIMEOUT = int(os.getenv("NAUTOBOT_REDIS_LOCK_TIMEOUT", "600"))

#
# Custom branding (logo and title)
#

# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.
# The filepath should be relative to the `MEDIA_ROOT`.
BRANDING_FILEPATHS = {
    "logo": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_LOGO", None),  # Navbar logo
    "favicon": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_FAVICON", None),  # Browser favicon
    "icon_16": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_16", None),  # 16x16px icon
    "icon_32": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_32", None),  # 32x32px icon
    "icon_180": os.getenv(
        "NAUTOBOT_BRANDING_FILEPATHS_ICON_180", None
    ),  # 180x180px icon - used for the apple-touch-icon header
    "icon_192": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_192", None),  # 192x192px icon
    "icon_mask": os.getenv(
        "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK", None
    ),  # mono-chrome icon used for the mask-icon header
    "header_bullet": os.getenv(
        "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET", None
    ),  # bullet image used for various view headers
    "nav_bullet": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET", None),  # bullet image used for nav menu headers
    "css": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_CSS", None),  # Custom global CSS
    "javascript": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT", None),  # Custom global JavaScript
}

# Title to use in place of "Nautobot"
BRANDING_TITLE = os.getenv("NAUTOBOT_BRANDING_TITLE", "Nautobot")

# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)
BRANDING_PREPENDED_FILENAME = os.getenv("NAUTOBOT_BRANDING_PREPENDED_FILENAME", "nautobot_")

# Branding URLs (links in the bottom right of the footer)
BRANDING_URLS = {
    "code": os.getenv("NAUTOBOT_BRANDING_URLS_CODE", "https://github.com/nautobot/nautobot"),
    "docs": os.getenv("NAUTOBOT_BRANDING_URLS_DOCS", None),
    "help": os.getenv("NAUTOBOT_BRANDING_URLS_HELP", "https://github.com/nautobot/nautobot/wiki"),
}

# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.
BRANDING_POWERED_BY_URL = "https://docs.nautobot.com/"

#
# Django extensions settings
#

# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models
SHELL_PLUS_DONT_LOAD = ["taggit"]

#
# UI settings
#


# UI_RACK_VIEW_TRUNCATE_FUNCTION
def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):
    """Given device display name, truncate to fit the rack elevation view.

    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.
    :type device_display_name: str

    :return: Truncated device name
    :type: str
    """
    return str(device_display_name).split(".")[0]


# Custom JSON schema serializer field type mappingss. These will be added to
# `NautobotProcessingMixin.TYPE_MAP`.
# Format: `{serializer_field_class.__name__}` => `{json_schema_type}`
# See: https://github.com/yoyowallet/drf-react-template-framework#settings
DRF_REACT_TEMPLATE_TYPE_MAP = {
    "ContentTypeField": {"type": "string", "enum": "choices"},
    "CustomFieldsDataField": {"type": "object", "widget": "textarea"},
    "DateTimeField": {"type": "string", "format": "date-time", "widget": "date-time"},
    "ImageField": {"type": "string", "format": "data-url"},
    "IPFieldSerializer": {"type": "string"},
    "JSONField": {"type": "string", "widget": "textarea"},
    "MultipleChoiceJSONField": {"type": "array", "required": [], "enum": "choices"},
    "ManyRelatedField": {"type": "array", "required": []},
    #
    # Foreign Key fields
    #
    # enum=choices is the one that works in the UI as a related field but it
    # includes ALL related objects in the schema.
    # "NautobotHyperlinkedRelatedField": {"type": "string", "enum": "choices"},
    # readOnly=True disables the fields in the UI; not what we want.
    # "NautobotHyperlinkedRelatedField": {"type": "string", "readOnly": True},
    # type=string results in a free text field; also not what we want. For now,
    # however, this will keep things moving so the unit tests pass.
    "NautobotHyperlinkedRelatedField": {"type": "object"},
    "PrimaryKeyRelatedField": {"type": "string", "enum": "choices"},
    "RelationshipsDataField": {"type": "object"},
    "SlugField": {"type": "string"},
    "TimeZoneSerializerField": {"type": "string"},
    "UUIDField": {"type": "string", "format": "uuid"},
}


#
# django-silk is used for optional request profiling for debugging purposes
#

SILKY_PYTHON_PROFILER = True
SILKY_PYTHON_PROFILER_BINARY = True
SILKY_PYTHON_PROFILER_EXTENDED_FILE_NAME = True
SILKY_ANALYZE_QUERIES = False  # See the docs for the implications of turning this on https://github.com/jazzband/django-silk?tab=readme-ov-file#enable-query-analysis
SILKY_AUTHENTICATION = True  # User must login
SILKY_AUTHORISATION = True  # User must have permissions


# This makes it so that only superusers can access the silk UI
def silk_user_permissions(user):
    return user.is_superuser


SILKY_PERMISSIONS = silk_user_permissions


# This ensures profiling only happens when enabled on the sessions. Users are able
# to turn this on or off in their user profile. It also ignores health-check requests.
def silk_request_logging_intercept_logic(request):
    if request.path != "/health/":
        if request.session.get("silk_record_requests", False):
            return True
    return False


SILKY_INTERCEPT_FUNC = silk_request_logging_intercept_logic



----- FILE: changes_1858.security (NEW) -----
Added sanitization of HTML tags in the content of `BANNER_TOP`, `BANNER_BOTTOM`, and `BANNER_LOGIN` configuration to prevent against potential injection of malicious scripts (stored XSS) via these features ([GHSA-r2hr-4v48-fjv3](https://github.com/nautobot/nautobot/security/advisories/GHSA-r2hr-4v48-fjv3)).



----- FILE: nautobot_core_templates_admin_base.html (NEW) -----
{% load bootstrapped_goodies_tags %}
{% load helpers %}
{% load i18n %}
{% load plugins %}
{% load static%}

<!DOCTYPE html>
<html lang="en"{% if request.COOKIES|get_item:"theme" == 'dark' %} data-theme="dark"{% endif %}>
<head>
    <title>{% block title %}Admin Home{% endblock %} - Nautobot</title>
    {% include 'inc/media.html' %}
    {% block extrahead %}{% endblock %}
    {% block extrastyle %}{% endblock %}

    <style>
        .description {
            padding-bottom: 20px;
        }
        .help-block {
            white-space: initial;
            word-wrap: break-word;
        }
        .related-widget-wrapper {
            float: none;
        }
        .selectfilter {
            width: 100%;
        }
        .vLargeTextField, .vXMLLargeTextField {
            width: 100%;
        }
        .vTextField {
            width: 100%;
        }
        .related-widget-wrapper > select {
            width: 100%;
        }
        .form-horizontal .control-label {
            text-align: left;
        }
        input[type="checkbox"] {
            margin-left: 0 !important;
        }
        textarea {
            width: 100%;
        }
    </style>
</head>
<body {% if is_popup %}style="padding-left: 0px;"{% endif %}>

{% if not is_popup %}
    {% include 'inc/nav_menu.html' %}
{% endif %}

<div class="container-fluid wrapper" id="main-content" {% if is_popup %}style="padding-bottom: 0px;"{% endif %}>
    {% if not is_popup %}
        {% if "BANNER_TOP"|settings_or_config %}
            <div class="alert alert-info text-center" role="alert">
                {{ "BANNER_TOP"|settings_or_config|render_markdown }}
            </div>
        {% endif %}
        {% if settings.MAINTENANCE_MODE %}
            <div class="alert alert-warning text-center" role="alert">
                <h4><i class="mdi mdi-alert"></i> Maintenance Mode</h4>
                <p>Nautobot is currently in maintenance mode. Functionality may be limited.</p>
            </div>
        {% endif %}
        {% plugin_banners %}
    {% endif %}
    {% for message in messages %}
        <div class="alert alert-{{ message.tags }} alert-dismissable" role="alert">
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span>&times;</span>
            </button>
            {{ message }}
        </div>
    {% endfor %}
    <!-- Content -->
    <div class="container-fluid wrapper">
        {% if not is_popup %}
            <div class="row noprint">
                {% block breadcrumbs %}
                {% endblock %}
            </div>
        {% endif %}
        <div>
            <div>
                {% block pretitle %}{% endblock %}
                <div class="pull-right noprint">
                    {% block object-tools %}{% endblock %}
                </div>
                <div>
                    {% block content_title %}
                        {% if title %}
                            <h1>{% render_with_template_if_exist title|lower|add:"/admin_app_name.html" title %}</h1>
                            <ul class="nav nav-tabs"></ul>
                        {% endif %}
                    {% endblock %}
                    <br>
                </div>
            </div>
        </div>
        <div class="container-fluid wrapper">
            {% block content %}{{ content }}{% endblock %}
        </div>
    </div>
    <div class="push"></div>
    {% if "BANNER_BOTTOM"|settings_or_config %}
        <div class="alert alert-info text-center banner-bottom" role="alert">
                {{ "BANNER_BOTTOM"|settings_or_config|render_markdown }}
        </div>
    {% endif %}
</div>
{% if not is_popup %}
    {% include 'inc/footer.html' %}
{% endif %}
{% include 'modals/modal_theme.html' with name='theme'%}

{% block javascript %}
    {% include 'inc/javascript.html' %}
{% endblock %}
</body>
</html>



----- FILE: nautobot_core_tests_test_views.py (NEW) -----
import re
from unittest import mock
import urllib.parse

from django.apps import apps
from django.contrib.contenttypes.models import ContentType
from django.core.files.uploadedfile import SimpleUploadedFile
from django.test import override_settings, RequestFactory
from django.test.utils import override_script_prefix
from django.urls import get_script_prefix, reverse
from prometheus_client.parser import text_string_to_metric_families

from nautobot.core.constants import GLOBAL_SEARCH_EXCLUDE_LIST
from nautobot.core.testing import TestCase
from nautobot.core.testing.api import APITestCase
from nautobot.core.utils.permissions import get_permission_for_model
from nautobot.core.views import NautobotMetricsView
from nautobot.core.views.mixins import GetReturnURLMixin
from nautobot.dcim.models.locations import Location
from nautobot.extras.choices import CustomFieldTypeChoices
from nautobot.extras.models import FileProxy
from nautobot.extras.models.customfields import CustomField, CustomFieldChoice
from nautobot.extras.registry import registry
from nautobot.users.models import ObjectPermission


class GetReturnURLMixinTestCase(TestCase):
    """Tests for the API of GetReturnURLMixin."""

    @classmethod
    def setUpTestData(cls):
        cls.factory = RequestFactory(SERVER_NAME="nautobot.example.com")
        cls.mixin = GetReturnURLMixin()

    def test_get_return_url_explicit(self):
        request = self.factory.get("/", {"return_url": "/dcim/devices/"})
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), "/dcim/devices/")
        self.assertEqual(self.mixin.get_return_url(request=request, obj=Location.objects.first()), "/dcim/devices/")

        request = self.factory.get("/", {"return_url": "/dcim/devices/?status=Active"})
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), "/dcim/devices/?status=Active")

    def test_get_return_url_explicit_unsafe(self):
        request = self.factory.get("/", {"return_url": "http://example.com"})
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), reverse("home"))

    def test_get_return_url_explicit_punycode(self):
        """
        Replace the 'i' in '/dcim/' with a unicode dotless 'ı' and make sure we're not fooled by it.
        """  # noqa: RUF002  # ambiguous-unicode-character-docstring -- fully intentional here!
        request = self.factory.get("/", {"return_url": "/dcım/devices/"})  # noqa: RUF001  # ambiguous-unicode-character-string -- fully intentional here!
        self.assertEqual(self.mixin.get_return_url(request=request, obj=None), "/dc%C4%B1m/devices/")

    def test_get_return_url_default_with_obj(self):
        request = self.factory.get("/")
        location = Location.objects.first()
        self.assertEqual(self.mixin.get_return_url(request=request, obj=location), location.get_absolute_url())


class HomeViewTestCase(TestCase):
    def test_home(self):
        url = reverse("home")

        response = self.client.get(url)
        self.assertHttpStatus(response, 200)

    def test_search(self):
        url = reverse("search")
        params = {
            "q": "foo",
        }

        response = self.client.get(f"{url}?{urllib.parse.urlencode(params)}")
        self.assertHttpStatus(response, 200)

    def test_appropriate_models_included_in_global_search(self):
        # Gather core app configs
        existing_models = []
        global_searchable_models = []
        for app_name in ["circuits", "dcim", "extras", "ipam", "tenancy", "virtualization"]:
            app_config = apps.get_app_config(app_name)
            existing_models += [model._meta.model_name for model in app_config.get_models()]
            global_searchable_models += app_config.searchable_models

        # Remove those models that are not searchable
        existing_models = [model for model in existing_models if model not in GLOBAL_SEARCH_EXCLUDE_LIST]
        existing_models.sort()

        # See if there are any models that are missing from global search
        difference = [model for model in existing_models if model not in global_searchable_models]
        if difference:
            self.fail(
                f'Existing model/models {",".join(difference)} are not included in the searchable_models attribute of the app config.\n'
                'If you do not want the models to be searchable, please include them in the GLOBAL_SEARCH_EXCLUDE_LIST constant in nautobot.core.constants.'
            )

    def make_request(self):
        url = reverse("home")
        response = self.client.get(url)

        # Search bar in nav
        nav_search_bar_pattern = re.compile(
            '<nav.*<form action="/search/" method="get" class="navbar-form" id="navbar_search" role="search">.*</form>.*</nav>'
        )
        nav_search_bar_result = nav_search_bar_pattern.search(
            response.content.decode(response.charset).replace("\n", "")
        )

        # Global search bar in body/container-fluid wrapper
        body_search_bar_pattern = re.compile(
            '<div class="container-fluid wrapper" id="main-content">.*<form action="/search/" method="get" class="form-inline">.*</form>.*</div>',
            re.DOTALL,
        )

        body_search_bar_result = body_search_bar_pattern.search(
            response.content.decode(response.charset).replace("\n", "")
        )

        return nav_search_bar_result, body_search_bar_result

    def test_search_bar_not_visible_if_user_not_authenticated(self):
        self.client.logout()

        nav_search_bar_result, body_search_bar_result = self.make_request()

        self.assertIsNone(nav_search_bar_result)
        self.assertIsNone(body_search_bar_result)

    def test_search_bar_visible_if_user_authenticated(self):
        nav_search_bar_result, body_search_bar_result = self.make_request()

        self.assertIsNotNone(nav_search_bar_result)
        self.assertIsNotNone(body_search_bar_result)

    @override_settings(VERSION="1.2.3")
    def test_footer_version_visible_authenticated_users_only(self):
        url = reverse("home")
        response = self.client.get(url)
        response_content = response.content.decode(response.charset).replace("\n", "")

        footer_hostname_version_pattern = re.compile(r'<p class="text-muted">\s+\S+\s+\(v1\.2\.3\)\s+</p>')
        self.assertRegex(response_content, footer_hostname_version_pattern)

        self.client.logout()
        response = self.client.get(url)
        response_content = response.content.decode(response.charset).replace("\n", "")
        self.assertNotRegex(response_content, footer_hostname_version_pattern)

    def test_banners_markdown(self):
        url = reverse("home")
        with override_settings(
            BANNER_TOP="# Hello world",
            BANNER_BOTTOM="[info](https://nautobot.com)",
        ):
            response = self.client.get(url)
        self.assertInHTML("<h1>Hello world</h1>", response.content.decode(response.charset))
        self.assertInHTML(
            '<a href="https://nautobot.com" rel="noopener noreferrer">info</a>',
            response.content.decode(response.charset),
        )

        with override_settings(BANNER_LOGIN="_Welcome to Nautobot!_"):
            self.client.logout()
            response = self.client.get(reverse("login"))
        self.assertInHTML("<em>Welcome to Nautobot!</em>", response.content.decode(response.charset))

    def test_banners_no_xss(self):
        url = reverse("home")
        with override_settings(
            BANNER_TOP='<script>alert("Hello from above!");</script>',
            BANNER_BOTTOM='<script>alert("Hello from below!");</script>',
        ):
            response = self.client.get(url)
        self.assertNotIn("Hello from above", response.content.decode(response.charset))
        self.assertNotIn("Hello from below", response.content.decode(response.charset))

        with override_settings(BANNER_LOGIN='<script>alert("Welcome to Nautobot!");</script>'):
            self.client.logout()
            response = self.client.get(reverse("login"))
        self.assertNotIn("Welcome to Nautobot!", response.content.decode(response.charset))


@override_settings(BRANDING_TITLE="Nautobot")
class SearchFieldsTestCase(TestCase):
    def test_search_bar_redirect_to_login(self):
        self.client.logout()
        response = self.client.get(reverse("search") + "?q=prefix")
        # Assert that if the user is not logged in
        # SearchForm will redirect the user to the login Page
        self.assertEqual(response.status_code, 302)

    def test_global_and_model_search_bar(self):
        self.add_permissions("dcim.view_location", "dcim.view_device")

        # Assert model search bar present in list UI
        response = self.client.get(reverse("dcim:location_list"))
        self.assertInHTML(
            '<input type="text" name="q" class="form-control" required placeholder="Search Locations" id="id_q">',
            response.content.decode(response.charset),
        )

        response = self.client.get(reverse("dcim:device_list"))
        self.assertInHTML(
            '<input type="text" name="q" class="form-control" required placeholder="Search Devices" id="id_q">',
            response.content.decode(response.charset),
        )

        # Assert global search bar present in UI
        self.assertInHTML(
            '<input type="text" name="q" class="form-control" placeholder="Search Nautobot">',
            response.content.decode(response.charset),
        )


class FilterFormsTestCase(TestCase):
    def test_support_for_both_default_and_dynamic_filter_form_in_ui(self):
        self.add_permissions("dcim.view_location", "circuits.view_circuit")

        filter_tabs = """
            <ul id="tabs" class="nav nav-tabs">
                <li role="presentation" class="active">
                    <a href="#default-filter" role="tab" data-toggle="tab">
                        Default
                    </a>
                </li>
                <li role="presentation" class="">
                    <a href="#advanced-filter" role="tab" data-toggle="tab">
                        Advanced
                    </a>
                </li>
            </ul>
            """

        response = self.client.get(reverse("dcim:location_list"))
        self.assertInHTML(
            filter_tabs,
            response.content.decode(response.charset),
        )

        response = self.client.get(reverse("circuits:circuit_list"))
        self.assertInHTML(
            filter_tabs,
            response.content.decode(response.charset),
        )

    def test_filtering_on_custom_select_filter_field(self):
        """Assert CustomField select and multiple select fields can be filtered using multiple entries"""
        self.add_permissions("dcim.view_location")

        multi_select_cf = CustomField.objects.create(
            type=CustomFieldTypeChoices.TYPE_MULTISELECT, label="Multiple Choice"
        )
        select_cf = CustomField.objects.create(type=CustomFieldTypeChoices.TYPE_SELECT, label="choice")
        choices = ["Foo", "Bar", "FooBar"]
        for cf in [multi_select_cf, select_cf]:
            cf.content_types.set([ContentType.objects.get_for_model(Location)])
            CustomFieldChoice.objects.create(custom_field=cf, value=choices[0])
            CustomFieldChoice.objects.create(custom_field=cf, value=choices[1])
            CustomFieldChoice.objects.create(custom_field=cf, value=choices[2])

        locations = Location.objects.all()[:3]
        for idx, location in enumerate(locations):
            location.cf[multi_select_cf.key] = choices[:2]
            location.cf[select_cf.key] = choices[idx]
            location.save()

        query_param = (
            f"?cf_{multi_select_cf.key}={choices[0]}&cf_{multi_select_cf.key}={choices[1]}"
            f"&cf_{select_cf.key}={choices[0]}&cf_{select_cf.key}={choices[1]}"
        )
        url = reverse("dcim:location_list") + query_param
        response = self.client.get(url)
        self.assertHttpStatus(response, 200)
        response_content = response.content.decode(response.charset).replace("\n", "")
        self.assertInHTML(locations[0].name, response_content)
        self.assertInHTML(locations[1].name, response_content)

    def test_filtering_crafted_query_params(self):
        """Test for reflected-XSS vulnerability GHSA-jxgr-gcj5-cqqg."""
        self.add_permissions("dcim.view_location")
        query_param = "?location_type=1 onmouseover=alert('hi') foo=bar"
        url = reverse("dcim:location_list") + query_param
        response = self.client.get(url)
        self.assertHttpStatus(response, 200)
        response_content = response.content.decode(response.charset)
        # The important thing here is that the data-field-parent and data-field-value are correctly quoted
        self.assertInHTML(
            """
<span class="filter-selection-choice-remove remove-filter-param"
      data-field-type="child"
      data-field-parent="location_type"
      data-field-value="1 onmouseover=alert(&#x27;hi&#x27;) foo=bar"
>×</span>""",  # noqa: RUF001 - ambiguous-unicode-character-string
            response_content,
        )


class ForceScriptNameTestcase(TestCase):
    """Basic test to assert that `settings.FORCE_SCRIPT_NAME` works as intended."""

    @override_settings(
        FORCE_SCRIPT_NAME="/nautobot/",
    )
    @override_script_prefix("/nautobot/")
    def test_subdirectory_routes(self):
        # We must call `set_script_prefix()` to set the URL resolver script prefix outside of the
        # request/response cycle (e.g. in scripts/tests) to generate correct URLs when `SCRIPT_NAME`
        # is not `/`.
        #
        # We must then call it again to reset the script pefix after we're done because
        # the state is stored in the thread-local scope and will "infect" other tests.
        prefix = get_script_prefix()
        self.assertEqual(prefix, "/nautobot/")

        # And that routes will start w/ the prefix vs. just "/" (the default).
        routes = ("home", "login", "search", "api-root")
        for route in routes:
            url = reverse(route)
            self.assertTrue(url.startswith(prefix))


class NavAppsUITestCase(TestCase):
    def setUp(self):
        super().setUp()

        self.url = reverse("apps:apps_list")
        self.item_weight = 100  # TODO: not easy to introspect from the nav menu struct, so hard-code it here for now

    def make_request(self):
        response = self.client.get(reverse("home"))
        return response.content.decode(response.charset)

    def test_installed_apps_visible(self):
        """The "Installed Apps" menu item should be available to an authenticated user regardless of permissions."""
        response_content = self.make_request()
        self.assertInHTML(
            f"""
            <a href="{self.url}"
                data-item-weight="{self.item_weight}">
                Installed Apps
            </a>
            """,
            response_content,
        )


class LoginUITestCase(TestCase):
    def setUp(self):
        super().setUp()

        self.footer_elements = [
            '<a href="#theme_modal" data-toggle="modal" data-target="#theme_modal" id="btn-theme-modal"><i class="mdi mdi-theme-light-dark text-primary"></i>Theme</a>',
            '<a href="/static/docs/index.html">Docs</a>',
            '<i class="mdi mdi-cloud-braces text-primary"></i> <a href="/api/docs/">API</a>',
            '<i class="mdi mdi-graphql text-primary"></i> <a href="/graphql/">GraphQL</a>',
            '<i class="mdi mdi-xml text-primary"></i> <a href="https://github.com/nautobot/nautobot">Code</a>',
            '<i class="mdi mdi-lifebuoy text-primary"></i> <a href="https://github.com/nautobot/nautobot/wiki">Help</a>',
        ]

    def make_request(self):
        response = self.client.get(reverse("login"))
        sso_login_pattern = re.compile('<a href=".*">Continue with SSO</a>')
        return sso_login_pattern.search(response.content.decode(response.charset))

    def test_sso_login_button_not_visible(self):
        """Test Continue with SSO button not visible if SSO is enabled"""
        self.client.logout()

        sso_login_search_result = self.make_request()
        self.assertIsNone(sso_login_search_result)

    @override_settings(
        AUTHENTICATION_BACKENDS=[
            "social_core.backends.google.GoogleOAuth2",
            "nautobot.core.authentication.ObjectPermissionBackend",
        ]
    )
    def test_sso_login_button_visible(self):
        self.client.logout()
        sso_login_search_result = self.make_request()
        self.assertIsNotNone(sso_login_search_result)

    def test_graphql_redirects_back_to_login_unauthenticated(self):
        """Assert that graphql redirects to login page if user is unauthenticated."""
        self.client.logout()
        headers = {"HTTP_ACCEPT": "text/html"}
        url = reverse("graphql")
        response = self.client.get(url, follow=True, **headers)
        self.assertHttpStatus(response, 200)
        self.assertRedirects(response, f"/login/?next={url}")
        response_content = response.content.decode(response.charset).replace("\n", "")
        for footer_text in self.footer_elements:
            self.assertNotIn(footer_text, response_content)

    def test_api_docs_403_unauthenticated(self):
        """Assert that api docs return a 403 Forbidden if user is unauthenticated."""
        self.client.logout()
        urls = [
            reverse("api_docs"),
            reverse("api_redocs"),
            reverse("schema"),
            reverse("schema_json"),
            reverse("schema_yaml"),
        ]
        for url in urls:
            response = self.client.get(url)
            self.assertHttpStatus(response, 403)


class MetricsViewTestCase(TestCase):
    def query_and_parse_metrics(self):
        response = self.client.get(reverse("metrics"))
        self.assertHttpStatus(response, 200, msg="/metrics should return a 200 HTTP status code.")
        page_content = response.content.decode(response.charset)
        return text_string_to_metric_families(page_content)

    def test_metrics_extensibility(self):
        """Assert that the example metric from the Example App shows up _exactly_ when the app is enabled."""
        test_metric_name = "nautobot_example_metric_count"
        metrics_with_app = self.query_and_parse_metrics()
        metric_names_with_app = {metric.name for metric in metrics_with_app}
        self.assertIn(test_metric_name, metric_names_with_app)
        with override_settings(PLUGINS=[]):
            # Clear out the app metric registry because it is not updated when settings are changed but Nautobot is not
            # restarted.
            registry["app_metrics"].clear()
            metrics_without_app = self.query_and_parse_metrics()
            metric_names_without_app = {metric.name for metric in metrics_without_app}
            self.assertNotIn(test_metric_name, metric_names_without_app)
        metric_names_with_app.remove(test_metric_name)
        self.assertSetEqual(metric_names_with_app, metric_names_without_app)


class AuthenticateMetricsTestCase(APITestCase):
    def test_metrics_authentication(self):
        """Assert that if metrics require authentication, a user not logged in gets a 403."""
        self.client.logout()
        headers = {}
        response = self.client.get(reverse("metrics"), **headers)
        self.assertHttpStatus(response, 403, msg="/metrics should return a 403 HTTP status code.")

    def test_metrics(self):
        """Assert that if metrics don't require authentication, a user not logged in gets a 200."""
        self.factory = RequestFactory()
        self.client.logout()

        request = self.factory.get("/")
        response = NautobotMetricsView.as_view()(request)
        self.assertHttpStatus(response, 200, msg="/metrics should return a 200 HTTP status code.")


class ErrorPagesTestCase(TestCase):
    """Tests for 4xx and 5xx error page rendering."""

    @override_settings(DEBUG=False)
    def test_404_default_support_message(self):
        """Nautobot's custom 404 page should be used and should include a default support message."""
        with self.assertTemplateUsed("404.html"):
            response = self.client.get("/foo/bar")
        self.assertContains(response, "Network to Code", status_code=404)
        response_content = response.content.decode(response.charset)
        self.assertInHTML(
            "If further assistance is required, please join the <code>#nautobot</code> channel on "
            '<a href="https://slack.networktocode.com/" rel="noopener noreferrer">Network to Code\'s '
            "Slack community</a> and post your question.",
            response_content,
        )

    @override_settings(DEBUG=False, SUPPORT_MESSAGE="Hello world!")
    def test_404_custom_support_message(self):
        """Nautobot's custom 404 page should be used and should include a custom support message if defined."""
        with self.assertTemplateUsed("404.html"):
            response = self.client.get("/foo/bar")
        self.assertNotContains(response, "Network to Code", status_code=404)
        response_content = response.content.decode(response.charset)
        self.assertInHTML("Hello world!", response_content)

    @override_settings(DEBUG=False)
    @mock.patch("nautobot.core.views.HomeView.get", side_effect=Exception)
    def test_500_default_support_message(self, mock_get):
        """Nautobot's custom 500 page should be used and should include a default support message."""
        url = reverse("home")
        with self.assertTemplateUsed("500.html"):
            self.client.raise_request_exception = False
            response = self.client.get(url)
        self.assertContains(response, "Network to Code", status_code=500)
        response_content = response.content.decode(response.charset)
        self.assertInHTML(
            "If further assistance is required, please join the <code>#nautobot</code> channel on "
            '<a href="https://slack.networktocode.com/" rel="noopener noreferrer">Network to Code\'s '
            "Slack community</a> and post your question.",
            response_content,
        )

    @override_settings(DEBUG=False, SUPPORT_MESSAGE="Hello world!")
    @mock.patch("nautobot.core.views.HomeView.get", side_effect=Exception)
    def test_500_custom_support_message(self, mock_get):
        """Nautobot's custom 500 page should be used and should include a custom support message if defined."""
        url = reverse("home")
        with self.assertTemplateUsed("500.html"):
            self.client.raise_request_exception = False
            response = self.client.get(url)
        self.assertNotContains(response, "Network to Code", status_code=500)
        response_content = response.content.decode(response.charset)
        self.assertInHTML("Hello world!", response_content)


class DBFileStorageViewTestCase(TestCase):
    """Test authentication/permission enforcement for django_db_file_storage views."""

    def setUp(self):
        super().setUp()
        self.test_file_1 = SimpleUploadedFile(name="test_file_1.txt", content=b"I am content.\n")
        self.file_proxy_1 = FileProxy.objects.create(name=self.test_file_1.name, file=self.test_file_1)
        self.test_file_2 = SimpleUploadedFile(name="test_file_2.txt", content=b"I am content.\n")
        self.file_proxy_2 = FileProxy.objects.create(name=self.test_file_2.name, file=self.test_file_2)
        self.url = f"{reverse('db_file_storage.download_file')}?name={self.file_proxy_1.file.name}"

    def test_get_file_anonymous(self):
        self.client.logout()
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 403)

    def test_get_file_without_permission(self):
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 403)

    def test_get_object_with_permission(self):
        self.add_permissions(get_permission_for_model(FileProxy, "view"))
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 200)

    def test_get_object_with_constrained_permission(self):
        obj_perm = ObjectPermission(
            name="Test permission",
            constraints={"pk": self.file_proxy_1.pk},
            actions=["view"],
        )
        obj_perm.save()
        obj_perm.users.add(self.user)
        obj_perm.object_types.add(ContentType.objects.get_for_model(FileProxy))
        response = self.client.get(self.url)
        self.assertHttpStatus(response, 200)
        url = f"{reverse('db_file_storage.download_file')}?name={self.file_proxy_2.file.name}"
        response = self.client.get(url)
        self.assertHttpStatus(response, 404)


class SilkUIAccessTestCase(TestCase):
    """Test access control related to the django-silk UI"""

    def test_access_for_non_superuser(self):
        # Login as non-superuser
        self.user.is_superuser = False
        self.user.save()
        self.client.force_login(self.user)

        # Attempt to access the view
        response = self.client.get(reverse("silk:summary"))

        # Check for redirect or forbidden status code (302 or 403)
        self.assertIn(response.status_code, [302, 403])

    def test_access_for_superuser(self):
        # Login as superuser
        self.user.is_superuser = True
        self.user.save()
        self.client.force_login(self.user)

        # Attempt to access the view
        response = self.client.get(reverse("silk:summary"))

        # Check for success status code (e.g., 200)
        self.assertEqual(response.status_code, 200)



----- FILE: nautobot_core_settings.yaml (NEW) -----
---
"$schema": "https://json-schema.org/draft/2020-12/schema"
title: "Nautobot Settings"
definitions:
  absolute_path:
    type: "string"
  callable:
    type: "string"
  regex:
    type: "string"
  relative_path:
    type: "string"
type: "object"
properties:
  ADMINS:
    default: []
    description: >-
      Administrators' names and emails as a list of (name, email) tuples.
      Nautobot will email details about critical errors to any administrators listed here.
    details: |
      For example:

      ```python
      ADMINS = [
          ['Hank Hill', 'hhill@example.com'],
          ['Dale Gribble', 'dgribble@example.com'],
      ]
      ```
    items:
      items:
        type: "string"
      type: "array"
    see_also:
      "Django documentation for `ADMINS`": "https://docs.djangoproject.com/en/stable/ref/settings/#admins"
    type: "array"
  ALLOW_REQUEST_PROFILING:
    default: false
    description: "Global setting to allow or deny users from enabling request profiling on their login session."
    environment_variable: "NAUTOBOT_ALLOW_REQUEST_PROFILING"
    is_constance_config: true
    see_also:
      "Administration guide to request profiling": "../guides/request-profiling.md"
    type: "boolean"
    version_added: "2.2.0"
  ALLOWED_HOSTS:
    default: []
    description: >-
      A list of valid fully-qualified domain names (FQDNs) and/or IP addresses that can be used to reach the
      Nautobot service. (If provided as an environment variable, it should be a space-separated string, for example
      `NAUTOBOT_ALLOWED_HOSTS="localhost 127.0.0.1 example.com"`)
    details: |-
      Usually this is the same as the hostname for the Nautobot server, but can also be different; for example,
      when using a reverse proxy serving the Nautobot website under a different FQDN than the hostname of the
      Nautobot server. To help guard against [HTTP Host header attacks](https://docs.djangoproject.com/en/stable/topics/security/#host-headers-virtual-hosting),
      Nautobot will not permit access to the server via any other hostnames or IPs.

      Keep in mind that by default Nautobot sets
      [`USE_X_FORWARDED_HOST`](https://docs.djangoproject.com/en/stable/ref/settings/#use-x-forwarded-host)
      to `True`, which means that if you're using a reverse proxy, the FQDN used to reach that reverse proxy needs
      to be in this list.

      !!! warning
          This parameter must always be defined as a list or tuple, even if only a single value is provided.

      Example:

      ```python
      ALLOWED_HOSTS = ['nautobot.example.com', '192.0.2.123']
      ```

      !!! tip
          If there is more than one hostname in this list, you may also need to set
          [CSRF_TRUSTED_ORIGINS](optional-settings.md#csrf_trusted_origins) as well.

      If you are not yet sure what the domain name and/or IP address of the Nautobot installation will be,
      and are comfortable accepting the risks in doing so, you can set this to a wildcard (asterisk) to
      allow all host values:

      ```python
      ALLOWED_HOSTS = ['*']
      ```

      !!! warning
          It is not recommended to leave this value as `['*']` for production deployments.
    environment_variable: "NAUTOBOT_ALLOWED_HOSTS"
    is_required_setting: true
    items:
      type: "string"
    see_also:
      "Django documentation for `ALLOWED_HOSTS`": "https://docs.djangoproject.com/en/stable/ref/settings/#allowed-hosts"
    type: "array"
  ALLOWED_URL_SCHEMES:
    default:
    - "file"
    - "ftp"
    - "ftps"
    - "http"
    - "https"
    - "irc"
    - "mailto"
    - "sftp"
    - "ssh"
    - "tel"
    - "telnet"
    - "tftp"
    - "vnc"
    - "xmpp"
    description: >-
      A list of permitted URL schemes referenced when rendering links within Nautobot.
      Note that only the schemes specified in this list will be accepted; if adding your own,
      be sure to replicate all of the default values as well (excluding those schemes which are not desirable).
    items:
      type: "string"
    type: "array"
  AUTHENTICATION_BACKENDS:
    default:
    - "nautobot.core.authentication.ObjectPermissionBackend"
    description: >-
      A list of authentication backend classes (as strings) to use when attempting to authenticate a user.
      The entry `"nautobot.core.authentication.ObjectPermissionBackend"` **must** always be the last in this list.
    items:
      type: "string"
    see_also:
      "Django documentation for `AUTHENTICATION_BACKENDS`": "https://docs.djangoproject.com/en/stable/ref/settings/#std-setting-AUTHENTICATION_BACKENDS"
      "LDAP Authentication": "./authentication/ldap.md"
      "Remote User Authentication": "./authentication/remote.md"
      "Single Sign On (SSO)": "./authentication/sso.md"
    type: "array"
  BANNER_BOTTOM:
    default: ""
    description: >-
      Custom content to be displayed in a banner at the bottom of all Nautobot pages.
    details: |-
      +/- 2.2.4
          Markdown formatting is supported within this message, as well as
          [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).
    environment_variable: "NAUTOBOT_BANNER_BOTTOM"
    is_constance_config: true
    type: "string"
  BANNER_LOGIN:
    default: ""
    description: >-
      Custom content to be displayed in a banner on the login page above the login form.
    details: |-
      +/- 2.2.4
          Markdown formatting is supported within this message, as well as
          [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).
    environment_variable: "NAUTOBOT_BANNER_LOGIN"
    is_constance_config: true
    type: "string"
  BANNER_TOP:
    default: ""
    description: >-
      Custom content to be displayed in a banner at the top of all Nautobot pages.
    details: |-
      +/- 2.2.4
          Markdown formatting is supported within this message, as well as
          [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).
    environment_variable: "NAUTOBOT_BANNER_TOP"
    is_constance_config: true
    type: "string"
  BRANDING_FILEPATHS:
    default:
      css: null
      favicon: null
      header_bullet: null
      icon_16: null
      icon_32: null
      icon_180: null
      icon_192: null
      icon_mask: null
      javascript: null
      logo: null
      nav_bullet: null
    description: >-
      A set of filepaths relative to the [`MEDIA_ROOT`](#media_root) which locate assets used for
      custom branding of your Nautobot instance.
      With the exception of `css` and `javascript`, which provide the option to add an _additional_ file to Nautobot
      page content, each of the other assets takes the place of the corresponding stock Nautobot asset.
      This allows for, for instance, providing your own navbar logo and favicon.
      If a custom asset is not provided for any of the above options, the stock Nautobot asset is used.
    details: |-
      +++ 2.1.0
          The `header_bullet` and `nav_bullet` assets were added as options.

      +++ 2.2.4
          The `css` and `javascript` assets were added as options.
    properties:
      css:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Custom global CSS file"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_CSS"
      favicon:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Browser favicon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_FAVICON"
      header_bullet:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Bullet image used for various view headers"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET"
      icon_16:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "16x16px icon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_16"
      icon_180:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "180x180px icon - used for the apple-touch-icon header"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_180"
      icon_192:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "192x192px icon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_192"
      icon_32:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "32x32px icon"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_32"
      icon_mask:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Mono-chrome icon used for the mask-icon header"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK"
      javascript:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Custom global JavaScript file"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT"
      logo:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Navbar logo"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_LOGO"
      nav_bullet:
        "$ref": "#/definitions/relative_path"
        default: null
        description: "Bullet image used for nav menu headers"
        environment_variable: "NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET"
    type: "object"
    version_added: "1.2.0"
  BRANDING_PREPENDED_FILENAME:
    default: "nautobot_"
    description: "Defines the prefix of the filename when exporting to CSV/YAML or export templates."
    environment_variable: "NAUTOBOT_BRANDING_PREPENDED_FILENAME"
    type: "string"
    version_added: "1.3.4"
  BRANDING_TITLE:
    default: "Nautobot"
    description: >-
      Defines the custom branding title that should be used in place of 'Nautobot' within user facing areas
      of the application, such as the HTML title of web pages.
    environment_variable: "NAUTOBOT_BRANDING_TITLE"
    type: "string"
    version_added: "1.2.0"
  BRANDING_URLS:
    default:
      code: "https://github.com/nautobot/nautobot"
      docs: null
      help: "https://github.com/nautobot/nautobot/wiki"
    description: >-
      A set of URLs that correspond to helpful links in the right of the footer on every web page.
      If a custom URL is not provided for any of the links, the default link within the Nautobot community is used.
    properties:
      code:
        default: "https://github.com/nautobot/nautobot"
        description: "Code link in the footer"
        environment_variable: "NAUTOBOT_BRANDING_URLS_CODE"
        format: "uri"
        type: "string"
      docs:
        "$ref": "#/definitions/relative_path"
        default: "static/docs/index.html"
        description: "Docs link in the footer"
        environment_variable: "NAUTOBOT_BRANDING_URLS_DOCS"
      help:
        default: "https://github.com/nautobot/nautobot/wiki"
        description: "Help link in the footer"
        environment_variable: "NAUTOBOT_BRANDING_URLS_HELP"
        format: "uri"
        type: "string"
    type: "object"
    version_added: "1.2.0"
  CACHES:
    additionalProperties: true
    default:
      default:
        BACKEND: "django_redis.cache.RedisCache"
        LOCATION: "redis://localhost:6379/1"
        OPTIONS:
          CLIENT_CLASS: "django_redis.client.DefaultClient"
          PASSWORD: ""
        TIMEOUT: 300
    description: "The `CACHES` setting is required to simplify the configuration for `django-redis`."
    details: |-
      The [`django-redis`](https://github.com/jazzband/django-redis) Django plugin is used to enable Redis
      as a concurrent write lock for preventing race conditions when allocating IP address objects.

      !!! important
          Nautobot also utilizes the built-in
          [Django cache framework](https://docs.djangoproject.com/en/stable/topics/cache/)
          (which also relies on the `CACHES` setting) to perform caching.

      +/- 2.0.0
          The default value of `CACHES["default"]["LOCATION"]` has changed from `redis://localhost:6379/0`
          to `redis://localhost:6379/1`, as Django's native caching is now taking the role previously occupied by
          `django-cacheops`.
    is_required_setting: true
    properties:
      default:
        properties:
          BACKEND:
            default: "django_redis.cache.RedisCache"
            enum:
            - "django_redis.cache.RedisCache"
            - "django_prometheus.cache.backends.redis.RedisCache"
            environment_variable: "NAUTOBOT_CACHES_BACKEND"
            type: "string"
          LOCATION:
            default: "redis://localhost:6379/1"
            format: "uri"
            type: "string"
          OPTIONS:
            additionalProperties: true
            properties:
              CLIENT_CLASS:
                default: "django_redis.client.DefaultClient"
                type: "string"
              PASSWORD:
                default: ""
                type: "string"
            type: "object"
          TIMEOUT:
            default: 300
            type: "integer"
        type: "object"
    see_also:
      "Guide to Nautobot Caching, including TLS and HA configuration": "../../administration/guides/caching.md"
    type: "object"
  CELERY_BEAT_HEARTBEAT_FILE:
    default: "/tmp/nautobot_celery_beat_heartbeat"
    description: "A file touched by Celery Beat during health check."
    environment_variable: "NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE"
    type: "string"
  CELERY_BROKER_TRANSPORT_OPTIONS:
    additionalProperties: true
    default: {}
    description: "A dict of additional options passed to the Celery broker transport."
    details: >-
      This is only required when
      [configuring Celery to utilize Redis Sentinel](../../administration/guides/caching.md#celery-sentinel-configuration).
    properties:
      master_name:
        type: "string"
      sentinel_kwargs:
        additionalProperties: true
        properties:
          password:
            type: "string"
        type: "object"
    type: "object"
  CELERY_BROKER_URL:
    default: "redis://localhost:6379/0"
    description: "Celery broker URL used to tell workers where queues are located."
    environment_variable: "NAUTOBOT_CELERY_BROKER_URL"
    format: "uri"
    type: "string"
  CELERY_BROKER_USE_SSL:
    default: null
    description: "Optional configuration for Celery to use custom SSL certificates to connect to Redis."
    properties:
      ssl_ca_certs:
        "$ref": "#/definitions/absolute_path"
      ssl_cert_reqs:
        type: "boolean"
      ssl_certfile:
        "$ref": "#/definitions/absolute_path"
      ssl_keyfile:
        "$ref": "#/definitions/absolute_path"
    see_also:
      "Celery documentation": "https://docs.celeryq.dev/en/stable/userguide/configuration.html#std-setting-broker_use_ssl"
    type: "object"
  CELERY_REDIS_BACKEND_USE_SSL:
    default: false
    description: "Optional configuration for Celery to use custom SSL certificates to connect to Redis."
    properties:
      ssl_ca_certs:
        "$ref": "#/definitions/absolute_path"
      ssl_cert_reqs:
        type: "boolean"
      ssl_certfile:
        "$ref": "#/definitions/absolute_path"
      ssl_keyfile:
        "$ref": "#/definitions/absolute_path"
    see_also:
      "Celery documentation": "https://docs.celeryq.dev/en/stable/userguide/configuration.html#std-setting-redis_backend_use_ssl"
    type: "object"
  CELERY_TASK_DEFAULT_QUEUE:
    default: "default"
    description: >-
      The default celery queue name that will be used by workers if no queue is specified in the
      `nautobot-server celery worker` command. This queue will also be used by celery tasks
      if no queue is specified when a task is run.
    environment_variable: "NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE"
    type: "string"
    version_added: "1.5.0"
  CELERY_TASK_SOFT_TIME_LIMIT:
    default: 300
    description: "The global Celery task soft timeout (in seconds)."
    details: >-
      Any background task that exceeds this duration will receive a `SoftTimeLimitExceeded` exception and is
      responsible for handling this exception and performing any necessary cleanup or final operations before ending.
    environment_variable: "NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT"
    see_also:
      "`CELERY_TASK_TIME_LIMIT`": "#celery_task_time_limit"
    type: "integer"
  CELERY_TASK_TIME_LIMIT:
    default: 600
    description: "The global Celery task hard timeout (in seconds)."
    details: "Any background task that exceeds this duration will be forcibly killed with a `SIGKILL` signal."
    environment_variable: "NAUTOBOT_CELERY_TASK_TIME_LIMIT"
    see_also:
      "`CELERY_TASK_SOFT_TIME_LIMIT`": "#celery_task_soft_time_limit"
    type: "integer"
  CELERY_WORKER_PROMETHEUS_PORTS:
    default: []
    description: "Ports for Prometheus metric HTTP server running on the celery worker(s)."
    details: >-
      Normally this should be set to a single port, unless you have multiple workers running on a single machine,
      i.e.  sharing the same available ports. In that case you need to specify a range of ports greater than or
      equal to the highest amount of workers you are running on a single machine (comma-separated, like
      "8080,8081,8082"). You can then use the `target_limit` parameter to the Prometheus `scrape_config`
      to ensure you are not getting duplicate metrics in that case. Set this to an empty list to disable it.
    environment_variable: "NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS"
    items:
      type: "integer"
    type: "array"
    version_added: "1.5.10"
  CELERY_WORKER_REDIRECT_STDOUTS:
    default: true
    description: "If enabled stdout and stderr of running jobs will be redirected to the task logger."
    environment_variable: "NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS"
    type: "boolean"
    version_added: "2.0.0"
  CELERY_WORKER_REDIRECT_STDOUTS_LEVEL:
    default: "WARNING"
    description: "The log level of log messages generated by redirected job stdout and stderr."
    enum:
    - "DEBUG"
    - "INFO"
    - "WARNING"
    - "ERROR"
    - "CRITICAL"
    environment_variable: "NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL"
    type: "string"
    version_added: "2.0.0"
  CHANGELOG_RETENTION:
    default: 90
    description: >-
      The number of days to retain logged changes (object creations, updates, and deletions).
      Set this to `0` to retain changes in the database indefinitely.
    details: |-
      !!! warning
          If enabling indefinite changelog retention, it is recommended to periodically delete old entries.
          Otherwise, the database may eventually exceed capacity.
    environment_variable: "NAUTOBOT_CHANGELOG_RETENTION"
    is_constance_config: true
    type: "integer"
  CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:
    default: false
    description: >-
      If `True`, it will be possible to apply Config Context objects to Devices and Virtual Machines
      via Dynamic Group membership. When set to `False` this behavior will not be available.
    details: |-
      !!! warning
          With a large number of dynamic groups, enabling this could invoke a performance penalty when
          processing Config Contexts.
    environment_variable: "NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED"
    type: "boolean"
  CONTENT_TYPE_CACHE_TIMEOUT:
    default: 0
    description: >-
      The number of seconds to cache the content type accessible via a object's class property
      `Object._content_type_cached`. This can save frequent calls to `ContentType.objects.get_for_model(model)`.
      Set this to `0` to disable caching.
    environment_variable: "NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT"
    type: "integer"
    version_added: "1.6.0"
  CORS_ALLOW_ALL_ORIGINS:
    default: false
    description: "If `True`, all origins will be allowed. Other settings restricting allowed origins will be ignored."
    details: >-
      Setting this to `True` can be dangerous, as it allows any website to make cross-origin requests to yours.
      Generally you'll want to restrict the list of allowed origins with
      [`CORS_ALLOWED_ORIGINS`](#cors_allowed_origins) or
      [`CORS_ALLOWED_ORIGIN_REGEXES`](#cors_allowed_origin_regexes).
    environment_variable: "NAUTOBOT_CORS_ALLOW_ALL_ORIGINS"
    type: "boolean"
  CORS_ALLOWED_ORIGIN_REGEXES:
    default: []
    description: >-
      A list of strings representing regexes that match Origins that are authorized to make cross-site HTTP requests.
    details: |-
      Useful when [`CORS_ALLOWED_ORIGINS`](#cors_allowed_origins) is impractical, such as when you have a
      large number of subdomains.

      Example:

      ```python
      CORS_ALLOWED_ORIGIN_REGEXES = [r"^https://\w+\.example\.com$"]
      ```
    items:
      "$ref": "#/definitions/regex"
    type: "array"
  CORS_ALLOWED_ORIGINS:
    default: []
    description: "A list of origins that are authorized to make cross-site HTTP requests."
    details: |-
      An Origin is defined by [the CORS RFC Section 3.2](https://tools.ietf.org/html/rfc6454#section-3.2) as a
      URI `scheme + hostname + port`, or one of the special values `'null'` or `'file://'`.
      Default ports (HTTPS = 443, HTTP = 80) are optional here.

      The special value `null` is sent by the browser in
      ["privacy-sensitive contexts"](https://tools.ietf.org/html/rfc6454#section-6), such as when the client
      is running from a `file://` domain.
      The special value `file://` is sent accidentally by some versions of Chrome on Android as per this bug.

      Example:

      ```python
      CORS_ALLOWED_ORIGINS = [
          'https://example.com',
          'https://sub.example.com',
          'http://localhost:8080',
          'http://127.0.0.1:9000'
      ]
      ```
    items:
      format: "uri"
      type: "string"
    type: "array"
  CSRF_TRUSTED_ORIGINS:
    default: []
    description: >-
      A list of hosts (fully-qualified domain names (FQDNs) or subdomains) that are considered trusted origins
      for cross-site secure requests such as HTTPS POST.
    items:
      type: "string"
    see_also:
      "Django documentation for `CSRF_TRUSTED_ORIGINS`": "https://docs.djangoproject.com/en/stable/ref/settings/#csrf-trusted-origins"
      "Django documentation for CSRF protection": "https://docs.djangoproject.com/en/stable/ref/csrf/#how-it-works"
    type: "array"
  DATABASE_ROUTERS:
    default: []
    description: >-
      Custom database router to generate the before & after queries for generating diffs.
      Used for Nautobot Version Control App.
    items:
      type: "string"
    type: "array"
  DATABASES:
    additionalProperties: true
    default:
      default:
        CONN_MAX_AGE: 300
        ENGINE: "django.db.backends.postgresql"
        HOST: "localhost"
        NAME: "nautobot"
        PASSWORD: ""
        PORT: ""
        USER: ""
    description: |-
      Nautobot requires access to a supported database service to store data.
      This service can run locally on the Nautobot server or on a remote system.

      Nautobot supports either MySQL or PostgreSQL as a database backend. You must make sure that the `ENGINE`
      setting matches your selected database backend or **you will be unable to connect to the database**.
    details: |-
      !!! note
          Nautobot supports all database options supported by the underlying Django framework.
          For a complete list of available parameters, please see the
          [official Django documentation on `DATABASES`](https://docs.djangoproject.com/en/stable/ref/settings/#databases).

      !!! warning
          By default, MySQL is case-insensitive in its handling of text strings. This is different from
          PostgreSQL which is case-sensitive by default. We strongly recommend that you configure MySQL to be
          case-sensitive for use with Nautobot, either when you enable the MySQL server, or when you create the
          Nautobot database in MySQL. If you follow the provided installation instructions for CentOS or Ubuntu,
          the recommended steps there will include the appropriate database configuration.

      !!! tip
          When using MySQL as a database backend, and you want to enable support for Unicode characters like
          the beloved poop emoji, you'll need to update your settings.

          If you try to use emojis without this setting, you will encounter a server error along the lines of
          `Incorrect string value`, because you are running afoul of the legacy implementation of Unicode
          (aka `utf8`) encoding in MySQL. The `utf8` encoding in MySQL is limited to 3-bytes per character.
          Newer Unicode emoji require 4-bytes.

          To properly support using such characters, you will need to create an entry in
          `DATABASES` -> `default` -> `OPTIONS` with the value `{"charset": "utf8mb4"}` in your `nautobot_config.py`
          and restart all Nautobot services. This will tell MySQL to always use `utf8mb4` character set
          for database client connections.

          As of Nautobot 1.1.5 and later, if you have generated a new `nautobot_config.py` using
          `nautobot-server init`, this line is already present in your config and no action is required.
    is_required_setting: true
    properties:
      default:
        additionalProperties: true
        properties:
          CONN_MAX_AGE:
            default: 300
            description: >-
              Lifetime of a
              [persistent database connection](https://docs.djangoproject.com/en/stable/ref/databases/#persistent-connections)
              in seconds
            details: "https://docs.djangoproject.com/en/stable/ref/databases/#persistent-connections"
            environment_variable: "NAUTOBOT_DB_TIMEOUT"
            type: "integer"
          ENGINE:
            default: "django.db.backends.postgresql"
            description: >-
              The database backend to use. Use the `django_prometheus` backends when `METRICS_ENABLED` is `True`.
            enum:
            - "django.db.backends.postgresql"
            - "django.db.backends.mysql"
            - "django_prometheus.db.backends.postgresql"
            - "django_prometheus.db.backends.mysql"
            environment_variable: "NAUTOBOT_DB_ENGINE"
            type: "string"
          HOST:
            default: "localhost"
            description: "Name or IP addrress of the database server (use `localhost` if running locally)"
            environment_variable: "NAUTOBOT_DB_HOST"
            type: "string"
          NAME:
            default: "nautobot"
            description: "Database name"
            environment_variable: "NAUTOBOT_DB_NAME"
            type: "string"
          PASSWORD:
            default: ""
            description: "Database password"
            environment_variable: "NAUTOBOT_DB_PASSWORD"
            type: "string"
          PORT:
            default: ""
            description: >-
              The port to use when connecting to the database.
              An empty string means the default port for your selected backend (PostgreSQL: `5432`, MySQL: `3306`).
            environment_variable: "NAUTOBOT_DB_PORT"
            type: "string"
          USER:
            default: ""
            description: "Database username"
            environment_variable: "NAUTOBOT_DB_USER"
            type: "string"
        type: "object"
    see_also:
      "Django documentation for `DATABASES`": "https://docs.djangoproject.com/en/stable/ref/settings/#databases"
    type: "object"
  DATE_FORMAT:
    default: "N j, Y"
    description: "Custom format for dates. The default results in strings like \"January 22, 2024\"."
    environment_variable: "NAUTOBOT_DATE_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  DATETIME_FORMAT:
    default: "N j, Y g:i a"
    description: "Custom format for date-times. The default results in strings like \"January 22, 2024 1:22 p.m.\"."
    environment_variable: "NAUTOBOT_DATETIME_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  DEBUG:
    default: false
    description: >-
      This setting enables debugging. Debugging should be enabled only during development or troubleshooting.
    details: |-
      Note that only clients which access Nautobot from a recognized [internal IP address](#internal_ips)
      will see debugging tools in the user interface.

      !!! warning
          Never enable debugging on a production system, as it can expose sensitive data to unauthenticated users
          and imposes a substantial performance penalty.
    environment_variable: "NAUTOBOT_DEBUG"
    see_also:
      "Django documentation for `DEBUG`": "https://docs.djangoproject.com/en/stable/ref/settings/#debug"
    type: "boolean"
  DEPLOYMENT_ID:
    default: ""
    description: >-
      Setting to uniquely but anonymously identify Nautobot deployments when sending installation metrics.
    details: |-
      Defaults to a random UUID generated at installation time.

      This setting is used to uniquely but anonymously identify Nautobot deployments when sending
      installation metrics. This setting is not generally intended to be user-serviceable.
    environment_variable: "NAUTOBOT_DEPLOYMENT_ID"
    is_constance_config: true
    see_also:
      "`nautobot-server send_installation_metrics`": "../tools/nautobot-server.md#send_installation_metrics"
    type: "string"
    version_added: "1.6.0"
  DEVICE_NAME_AS_NATURAL_KEY:
    default: false
    description: >-
      `Device` names are not guaranteed globally-unique by Nautobot but in practice they often are.
      Set this to `True` to use the device `name` alone as the natural key for `Device` objects.
      Set this to `False` to use the sequence `(name, tenant, location)` as the natural key instead.
    environment_variable: "NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"
    is_constance_config: true
    type: "boolean"
    version_added: "2.0.0"
  DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT:
    default: 0
    description: >-
      The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.
    details: >-
      With large datasets (those in scope of a Dynamic Group and number of Dynamic Groups themselves),
      users will encounter a performance penalty using or accessing the membership lists.
      This setting allows users to accept a cached list for common use cases (particularly in the UI)
      that expires after the configured time."
    environment_variable: "NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"
    is_constance_config: true
    type: "integer"
    version_added: "1.6.0"
  EXEMPT_VIEW_PERMISSIONS:
    default: []
    description: "A list of Nautobot models to exempt from the enforcement of view permissions."
    details: |-
      Models listed here will be viewable by all users, both authenticated and anonymous.
      List models in the form `<app>.<model>`.

      Example:

      ```python
      EXEMPT_VIEW_PERMISSIONS = [
          'dcim.location',
          'dcim.location_type',
          'ipam.prefix',
      ]
      ```

      To exempt _all_ models from view permission enforcement, set the following.
      (Note that `EXEMPT_VIEW_PERMISSIONS` must be an iterable.)

      ```python
      EXEMPT_VIEW_PERMISSIONS = ['*']
      ```

      !!! note
          Using a wildcard will not affect certain potentially sensitive models, such as user permissions.
          If there is a need to exempt these models, they must be specified individually.
    items:
      type: "string"
    type: "array"
  EXTERNAL_AUTH_DEFAULT_GROUPS:
    default: []
    description: "The list of group names to assign a new user account when created using 3rd-party authentication."
    items:
      type: "string"
    type: "array"
  EXTERNAL_AUTH_DEFAULT_PERMISSIONS:
    additionalProperties: true
    default: {}
    description: "A mapping of permissions to assign a new user account when created using SSO authentication."
    details: |-
      Each key in the dictionary will be the permission name specified as `<app_label>.<action>_<model>`,
      and the value should be set to the permission [constraints](../guides/permissions.md#constraints),
      or `None` to allow all objects.

      Example:

      | Permission | Description |
      |---|---|
      | `{'dcim.view_device': {}}` or `{'dcim.view_device': None}` | Users can view all devices |
      | `{'dcim.add_device': {}}` | Users can add devices, see note below |
      | `{'dcim.view_device': {'location__name__in': ['HQ'], 'location__location_type__name__in': ['Building']}}` | Users can view all devices in the HQ Building |

      !!! warning
          Permissions can be complicated! Be careful when restricting permissions to also add any required
          prerequisite permissions.

          For example, when adding Devices the Role, Device Type, Location, and Status fields are all required fields
          in order for the UI to function properly. Users will also need view permissions for those models or the
          corresponding field selections in the UI will be unavailable and potentially prevent objects from being
          able to be created or edited.

      The following example gives a user a reasonable amount of access to add devices to a single location
      (Building HQ in this case):

      ```python
      {
          'dcim.add_device': {'location__name__in':  ['HQ'], 'location__location_type__name__in': ['Building']},
          'dcim.view_device': {'location__name__in':  ['HQ'], 'location__location_type__name__in': ['Building']},
          'dcim.view_devicetype': None,
          'extras.view_role': None,
          'extras.view_status': None,
          'dcim.view_location': {'name__in':  ['HQ'], 'location_type__name__in': ['Building']},
          'dcim.view_manufacturer': None,
          'dcim.view_region': None,
          'dcim.view_rack': None,
          'dcim.view_rackgroup': None,
          'dcim.view_platform': None,
          'virtualization.view_cluster': None,
          'virtualization.view_clustergroup': None,
          'tenancy.view_tenant': None,
          'tenancy.view_tenantgroup': None,
      }
      ```
    see_also:
      "Guide to object permissions": "../guides/permissions.md"
    type: "object"
  FORCE_SCRIPT_NAME:
    default: null
    description: >-
      If not None, this will be used as the value of the SCRIPT_NAME environment variable in any HTTP request.
    details: |-
      This setting can be used to override the server-provided value of `SCRIPT_NAME`, which is most commonly used
      for hosting Nautobot in a subdirectory (e.g. _example.com/nautobot/_).

      !!! important
          To host Nautobot under a subdirectory you must set this value to match the same prefix configured on
          your HTTP server. For example, if you configure NGINX to serve Nautobot at `/nautobot/`, you must
          set `FORCE_SCRIPT_NAME = "/nautobot/"`.
    see_also:
      "Django documentation for `FORCE_SCRIPT_NAME`": "https://docs.djangoproject.com/en/stable/ref/settings/#force-script-name"
    type: "string"
  GIT_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/git"
    description: >-
      The file path to a directory where cloned [Git repositories](../../platform-functionality/gitrepository.md)
      will be located.
    environment_variable: "NAUTOBOT_GIT_ROOT"
  GRAPHQL_COMPUTED_FIELD_PREFIX:
    default: "cpf"
    description: "The prefix used for all computed fields in GraphQL. e.g. `my_field` => `cpf_my_field`"
    type: "string"
  GRAPHQL_CUSTOM_FIELD_PREFIX:
    default: "cf"
    description: "The prefix used for all custom fields in GraphQL. e.g. `my_field` => `cf_my_field`"
    type: "string"
  GRAPHQL_RELATIONSHIP_PREFIX:
    default: "rel"
    description: >-
      The prefix used for all relationship associations in GraphQL. e.g. `my_relationship` => `rel_my_relationship`.
    type: "string"
  HTTP_PROXIES:
    default: null
    description: >-
      A dictionary of HTTP proxies to use for outbound requests originating from Nautobot
      (such as when sending webhook requests).
    details: |-
      Proxies should be specified by schema (HTTP and HTTPS) as per the
      [Python `requests` library documentation](https://2.python-requests.org/en/master/user/advanced/).

      Example:

      ```python
      HTTP_PROXIES = {
          'http': 'http://10.10.1.10:3128',
          'https': 'http://10.10.1.10:1080',
      }
      ```

      !!! note
          When using Git repositories within Nautobot the Python library `GitPython` needs extra proxy configuration:

          ```bash
              git config --global http.proxy http://192.0.2.1:3128
              git config --global https.proxy http://192.0.2.1:3128
          ```
    properties:
      http:
        type: "string"
      https:
        type: "string"
    type: "object"
  INSTALLATION_METRICS_ENABLED:
    default: true
    description: "Controls sending of anonymized installation metrics to the Nautobot maintainers."
    details: >-
      Default value is user-specified when running `nautobot-server init` for a new deployment.
      Defaults to `True` when upgrading pre-1.6.0 deployments without configuring a value.

      When set to `True`, Nautobot will send anonymized installation metrics to the Nautobot maintainers
      when running the [`post_upgrade`](../tools/nautobot-server.md#post_upgrade) or
      [`send_installation_metrics`](../tools/nautobot-server.md#send_installation_metrics) management commands.
    environment_variable: "NAUTOBOT_INSTALLATION_METRICS_ENABLED"
    see_also:
      "`nautobot-server send_installation_metrics`": "../tools/nautobot-server.md#send_installation_metrics"
    type: "boolean"
    version_added: "1.6.0"
  INTERNAL_IPS:
    default:
    - "127.0.0.1"
    - "::1"
    description: >-
      A list of IP addresses recognized as internal to the system, used to control the display of debugging output.
    details: >-
      For example, the [Django debugging toolbar](https://django-debug-toolbar.readthedocs.io/), if installed,
      will be viewable only when a client is accessing Nautobot from one of the listed IP addresses
      (and [`DEBUG`](#debug) is true).
    items:
      type: "string"
    type: "array"
  JOB_CREATE_FILE_MAX_SIZE:
    default: 10485760
    description: >-
      The maximum file size (in bytes) that a running Job will be allowed to create in a single call
      to `Job.create_file()`.
    environment_variable: "NAUTOBOT_JOB_CREATE_FILE_MAX_SIZE"
    is_constance_config: true
    see_also:
      "`JOB_FILE_IO_STORAGE`": "#job_file_io_storage"
    type: "integer"
    version_added: "2.1.0"
  JOB_FILE_IO_STORAGE:
    default: "db_file_storage.storage.DatabaseFileStorage"
    description: >-
      The backend storage engine for handling files provided as input to Jobs and files generated as output by Jobs.
    details: |-
      !!! warning
          For backwards compatibility with storage of Job inputs in prior versions of Nautobot, this
          currently defaults to using `DatabaseFileStorage` to store such files directly in Nautobot's database;
          however this is not typically the best option (see below) and may change in a future major release.

      If your Nautobot server instance(s) and your Celery worker instance(s) share a common
      [`MEDIA_ROOT`](#media_root) filesystem (as would typically be the case in a single-server installation of
      Nautobot) then we recommend changing this to `"django.core.files.storage.FileSystemStorage"` to store
      Job files on the filesystem (which will place them into a `files/` subdirectory under
      [`MEDIA_ROOT`](#media_root)) instead of in the database.

      If your Nautobot server instance(s) and Celery worker instance(s) do _not_ share a common filesystem,
      we recommend using one of the [`django-storages`](https://django-storages.readthedocs.io/en/stable/) options
      such as S3 to provide a storage backend that can be accessed by the server(s) and worker(s) alike.

      !!! tip
          For an example of using `django-storages` with AWS S3 buckets, visit the
          [django-storages with S3](../guides/s3-django-storage.md) user-guide.

      If you have neither a common `MEDIA_ROOT` filesystem nor an appropriate remote storage option, then
      it's permissible to leave this at its default, but know that storing files in the database is provided here
      as a "least-worst" option only.

      !!! caution
          It's typically safe to change this setting when initially updating to Nautobot 2.1.0 or later, as
          there should be no pre-existing Job output files, although any existing scheduled Jobs that have
          file _inputs_ may need to be deleted and recreated after doing so. However, once you've run any Jobs
          that output to a file, changing storage backends will of course break any existing links to
          Job output files in the previous storage backend.
          Migrating Job stored files from one backend to another is out of scope for this document.
    environment_variable: "NAUTOBOT_JOB_FILE_IO_STORAGE"
    see_also:
      "`STORAGE_BACKEND`": "#storage_backend"
      "`JOB_CREATE_FILE_MAX_SIZE`": "#job_create_file_max_size"
    type: "string"
    version_added: "2.1.0"
  JOBS_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/jobs"
    description: "The file path to a directory where Jobs can be discovered."
    details: |-
      +/- 2.0.0
          This directory no longer requires an `__init__.py` file.
    environment_variable: "NAUTOBOT_JOBS_ROOT"
  LOCATION_NAME_AS_NATURAL_KEY:
    default: false
    description: >-
      `Location` names are not guaranteed globally-unique by Nautobot but in practice they often are.
      Set this to `True` to use the location `name` alone as the natural key for `Location` objects.
      Set this to `False` to use the sequence `(name, parent__name, parent__parent__name, ...)` as
      the natural key instead.
    environment_variable: "NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"
    is_constance_config: true
    type: "boolean"
    version_added: "2.0.0"
  LOG_DEPRECATION_WARNINGS:
    default: false
    description: >-
      Set the environment variable `NAUTOBOT_LOG_DEPRECATION_WARNINGS` to change this setting.
      This can be set to `True` to allow deprecation warnings raised by Nautobot to (additionally)
      be logged as `WARNING` level log messages.
    details: |-
      !!! warning
          This setting cannot be effectively configured in `nautobot_config.py` due to the order of code evaluation
          at startup time. To enable this setting, always use the `NAUTOBOT_LOG_DEPRECATION_WARNINGS`
          environment variable.

      Deprecation warnings are normally silent in Python, but can be enabled globally by
      [various means](https://docs.python.org/3/library/warnings.html) such as setting the `PYTHONWARNINGS`
      environment variable. However, doing so can be rather noisy, as it will also include warnings from within
      Django about various code in various package dependencies of Nautobot's, etc.

      This configuration setting allows a more targeted enablement of only warnings from within Nautobot itself,
      which can be useful when vetting various Nautobot Apps for future-proofness against upcoming changes to Nautobot.
    environment_variable: "NAUTOBOT_LOG_DEPRECATION_WARNINGS"
    type: "boolean"
    version_added: "1.5.2"
  LOGGING:
    additionalProperties: true
    default:
      version: 1
      disable_existing_loggers: false
      formatters:
        normal:
          datefmt: "%H:%M:%S"
          format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s"
        verbose:
          datefmt: "%H:%M:%S"
          format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s"
      handlers:
        normal_console:
          class: "logging.StreamHandler"
          formatter: "normal"
          level: "INFO"
        verbose_console:
          class: "logging.StreamHandler"
          formatter: "verbose"
          level: "DEBUG"
      loggers:
        django:
          handlers:
          - "normal_console"
          level: "INFO"
        nautobot:
          handlers:
          - "normal_console"
          level: "INFO"
    default_literal: |-
      ```python
      {
          'version': 1,
          'disable_existing_loggers': False,
          'formatters': {
              'normal': {
                  'datefmt': '%H:%M:%S',
                  'format': '%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s',
              },
              'verbose': {
                  'datefmt': '%H:%M:%S',
                  'format': '%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s '
                            '%(funcName)30s() :\n  %(message)s',
              },
          },
          'handlers': {
              'normal_console': {
                  'class': 'logging.StreamHandler',
                  'formatter': 'normal',
                  'level': 'INFO',
              },
              'verbose_console': {
                  'class': 'logging.StreamHandler',
                  'formatter': 'verbose',
                  'level': 'DEBUG',
              },
          },
          'loggers': {
              'django': {'handlers': ['normal_console'], 'level': 'INFO'},
              'nautobot': {'handlers': ['normal_console'], 'level': 'INFO'},
          },
      }
      ```
    description: "A dictionary containing the configuration settings for logging in Nautobot."
    details: |-
      The default translates to:

      * All messages from Django and from Nautobot of INFO severity or higher will be logged to the console.
      * If [`DEBUG`](#debug) is True, Nautobot DEBUG messages will also be logged, and all Nautobot messages
        will be logged with a more verbose format including the filename and function name that originated
        each log message.

      The default log formatters split each log message across two lines of output for greater readability,
      which is useful for local observation and troubleshooting, but you may find it impractical to use in
      production environments that expect one line per log message. Fortunately, the Django framework allows for
      extensive customization of logging format and destination.

      Below is an example configuration extension which will additionally write all INFO and higher messages to
      a local file:

      ```python
      LOGGING["handlers"]["file"] = {
          "level": "INFO",
          "class": "logging.FileHandler",
          "filename": "/var/log/nautobot.log",
          "formatter": "normal",
      }
      LOGGING["loggers"]["django"]["handlers"] += ["file"]
      LOGGING["loggers"]["nautobot"]["handlers"] += ["file"]
      ```

      #### Available Loggers

      * `django.*` - Generic Django operations (HTTP requests/responses, etc.)
      * `nautobot.<app>.<module>` - Generic form for model- or module-specific log messages
      * `nautobot.auth.*` - Authentication events
      * `nautobot.extras.jobs.*` - Job execution (`* = JobClassName`)
      * `nautobot.core.graphql.*` - [GraphQL](../../platform-functionality/graphql.md) initialization and operation.
      * `nautobot.extras.plugins.*` - App loading and activity
      * `nautobot.core.views.generic.*` - Generic views which handle business logic for the web UI
    properties:
      additionalProperties: true
      disable_existing_loggers:
        default: false
        type: "boolean"
      formatters:
        additionalProperties: true
        default:
          normal:
            datefmt: "%H:%M:%S"
            format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s"
          verbose:
            datefmt: "%H:%M:%S"
            format: "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s"
        type: "object"
      handlers:
        additionalProperties: true
        default:
          normal_console:
            class: "logging.StreamHandler"
            formatter: "normal"
            level: "INFO"
          verbose_console:
            class: "logging.StreamHandler"
            formatter: "verbose"
            level: "DEBUG"
        type: "object"
      loggers:
        additionalProperties: true
        default:
          django:
            handlers:
            - "normal_console"
            level: "INFO"
          nautobot:
            handlers:
            - "normal_console"
            level: "INFO"
        type: "object"
      version:
        default: 1
        type: "integer"
    see_also:
      "Additional Nautobot logging examples": "https://github.com/nautobot/nautobot/tree/develop/examples/logging"
      "Django documentation for logging": "https://docs.djangoproject.com/en/stable/topics/logging/"
    type: "object"
  MAINTENANCE_MODE:
    default: false
    description: "Setting this to true causes Nautobot to go into maintenance mode."
    details: |-
      Setting this to `True` will display a "maintenance mode" banner at the top of every page.
      Additionally, Nautobot will no longer update a user's "last active" time upon login.
      This is to allow new logins when the database is in a read-only state.
      Recording of login times will resume when maintenance mode is disabled.

      !!! note
          The default [`SESSION_ENGINE`](#session_engine) configuration will store sessions in the database,
          but this obviously will not work when `MAINTENANCE_MODE` is `True` and the database is in
          a read-only state for maintenance.  Consider setting `SESSION_ENGINE` to
          `django.contrib.sessions.backends.cache` when enabling `MAINTENANCE_MODE`.

      !!! note
          The Docker container normally attempts to run migrations on startup; however, if the database is
          in a read-only state the Docker container will fail to start. Setting the environment variable
          [`NAUTOBOT_DOCKER_SKIP_INIT`](../installation/docker.md#nautobot_docker_skip_init) to `true`
          will prevent the migrations from occurring.

      !!! note
          If you are using `django-auth-ldap` for LDAP authentication, `django-auth-ldap` by default will
          try to update a user object on every log in.  If the database is in a read-only state `django-auth-ldap`
          will fail. You will also need to set `AUTH_LDAP_ALWAYS_UPDATE_USER=False` and `AUTH_LDAP_NO_NEW_USERS=True`
          to avoid this.
    environment_variable: "NAUTOBOT_MAINTENANCE_MODE"
    see_also:
      "`django-auth-ldap` documentation": "https://django-auth-ldap.readthedocs.io/en/stable/reference.html"
    type: "boolean"
  MAX_PAGE_SIZE:
    default: 1000
    description: >-
      A web user or API consumer can request an arbitrary number of objects by appending the `limit` parameter
      to the URL (e.g. `?limit=1000`). This parameter defines the maximum acceptable limit.
      Setting this to `0` or `None` will allow a client to retrieve _all_ matching objects at once with no limit
      by specifying `?limit=0`.
    environment_variable: "NAUTOBOT_MAX_PAGE_SIZE"
    is_constance_config: true
    type: "integer"
  MEDIA_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/media"
    description: "The file path to the location where media files (such as image attachments) are stored."
    see_also:
      "Django documentation for `MEDIA_ROOT`": "https://docs.djangoproject.com/en/stable/ref/settings/#media-root"
  METRICS_AUTHENTICATED:
    default: false
    description: "Toggle requiring authentication to view `/metrics`."
    environment_variable: "NAUTOBOT_METRICS_AUTHENTICATED"
    see_also:
      "Guide to Nautobot Prometheus metrics": "../guides/prometheus-metrics.md"
    type: "boolean"
    version_added: "2.1.5"
  METRICS_DISABLED_APPS:
    default: []
    description: >-
      A list of app names for which Prometheus metrics should be disabled.
      (If provided as an environment variable, it should be a comma-separated string, for example
      `NAUTOBOT_METRICS_DISABLED_APPS="nautobot_ssot, nautobot_device_lifecycle_mgmt"`.)
    environment_variable: "NAUTOBOT_METRICS_DISABLED_APPS"
    items:
      type: "string"
    see_also:
      "Guide to Nautobot Prometheus metrics": "../guides/prometheus-metrics.md"
    type: "array"
    version_added: "2.2.1"
  METRICS_ENABLED:
    default: false
    description: "Toggle the availability of Prometheus-compatible metrics at `/metrics`."
    environment_variable: "NAUTOBOT_METRICS_ENABLED"
    see_also:
      "Guide to Nautobot Prometheus metrics": "../guides/prometheus-metrics.md"
    type: "boolean"
  NAPALM_ARGS:
    additionalProperties: true
    default: {}
    description: "A dictionary of optional arguments to pass to NAPALM when instantiating a network driver."
    details: |-
      Example:

      ```python
      NAPALM_ARGS = {
          'api_key': '472071a93b60a1bd1fafb401d9f8ef41',
          'port': 2222,
      }
      ```

      Some platforms (e.g. Cisco IOS) require an enable password to be passed in addition to the normal password.
      If desired, you can use the configured `NAPALM_PASSWORD` as the value for this argument:

      ```python
      NAPALM_USERNAME = 'username'
      NAPALM_PASSWORD = 'MySecretPassword'
      NAPALM_ARGS = {
          'secret': NAPALM_PASSWORD,          # ios and nxos_ssh
          'enable_password': NAPALM_PASSWORD, # eos
          # Include any additional args here
      }
      ```

      !!! note
          If a given device has an appropriately populated
          [secrets group](../../platform-functionality/secret.md#secrets-groups) assigned to it,
          a [secret](../../platform-functionality/secret.md) defined in that group can override the
          `NAPALM_ARGS['secret']` or `NAPALM_ARGS['enable_password']` default value defined here.
    properties:
      secret:
        type: "string"
      enable_password:
        type: "string"
    see_also:
      "NAPALM Optional Arguments": "https://napalm.readthedocs.io/en/latest/support/#optional-arguments"
    type: "object"
  NAPALM_PASSWORD:
    default: ""
    description: >-
      Nautobot will use this optional credential with `NAPALM_USERNAME` when authenticating to remote devices
      via the NAPALM library, if installed.
    details: |-
      !!! note
          If SSH public key authentication has been set up on the remote device(s) for the system account
          under which Nautobot runs, this parameter is not needed.

      !!! note
          If a given device has an appropriately populated
          [secrets group](../../platform-functionality/secret.md#secretsgroup) assigned to it,
          the [secrets](../../platform-functionality/secret.md) defined in that group will take precedence
          over these default values.
    environment_variable: "NAUTOBOT_NAPALM_PASSWORD"
    type: "string"
  NAPALM_TIMEOUT:
    default: 30
    description: "The amount of time (in seconds) to wait for NAPALM to connect to a device."
    environment_variable: "NAUTOBOT_NAPALM_TIMEOUT"
    type: "integer"
  NAPALM_USERNAME:
    default: ""
    description: >-
      Nautobot will use this optional credential with `NAPALM_PASSWORD` when authenticating to remote devices
      via the NAPALM library, if installed.
    details: |-
      !!! note
          If SSH public key authentication has been set up on the remote device(s) for the system account
          under which Nautobot runs, this parameter is not needed.

      !!! note
          If a given device has an appropriately populated
          [secrets group](../../platform-functionality/secret.md#secretsgroup) assigned to it,
          the [secrets](../../platform-functionality/secret.md) defined in that group will take precedence
          over these default values.
    environment_variable: "NAUTOBOT_NAPALM_USERNAME"
    type: "string"
  NAUTOBOT_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/"
    description: >-
      The filesystem path to use to store Nautobot files (Jobs, uploaded images, Git repositories, etc.).
    details: |-
      This setting is used internally in the core settings to provide default locations for
      [features that require file storage](index.md#file-storage), and the
      [default location of the `nautobot_config.py`](index.md#specifying-your-configuration).

      !!! warning
          Do not override `NAUTOBOT_ROOT` in your `nautobot_config.py`. It will not work as expected.
          If you need to customize this setting, please always set the `NAUTOBOT_ROOT` environment variable.
    environment_variable: "NAUTOBOT_ROOT"
  NETWORK_DRIVERS:
    additionalProperties: true
    default: {}
    description: >-
      An optional dictionary to extend or override the default `Platform.network_driver` translations provided
      by [netutils](https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/).
    details: |-
      For example, to add support for a custom `Platform.network_driver` value of `"my_network_driver"`
      for Netmiko and PyATS drivers:

      ```python
      NETWORK_DRIVERS = {
          'netmiko': {'my_network_driver': 'cisco_ios'},
          'pyats': {'my_network_driver': 'iosxe'},
      }
      ```

      The default top-level keys are `ansible`, `hier_config`, `napalm`, `netmiko`, `netutils_parser`,
      `ntc_templates`, `pyats`, `pyntc`, and `scrapli`, but you can also add additional keys if you have
      an alternative network driver that you want your Nautobot instance to include.
    is_constance_config: true
    type: "object"
    version_added: "1.6.0"
  PAGINATE_COUNT:
    default: 50
    description: >-
      The default maximum number of objects to display per page within each list of objects.
      Applies to both the UI and the REST API.
    environment_variable: "NAUTOBOT_PAGINATE_COUNT"
    is_constance_config: true
    type: "integer"
  PER_PAGE_DEFAULTS:
    default:
    - 25
    - 50
    - 100
    - 250
    - 500
    - 1000
    description: "The options displayed in the web interface dropdown to limit the number of objects per page."
    details: >-
      For proper user experience, this list should include the [`PAGINATE_COUNT`](#paginate_count) and
      [`MAX_PAGE_SIZE`](#max_page_size) values as options.
    environment_variable: "NAUTOBOT_PER_PAGE_DEFAULTS"
    is_constance_config: true
    items:
      type: "integer"
    type: "array"
  PLUGINS:
    default: []
    description: >-
      A list of installed [Nautobot Apps](../../../apps/index.md) to enable.
      Apps will not take effect unless they are listed here.
    details: |-
      !!! warning
          Apps extend Nautobot by allowing external code to run with the same access and privileges as
          Nautobot itself. Only install Apps from trusted sources. The Nautobot maintainers make
          absolutely no guarantees about the integrity or security of your installation with Apps enabled.
    items:
      type: "string"
    type: "array"
  PLUGINS_CONFIG:
    default: {}
    description: "This parameter holds configuration settings for individual Nautobot Apps."
    details: |-
      It is defined as a dictionary, with each key using the name of an installed App.
      The specific parameters supported are unique to each App; reference the App's documentation to determine
      the supported parameters. An example configuration is shown below:

      ```python
      PLUGINS_CONFIG = {
          'app1': {
              'foo': 123,
              'bar': True
          },
          'app2': {
              'foo': 456,
          },
      }
      ```

      Note that an App must be listed in `PLUGINS` for its configuration to take effect.
    type: "object"
  PREFER_IPV4:
    default: false
    description: >-
      When determining the primary IP address for a device, IPv6 is preferred over IPv4 by default.
      Set this to True to prefer IPv4 instead.
    environment_variable: "NAUTOBOT_PREFER_IPV4"
    is_constance_config: true
    type: "boolean"
  RACK_ELEVATION_DEFAULT_UNIT_HEIGHT:
    default: 22
    description: >-
      Default height (in pixels) of a unit within a rendered rack elevation.
      For best results, this should be approximately one tenth of `RACK_ELEVATION_DEFAULT_UNIT_WIDTH.
    environment_variable: "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"
    is_constance_config: true
    type: "integer"
  RACK_ELEVATION_DEFAULT_UNIT_WIDTH:
    default: 230
    description: "Default width (in pixels) of a unit within a rendered rack elevation."
    environment_variable: "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"
    is_constance_config: true
    type: "integer"
  RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT:
    default: false
    description: "Enables two-digit format for the rack unit numbering in a rack elevation diagram."
    environment_variable: "NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"
    is_constance_config: true
    type: "boolean"
    version_added: "2.2.1"
  REDIS_LOCK_TIMEOUT:
    default: 600
    description: >-
      Maximum duration of a Redis lock created when calling `/api/ipam/prefixes/{id}/available-prefixes/` or
      `/api/ipam/prefixes/{id}/available-ips/` to avoid inadvertently allocating the same prefix or IP to
      multiple simultaneous callers.
    details: >-
      Default is set to 600 seconds (10 minutes) to be longer than any theoretical API call time.
      This is to prevent a deadlock scenario where the server did not gracefully exit the `with` block
      when acquiring the Redis lock.
    environment_variable: "NAUTOBOT_REDIS_LOCK_TIMEOUT"
    type: "integer"
  RELEASE_CHECK_TIMEOUT:
    default: 86400
    description: >-
      The number of seconds to retain the latest version that is fetched from the GitHub API before
      automatically invalidating it and fetching it from the API again.
    details: |-
      !!! warning
          This must be set to at least one hour (`3600` seconds). Setting it to a value lower than this is an error.
    environment_variable: "NAUTOBOT_RELEASE_CHECK_TIMEOUT"
    is_constance_config: true
    type: "integer"
  RELEASE_CHECK_URL:
    default: ""
    description: >-
      This parameter defines the URL of the repository that will be checked periodically for new Nautobot releases.
      When a new release is detected, a message will be displayed to administrative users on the home page.
    details: |-
      This can be set to the official repository (`'https://api.github.com/repos/nautobot/nautobot/releases'`)
      or a custom fork. Set this to `None` to disable automatic update checks.

      !!! note
          The URL provided **must** be compatible with the [GitHub REST API](https://docs.github.com/en/rest).
    environment_variable: "NAUTOBOT_RELEASE_CHECK_URL"
    format: "uri"
    is_constance_config: true
    type: "string"
  REMOTE_AUTH_AUTO_CREATE_USER:
    default: false
    description: >-
      If set to `True`, local accounts will be automatically created for users authenticated via a remote service.
    see_also:
      "Remote User Authentication": "./authentication/remote.md"
    type: "boolean"
  REMOTE_AUTH_HEADER:
    default: "HTTP_REMOTE_USER"
    description: >-
      When remote user authentication is in use, this is the name of the HTTP header which informs Nautobot
      of the currently authenticated user. For example, to use the request header `X-Remote-User`, it needs to
      be set to `"HTTP_X_REMOTE_USER"`.
    see_also:
      "Remote User Authentication": "./authentication/remote.md"
    type: "string"
  SANITIZER_PATTERNS:
    default: []
    default_literal: |-
      ```python
      [
          (re.compile(r"(https?://)?\S+\s*@", re.IGNORECASE), r"\1{replacement}@"),
          (
              re.compile(r"(username|password|passwd|pwd|secret|secrets)([\"']?(?:\s+is.?|:)?\s+)\S+[\"']?", re.IGNORECASE),
              r"\1\2{replacement}",
          ),
      ]
      ```
    description: >-
      List of (regular expression, replacement pattern) tuples used by the `nautobot.core.utils.logging.sanitize()`
      function.
    details: |-
      As of Nautobot 1.3.4 this function is used primarily for sanitization of Job log entries,
      but it may be used in other scopes in the future.

      This pattern catches patterns such as:

      | Pattern Match Examples |
      | --- |
      | Password is1234 |
      | Password: is1234 |
      | Password is: is1234 |
      | Password is is1234 |
      | secret is: is1234 |
      | secret is is1234 |
      | secrets is: is1234 |
      | secrets is is1234 |
      | {"username": "is1234"} |
      | {"password": "is1234"} |
      | {"secret": "is1234"} |
      | {"secrets": "is1234"} |

      !!! info
          `is1234` would be replaced in the Job logs with `(redacted)`.
    items:
      items:
        oneOf:
        - "$ref": "#/definitions/regex"
        - "type": "string"
      type: "array"
    type: "array"
    version_added: "1.3.4"
  SECRET_KEY:
    default: ""
    description: >-
      This is a secret, random string used to assist in the creation of new cryptographic hashes for passwords
      and HTTP cookies.
    details: |-
      The key defined here should not be shared outside of the configuration file.
      `SECRET_KEY` can be changed at any time, however be aware that doing so will invalidate all existing sessions.

      `SECRET_KEY` should be at least 50 characters long and contain a random mix of letters, digits, and symbols.

      !!! note
          A unique `SECRET_KEY` is generated for you automatically when you use `nautobot-server init`
          to create a new `nautobot_config.py`.

      You may run `nautobot-server generate_secret_key` to generate a new key at any time.

      ```no-highlight
      nautobot-server generate_secret_key
      ```

      Sample output:

      ```no-highlight
      +$_kw69oq&fbkfk6&q-+ksbgzw1&061ghw%420u3(wen54w(m
      ```

      Alternatively use the following command to generate a secret even before `nautobot-server` is runnable:

      ```no-highlight
      LC_ALL=C tr -cd '[:lower:][:digit:]!@#$%^&*(\-_=+)' < /dev/urandom | fold -w50 | head -n1
      ```

      Example output:

      ```no-highlight
      9.V$@Kxkc@@Kd@z<a/=.J-Y;rYc79<y@](9o9(L(*sS)Q+ud5P
      ```

      !!! warning
          In the case of a highly available installation with multiple web servers, `SECRET_KEY` must be identical
          among all servers in order to maintain a persistent user session state.
    environment_variable: "NAUTOBOT_SECRET_KEY"
    is_required_setting: true
    type: "string"
  SESSION_CACHE_ALIAS:
    default: "default"
    description: "The Alias for the sessions cache defined in CACHES, used in Nautobot Version Control App."
    type: "string"
  SESSION_COOKIE_AGE:
    default: 1209600
    description: "The maximum age of session cookies, in seconds. The default value is 2 weeks."
    environment_variable: "NAUTOBOT_SESSION_COOKIE_AGE"
    see_also:
      "Django documentation for `SESSION_COOKIE_AGE`": "https://docs.djangoproject.com/en/stable/ref/settings/#session-cookie-age"
      SESSION_EXPIRE_AT_BROWSER_CLOSE: "#session_expire_at_browser_close"
    type: "integer"
  SESSION_ENGINE:
    default: "django.contrib.sessions.backends.db"
    description: "Controls where Nautobot stores session data."
    details: >-
      To use cache-based sessions, set this to `'django.contrib.sessions.backends.cache'`.
      To use file-based sessions, set this to `'django.contrib.sessions.backends.file'`.
    see_also:
      "Django documentation on configuring sessions": "https://docs.djangoproject.com/en/stable/topics/http/sessions/#configuring-sessions"
    type: "string"
  SESSION_EXPIRE_AT_BROWSER_CLOSE:
    default: false
    description: >-
      If this is set to True, Nautobot will use browser-length cookies - cookies that expire as soon as
      the user closes their browser. When set to False, session cookies will be stored in users' browsers for as long
      as [`SESSION_COOKIE_AGE`](#session_cookie_age).
    environment_variable: "NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE"
    see_also:
      "Django documentation for `SESSION_EXPIRE_AT_BROWSER_CLOSE`": "https://docs.djangoproject.com/en/stable/ref/settings/#session-expire-at-browser-close"
    type: "boolean"
  SESSION_FILE_PATH:
    "$ref": "#/definitions/relative_path"
    default: null
    description: >-
      HTTP session data is used to track authenticated users when they access Nautobot.
      By default, Nautobot stores session data in its database. However, this inhibits authentication to a
      standby instance of Nautobot without write access to the database. Alternatively, a local file path may be
      specified here and Nautobot will store session data as files instead of using the database.
      Note that the Nautobot system user must have read and write permissions to this path.

      If set to the default value of `None`, Nautobot will use the standard temporary directory for the system.
    details: >-
      If you set this value, you must also enable file-based sessions as explained under
      [`SESSION_ENGINE`](#session_engine).
    environment_variable: "NAUTOBOT_SESSION_FILE_PATH"
  SHORT_DATE_FORMAT:
    default: "Y-m-d"
    description: "Custom short format for dates. The default results in strings like \"2024-01-22\"."
    environment_variable: "NAUTOBOT_SHORT_DATE_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  SHORT_DATETIME_FORMAT:
    default: "Y-m-d H:i"
    description: "Custom short format for date-times. The default results in strings like \"2024-01-22 13:23\"."
    environment_variable: "NAUTOBOT_SHORT_DATETIME_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  SOCIAL_AUTH_BACKEND_PREFIX:
    default: "social_core.backends"
    description: "Configuration of a custom external authentication backend with python-social-auth."
    see_also:
      "Single Sign On": "./authentication/sso.md"
      "`social-auth-app-django`": "https://python-social-auth.readthedocs.io/en/latest/configuration/django.html"
    type: "string"
  STATIC_ROOT:
    "$ref": "#/definitions/absolute_path"
    default: "~/.nautobot/static"
    description: >-
      The location where static files (such as CSS, JavaScript, fonts, or images) used to serve the web interface
      will be staged by the `nautobot-server collectstatic` command.
    see_also:
      "Django documentation for `STATIC_ROOT`": "https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-STATIC_ROOT"
  STORAGE_BACKEND:
    default: null
    description: "The backend storage engine for handling uploaded files (e.g. image attachments)."
    details: |-
      Nautobot supports integration with the [`django-storages`](https://django-storages.readthedocs.io/en/stable/)
      package, which provides backends for several popular file storage services.
      If not configured, local filesystem storage will be used.

      !!! tip
          For an example of using `django-storages` with AWS S3 buckets, visit the
          [django-storages with S3](../guides/s3-django-storage.md) user-guide.

      The configuration parameters for the specified storage backend are defined under the
      [`STORAGE_CONFIG`](#storage_config) setting.
    see_also:
      "`JOB_FILE_IO_STORAGE`": "#job_file_io_storage"
    type: "string"
  STORAGE_CONFIG:
    default: {}
    description: "A dictionary of configuration parameters for the storage backend configured as STORAGE_BACKEND."
    details: |-
      The specific parameters to be used here are specific to each backend.

      If [`STORAGE_BACKEND`](#storage_backend) is not defined, this setting will be ignored.
    see_also:
      "`django-storages` documentation": "https://django-storages.readthedocs.io/en/stable/"
    type: "object"
  STRICT_FILTERING:
    default: true
    description: >-
      If set to `True` (default), UI and REST API filtering of object lists will fail if an unknown/unrecognized
      filter parameter is provided as a URL parameter.
      (For example, `/dcim/devices/?ice_cream_flavor=chocolate` or `/api/dcim/locations/?ice_cream_flavor=chocolate`)
    details: |-
      UI list (table) views will report an error message in this case and display no filtered objects;
      REST API list endpoints will return a 400 Bad Request response with an explanatory error message.

      If set to `False`, unknown/unrecognized filter parameters will be discarded and ignored,
      although Nautobot will log a warning message.

      !!! warning
          Setting this to `False` can result in unexpected filtering results in the case of user error,
          for example `/dcim/devices/?has_primry_ip=false` (note the typo `primry`) will result in a list of
          _all_ devices, rather than the intended list of only devices that lack a primary IP address.
          In the case of Jobs or external automation making use of such a filter, this could have
          wide-ranging consequences.
    environment_variable: "NAUTOBOT_STRICT_FILTERING"
    type: "boolean"
    version_added: "1.4.0"
  SUPPORT_MESSAGE:
    default: ""
    description: "A message to include on error pages (status code 403, 404, 500, etc.) when an error occurs."
    details: |-
      You can configure this to direct users to the appropriate contact(s) within your organization that
      provide support for Nautobot. Markdown formatting is supported within this message, as well as
      [a limited subset of HTML](../../platform-functionality/template-filters.md#render_markdown).

      If unset, the default message that will appear is
      `If further assistance is required, please join the #nautobot channel on
      [Network to Code's Slack community](https://slack.networktocode.com) and post your question.`
    environment_variable: "NAUTOBOT_SUPPORT_MESSAGE"
    is_constance_config: true
    type: "string"
    version_added: "2.0.2"
  TEST_FACTORY_SEED:
    default: null
    description: >-
      This configuration provides a fixed seed string for the pseudo-random generator used to populate test data
      into the database, providing for reproducible randomness across consecutive test runs.
      If unset, a random seed will be used each time.
    environment_variable: "NAUTOBOT_TEST_FACTORY_SEED"
    type: "string"
    version_added: "1.5.0"
    see_also:
      "`TEST_USE_FACTORIES`": "#test_use_factories"
  TEST_PERFORMANCE_BASELINE_FILE:
    default: "nautobot/core/tests/performance_baselines.yml"
    description: "File path of a YAML file providing baseline times for all performance-related tests."
    details: |-
      The YAML file should conform to the following format:

      ```yaml
      tests:
          - name: >-
                test_run_job_with_sensitive_variables_and_requires_approval
                (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 4.799533
          - name: test_run_missing_schedule (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 4.367563
          - name: test_run_now_missing_args (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 4.363194
          - name: >-
                test_create_object_with_constrained_permission
                (nautobot.extras.tests.test_views.GraphQLQueriesTestCase)
            execution_time: 3.474244
          - name: >-
                test_run_now_constrained_permissions
                (nautobot.extras.tests.test_views.JobTestCase)
            execution_time: 2.727531
      ```
    environment_variable: "NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE"
    type: "string"
    version_added: "1.5.0"
  TEST_USE_FACTORIES:
    default: false
    description: >-
      If set to `True`, the Nautobot test runner will call `nautobot-server generate_test_data ...` before
      executing any test cases, pre-populating the test database with various pseudo-random instances of
      many of Nautobot's data models.
    details: |-
      !!! warning
          This functionality requires the installation of the [`factory-boy`](https://pypi.org/project/factory-boy/)
          Python package, which is present in Nautobot's own development environment, but is _not_ an inherent
          dependency of the Nautobot package when installed otherwise, such as into an App's development
          environment.

      !!! info
          Setting this to `True` is a requirement for all Nautobot core tests as of 1.5.0, and it is set accordingly
          in `nautobot/core/tests/nautobot_config.py`, but defaults to `False` otherwise so as to remain
          backwards-compatible with Apps that also may use the Nautobot test runner in their own test environments,
          but have not yet updated their tests to account for the presence of this test data.

      Because this test data can obviate the need to manually construct complex test data, and the random factor
      can improve test robustness, App developers are encouraged to set this to `True` in their configuration,
      ensure that their development environments include the `factory-boy` Python package as a test dependency,
      and update their tests as needed.
    environment_variable: "NAUTOBOT_TEST_USE_FACTORIES"
    type: "boolean"
    version_added: "1.5.0"
    see_also:
      "`TEST_FACTORY_SEED`": "#test_factory_seed"
  TIME_FORMAT:
    default: "g:i a"
    description: "Custom format for times. The default results in strings like \"1:23 p.m.\"."
    environment_variable: "NAUTOBOT_TIME_FORMAT"
    see_also:
      "Django documentation on date/time format strings": "https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date"
    type: "string"
  TIME_ZONE:
    default: "UTC"
    description: >-
      The time zone Nautobot will use when dealing with dates and times. It is recommended to use UTC time unless you have a specific need to use a local time zone. Please see the [list of available time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
    details: |-
      !!! warning
          Scheduled jobs will run in the time zone configured in this setting. If you change this setting from the
          default UTC, you must change it on the Celery Beat server and all Nautobot web servers or your scheduled
          jobs may run in the wrong time zone.
    environment_variable: "NAUTOBOT_TIME_ZONE"
    see_also:
      "Time Zones documentation": "./time-zones.md"
      "Django documentation for `TIME_ZONE`": "https://docs.djangoproject.com/en/stable/ref/settings/#time-zone"
    type: "string"
  UI_RACK_VIEW_TRUNCATE_FUNCTION:
    "$ref": "#/definitions/callable"
    default: "UI_RACK_VIEW_TRUNCATE_FUNCTION"
    default_literal: |-
      ```py
      def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):
          return str(device_display_name).split(".")[0]
      ```
    description: "This setting function is used to perform the rack elevation truncation feature."
    details: >-
      This provides a way to tailor the truncation behavior to best suit the needs of the installation.

      The function must take only one argument: the device display name, as a string, attempting to be rendered
      on the rack elevation.

      The function must return only one argument: a string of the truncated device display name.
    version_added: "1.4.0"
...



----- FILE: nautobot_core_templates_nautobot_config.py.j2 (NEW) -----
import os
import sys

from nautobot.core.settings import *  # noqa F401,F403
from nautobot.core.settings_funcs import is_truthy, parse_redis_connection

#########################
#                       #
#   Required settings   #
#                       #
#########################

# This is a list of valid fully-qualified domain names (FQDNs) for the Nautobot server. Nautobot will not permit write
# access to the server via any other hostnames. The first FQDN in the list will be treated as the preferred name.
#
# Example: ALLOWED_HOSTS = ['nautobot.example.com', 'nautobot.internal.local']
#
# ALLOWED_HOSTS = os.getenv("NAUTOBOT_ALLOWED_HOSTS", "").split(" ")

# The django-redis cache is used to establish concurrent locks using Redis.
#
# CACHES = {
#     "default": {
#         "BACKEND": os.getenv(
#             "NAUTOBOT_CACHES_BACKEND",
#             "django_prometheus.cache.backends.redis.RedisCache" if METRICS_ENABLED else "django_redis.cache.RedisCache",
#         ),
#         "LOCATION": parse_redis_connection(redis_database=1),
#         "TIMEOUT": 300,
#         "OPTIONS": {
#             "CLIENT_CLASS": "django_redis.client.DefaultClient",
#             "PASSWORD": "",
#         },
#     }
# }

# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.
# CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv("NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT", "0"))

# Celery Beat heartbeat file path - will be touched by Beat each time it wakes up as a proof-of-health.
# CELERY_BEAT_HEARTBEAT_FILE = os.getenv(
#     "NAUTOBOT_CELERY_BEAT_HEARTBEAT_FILE",
#     os.path.join(tempfile.gettempdir(), "nautobot_celery_beat_heartbeat"),
# )

# Celery broker URL used to tell workers where queues are located
#
# CELERY_BROKER_URL = os.getenv("NAUTOBOT_CELERY_BROKER_URL", parse_redis_connection(redis_database=0))

# Optional configuration dict for Celery to use custom SSL certificates to connect to Redis.
#
# CELERY_BROKER_USE_SSL = None

# Database configuration. See the Django documentation for a complete list of available parameters:
#   https://docs.djangoproject.com/en/stable/ref/settings/#databases
#
# DATABASES = {
#     "default": {
#         "NAME": os.getenv("NAUTOBOT_DB_NAME", "nautobot"),  # Database name
#         "USER": os.getenv("NAUTOBOT_DB_USER", ""),  # Database username
#         "PASSWORD": os.getenv("NAUTOBOT_DB_PASSWORD", ""),  # Database password
#         "HOST": os.getenv("NAUTOBOT_DB_HOST", "localhost"),  # Database server
#         "PORT": os.getenv("NAUTOBOT_DB_PORT", ""),  # Database port (leave blank for default)
#         "CONN_MAX_AGE": int(os.getenv("NAUTOBOT_DB_TIMEOUT", "300")),  # Database timeout
#         "ENGINE": os.getenv(
#             "NAUTOBOT_DB_ENGINE",
#             "django_prometheus.db.backends.postgresql" if METRICS_ENABLED else "django.db.backends.postgresql",
#         ),  # Database driver ("mysql" or "postgresql")
#     }
# }

# Ensure proper Unicode handling for MySQL
#
if DATABASES["default"]["ENGINE"].endswith("mysql"):
    DATABASES["default"]["OPTIONS"] = {"charset": "utf8mb4"}

# This key is used for secure generation of random numbers and strings. It must never be exposed outside of this file.
# For optimal security, SECRET_KEY should be at least 50 characters in length and contain a mix of letters, numbers, and
# symbols. Nautobot will not run without this defined. For more information, see
# https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-SECRET_KEY
SECRET_KEY = os.getenv("NAUTOBOT_SECRET_KEY", "{{ secret_key }}")

#####################################
#                                   #
#   Optional Django core settings   #
#                                   #
#####################################

# Specify one or more (name, email address) tuples representing Nautobot administrators.
# These people will be notified of application errors (assuming correct email settings are provided).
#
# ADMINS = []

# FQDNs that are considered trusted origins for secure, cross-domain, requests such as HTTPS POST.
# If running Nautobot under a single domain, you may not need to set this variable;
# if running on multiple domains, you *may* need to set this variable to more or less the same as ALLOWED_HOSTS above.
# https://docs.djangoproject.com/en/stable/ref/settings/#csrf-trusted-origins
#
# CSRF_TRUSTED_ORIGINS = []

# Date/time formatting. See the following link for supported formats:
# https://docs.djangoproject.com/en/stable/ref/templates/builtins/#date
#
# DATE_FORMAT = os.getenv("NAUTOBOT_DATE_FORMAT", "N j, Y")
# SHORT_DATE_FORMAT = os.getenv("NAUTOBOT_SHORT_DATE_FORMAT", "Y-m-d")
# TIME_FORMAT = os.getenv("NAUTOBOT_TIME_FORMAT", "g:i a")
# DATETIME_FORMAT = os.getenv("NAUTOBOT_DATETIME_FORMAT", "N j, Y g:i a")
# SHORT_DATETIME_FORMAT = os.getenv("NAUTOBOT_SHORT_DATETIME_FORMAT", "Y-m-d H:i")

# Set to True to enable server debugging. WARNING: Debugging introduces a substantial performance penalty and may reveal
# sensitive information about your installation. Only enable debugging while performing testing. Never enable debugging
# on a production system.
#
# DEBUG = is_truthy(os.getenv("NAUTOBOT_DEBUG", "False"))

# If hosting Nautobot in a subdirectory, you must set this value to match the base URL prefix configured in your
# HTTP server (e.g. `/nautobot/`). When not set, URLs will default to being prefixed by `/`.
#
# FORCE_SCRIPT_NAME = None

# IP addresses recognized as internal to the system.
#
# INTERNAL_IPS = ("127.0.0.1", "::1")

# Enable custom logging. Please see the Django documentation for detailed guidance on configuring custom logs:
#   https://docs.djangoproject.com/en/stable/topics/logging/
#
# LOGGING = {
#     "version": 1,
#     "disable_existing_loggers": False,
#     "formatters": {
#         "normal": {
#             "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\n  %(message)s",
#             "datefmt": "%H:%M:%S",
#         },
#         "verbose": {
#             "format": "%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\n  %(message)s",
#             "datefmt": "%H:%M:%S",
#         },
#     },
#     "handlers": {
#         "normal_console": {
#             "level": "INFO",
#             "class": "logging.StreamHandler",
#             "formatter": "normal",
#         },
#         "verbose_console": {
#             "level": "DEBUG",
#             "class": "logging.StreamHandler",
#             "formatter": "verbose",
#         },
#     },
#     "loggers": {
#         "django": {"handlers": ["normal_console"], "level": "INFO"},
#         "nautobot": {
#             "handlers": ["verbose_console" if DEBUG else "normal_console"],
#             "level": "DEBUG" if DEBUG else "INFO",
#         },
#     },
# }

# The file path where uploaded media such as image attachments are stored. A trailing slash is not needed.
#
# MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, "media").rstrip("/")

# Set to True to use session cookies instead of persistent cookies.
# Session cookies will expire when a browser is closed.
#
# SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv("NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE", "False"))

# The length of time (in seconds) for which a user will remain logged into the web UI before being prompted to
# re-authenticate. (Default: 1209600 [14 days])
#
# SESSION_COOKIE_AGE = int(os.getenv("NAUTOBOT_SESSION_COOKIE_AGE", "1209600"))  # 2 weeks, in seconds

# Where Nautobot stores user session data.
#
# SESSION_ENGINE = "django.contrib.sessions.backends.db"

# By default, Nautobot will store session data in the database. Alternatively, a file path can be specified here to use
# local file storage instead. (This can be useful for enabling authentication on a standby instance with read-only
# database access.) Note that the user as which Nautobot runs must have read and write permissions to this path.
#
# SESSION_FILE_PATH = os.getenv("NAUTOBOT_SESSION_FILE_PATH", None)

# Where static files (CSS, JavaScript, etc.) are stored
#
# STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, "static")

# Time zone (default: UTC)
#
# TIME_ZONE = os.getenv("NAUTOBOT_TIME_ZONE", "UTC")

###################################################################
#                                                                 #
#   Optional settings specific to Nautobot and its related apps   #
#                                                                 #
###################################################################

# Allow users to enable request profiling via django-silk for admins to inspect.
# if "NAUTOBOT_ALLOW_REQUEST_PROFILING" in os.environ and os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"] != "":
#     ALLOW_REQUEST_PROFILING = is_truthy(os.environ["NAUTOBOT_ALLOW_REQUEST_PROFILING"])

# URL schemes that are allowed within links in Nautobot
#
# ALLOWED_URL_SCHEMES = (
#     "file",
#     "ftp",
#     "ftps",
#     "http",
#     "https",
#     "irc",
#     "mailto",
#     "sftp",
#     "ssh",
#     "tel",
#     "telnet",
#     "tftp",
#     "vnc",
#     "xmpp",
# )

# Banners (HTML is permitted) to display at the top and/or bottom of all Nautobot pages, and on the login page itself.
#
# if "NAUTOBOT_BANNER_BOTTOM" in os.environ and os.environ["NAUTOBOT_BANNER_BOTTOM"] != "":
#     BANNER_BOTTOM = os.environ["NAUTOBOT_BANNER_BOTTOM"]
# if "NAUTOBOT_BANNER_LOGIN" in os.environ and os.environ["NAUTOBOT_BANNER_LOGIN"] != "":
#     BANNER_LOGIN = os.environ["NAUTOBOT_BANNER_LOGIN"]
# if "NAUTOBOT_BANNER_TOP" in os.environ and os.environ["NAUTOBOT_BANNER_TOP"] != "":
#     BANNER_TOP = os.environ["NAUTOBOT_BANNER_TOP"]

# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.
# The filepath should be relative to the `MEDIA_ROOT`.
#
# BRANDING_FILEPATHS = {
#     "logo": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_LOGO", None),  # Navbar logo
#     "favicon": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_FAVICON", None),  # Browser favicon
#     "icon_16": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_16", None),  # 16x16px icon
#     "icon_32": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_32", None),  # 32x32px icon
#     "icon_180": os.getenv(
#         "NAUTOBOT_BRANDING_FILEPATHS_ICON_180", None
#     ),  # 180x180px icon - used for the apple-touch-icon header
#     "icon_192": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_ICON_192", None),  # 192x192px icon
#     "icon_mask": os.getenv(
#         "NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK", None
#     ),  # mono-chrome icon used for the mask-icon header
#     "header_bullet": os.getenv(
#         "NAUTOBOT_BRANDING_FILEPATHS_HEADER_BULLET", None
#     ),  # bullet image used for various view headers
#     "nav_bullet": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_NAV_BULLET", None),  # bullet image used for nav menu headers
#     "css": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_CSS", None),  # Custom global CSS
#     "javascript": os.getenv("NAUTOBOT_BRANDING_FILEPATHS_JAVASCRIPT", None),  # Custom global JavaScript
# }

# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)
#
# BRANDING_PREPENDED_FILENAME = os.getenv("NAUTOBOT_BRANDING_PREPENDED_FILENAME", "nautobot_")

# Title to use in place of "Nautobot"
#
# BRANDING_TITLE = os.getenv("NAUTOBOT_BRANDING_TITLE", "Nautobot")

# Branding URLs (links in the bottom right of the footer)
#
# BRANDING_URLS = {
#     "code": os.getenv("NAUTOBOT_BRANDING_URLS_CODE", "https://github.com/nautobot/nautobot"),
#     "docs": os.getenv("NAUTOBOT_BRANDING_URLS_DOCS", None),
#     "help": os.getenv("NAUTOBOT_BRANDING_URLS_HELP", "https://github.com/nautobot/nautobot/wiki"),
# }

# Options to pass to the Celery broker transport, for example when using Celery with Redis Sentinel.
#
# CELERY_BROKER_TRANSPORT_OPTIONS = {}

# Default celery queue name that will be used by workers and tasks if no queue is specified
# CELERY_TASK_DEFAULT_QUEUE = os.getenv("NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE", "default")

# Global task time limits (seconds)
# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,
# while exceeding the hard limit will result in a SIGKILL.
#
# CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT", str(5 * 60)))
# CELERY_TASK_TIME_LIMIT = int(os.getenv("NAUTOBOT_CELERY_TASK_TIME_LIMIT", str(10 * 60)))

# Ports for prometheus metric HTTP server running on the celery worker.
# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.
# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the
# highest amount of workers you are running on a single machine (comma-separated, like "8080,8081,8082"). You can then
# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in
# that case. Set this to an empty string to disable it.
# CELERY_WORKER_PROMETHEUS_PORTS = []
# if os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS"):
#     CELERY_WORKER_PROMETHEUS_PORTS = [
#         int(value) for value in os.getenv("NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS").split(",")
#     ]


# Number of days to retain changelog entries. Set to 0 to retain changes indefinitely. Defaults to 90 if not set here.
#
# if "NAUTOBOT_CHANGELOG_RETENTION" in os.environ and os.environ["NAUTOBOT_CHANGELOG_RETENTION"] != "":
#     CHANGELOG_RETENTION = int(os.environ["NAUTOBOT_CHANGELOG_RETENTION"])

# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.
# Defaults to False. Setting this to True can be dangerous, as it allows any website to make
# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with
# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.
#
# CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv("NAUTOBOT_CORS_ALLOW_ALL_ORIGINS", "False"))

# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].
#
# CORS_ALLOWED_ORIGINS = [
#     'https://hostname.example.com',
# ]

# A list of strings representing regexes that match Origins that are authorized to make cross-site
# HTTP requests. Defaults to [].
#
# CORS_ALLOWED_ORIGIN_REGEXES = [
#     r'^(https?://)?(\w+\.)?example\.com$',
# ]

# UUID uniquely but anonymously identifying this Nautobot deployment.
#
# if "NAUTOBOT_DEPLOYMENT_ID" in os.environ and os.environ["NAUTOBOT_DEPLOYMENT_ID"] != "":
#     DEPLOYMENT_ID = os.environ["NAUTOBOT_DEPLOYMENT_ID"]

# Device names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to True to use the device name alone as the natural key for Device objects.
# Set this to False to use the sequence (name, tenant, location) as the natural key instead.
#
# if "NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"] != "":
#     DEVICE_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_DEVICE_NAME_AS_NATURAL_KEY"])

# The number of seconds to cache the member list of dynamic groups. Set this to `0` to disable caching.
#
# if (
#     "NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT" in os.environ
#     and os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"] != ""
# ):
#     DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT = int(os.environ["NAUTOBOT_DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT"])

# Exempt certain models from the enforcement of view permissions. Models listed here will be viewable by all users and
# by anonymous users. List models in the form `<app>.<model>`. Add '*' to this list to exempt all models.
# Defaults to [].
#
# EXEMPT_VIEW_PERMISSIONS = [
#     'dcim.location',
#     'ipam.prefix',
# ]

# Global 3rd-party authentication settings
#
# EXTERNAL_AUTH_DEFAULT_GROUPS = []
# EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}

# Directory where cloned Git repositories will be stored.
#
# GIT_ROOT = os.getenv("NAUTOBOT_GIT_ROOT", os.path.join(NAUTOBOT_ROOT, "git").rstrip("/"))

# Prefixes to use for custom fields, relationships, and computed fields in GraphQL representation of data.
#
# GRAPHQL_COMPUTED_FIELD_PREFIX = "cpf"
# GRAPHQL_CUSTOM_FIELD_PREFIX = "cf"
# GRAPHQL_RELATIONSHIP_PREFIX = "rel"

# HTTP proxies Nautobot should use when sending outbound HTTP requests (e.g. for webhooks).
#
# HTTP_PROXIES = {
#     'http': 'http://10.10.1.10:3128',
#     'https': 'http://10.10.1.10:1080',
# }

# Send anonymized installation metrics when `nautobot-server post_upgrade` command is run.
#
INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_INSTALLATION_METRICS_ENABLED", "{{ installation_metrics_enabled | default(True) }}"))

# Storage backend to use for Job input files and Job output files.
#
# Note: the default is for backwards compatibility and it is recommended to change it if possible for your deployment.
#
# JOB_FILE_IO_STORAGE = os.getenv("NAUTOBOT_JOB_FILE_IO_STORAGE", "db_file_storage.storage.DatabaseFileStorage")

# Maximum size in bytes of any single file created by Job.create_file().
#
# JOB_CREATE_FILE_MAX_SIZE = 10 << 20

# Directory where Jobs can be discovered.
#
# JOBS_ROOT = os.getenv("NAUTOBOT_JOBS_ROOT", os.path.join(NAUTOBOT_ROOT, "jobs").rstrip("/"))

# Location names are not guaranteed globally-unique by Nautobot but in practice they often are.
# Set this to True to use the location name alone as the natural key for Location objects.
# Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) as the natural key instead.
#
# if "NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY" in os.environ and os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"] != "":
#     LOCATION_NAME_AS_NATURAL_KEY = is_truthy(os.environ["NAUTOBOT_LOCATION_NAME_AS_NATURAL_KEY"])

# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True
#
# LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv("NAUTOBOT_LOG_DEPRECATION_WARNINGS", "False"))

# Setting this to True will display a "maintenance mode" banner at the top of every page.
#
# MAINTENANCE_MODE = is_truthy(os.getenv("NAUTOBOT_MAINTENANCE_MODE", "False"))

# Maximum number of objects that the UI and API will retrieve in a single request. Default is 1000
#
# if "NAUTOBOT_MAX_PAGE_SIZE" in os.environ and os.environ["NAUTOBOT_MAX_PAGE_SIZE"] != "":
#     MAX_PAGE_SIZE = int(os.environ["NAUTOBOT_MAX_PAGE_SIZE"])

# Expose Prometheus monitoring metrics at the HTTP endpoint '/metrics'
#
# METRICS_ENABLED = is_truthy(os.getenv("NAUTOBOT_METRICS_ENABLED", "False"))

# Require API Authentication to HTTP endpoint '/metrics'
#
# METRICS_AUTHENTICATED = is_truthy(os.getenv("NAUTOBOT_METRICS_AUTHENTICATED", "False"))

# Disable app metrics for specific apps
#
# if "NAUTOBOT_METRICS_DISABLED_APPS" in os.environ and os.environ["NAUTOBOT_METRICS_DISABLED_APPS"] != "":
#     METRICS_DISABLED_APPS = os.getenv("NAUTOBOT_METRICS_DISABLED_APPS", "").split(",")

# Credentials that Nautobot will uses to authenticate to devices when connecting via NAPALM.
#
# NAPALM_USERNAME = os.getenv("NAUTOBOT_NAPALM_USERNAME", "")
# NAPALM_PASSWORD = os.getenv("NAUTOBOT_NAPALM_PASSWORD", "")

# NAPALM timeout (in seconds). (Default: 30)
#
# NAPALM_TIMEOUT = int(os.getenv("NAUTOBOT_NAPALM_TIMEOUT", "30"))

# NAPALM optional arguments (see https://napalm.readthedocs.io/en/latest/support/#optional-arguments). Arguments must
# be provided as a dictionary.
#
# NAPALM_ARGS = {}

# Default number of objects to display per page of the UI and REST API. Default is 50
#
# if "NAUTOBOT_PAGINATE_COUNT" in os.environ and os.environ["NAUTOBOT_PAGINATE_COUNT"] != "":
#     PAGINATE_COUNT = int(os.environ["NAUTOBOT_PAGINATE_COUNT"])

# Options given in the web UI for the number of objects to display per page.
# Default is [25, 50, 100, 250, 500, 1000]
#
# if "NAUTOBOT_PER_PAGE_DEFAULTS" in os.environ and os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"] != "":
#     PER_PAGE_DEFAULTS = [int(val) for val in os.environ["NAUTOBOT_PER_PAGE_DEFAULTS"].split(",")]

# Enable installed plugins. Add the name of each plugin to the list.
#
# PLUGINS = []

# Plugins configuration settings. These settings are used by various plugins that the user may have installed.
# Each key in the dictionary is the name of an installed plugin and its value is a dictionary of settings.
#
# PLUGINS_CONFIG = {
#     'my_plugin': {
#         'foo': 'bar',
#         'buzz': 'bazz'
#     }
# }

# Prefer IPv6 addresses or IPv4 addresses in selecting a device's primary IP address? Default False
#
# if "NAUTOBOT_PREFER_IPV4" in os.environ and os.environ["NAUTOBOT_PREFER_IPV4"] != "":
#     PREFER_IPV4 = is_truthy(os.environ["NAUTOBOT_PREFER_IPV4"])

# Default height and width in pixels of a single rack unit in rendered rack elevations. Defaults are 22 and 230
#
# if (
#     "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT" in os.environ
#     and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"] != ""
# ):
#     RACK_ELEVATION_DEFAULT_UNIT_HEIGHT = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_HEIGHT"])
# if (
#     "NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH" in os.environ
#     and os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"] != ""
# ):
#     RACK_ELEVATION_DEFAULT_UNIT_WIDTH = int(os.environ["NAUTOBOT_RACK_ELEVATION_DEFAULT_UNIT_WIDTH"])

# Enable two-digit format for the rack unit numbering in rack elevations.
#
# if (
#     "NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT" in os.environ
#      and os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"] != ""
# ):
#     RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT = is_truthy(os.environ["NAUTOBOT_RACK_ELEVATION_UNIT_TWO_DIGIT_FORMAT"])

# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added
# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`
#
# REDIS_LOCK_TIMEOUT = int(os.getenv("NAUTOBOT_REDIS_LOCK_TIMEOUT", "600"))

# How frequently to check for a new Nautobot release on GitHub, and the URL to check for this information.
# Defaults to disabled (no URL) and check every 24 hours when enabled
#
# if "NAUTOBOT_RELEASE_CHECK_TIMEOUT" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"] != "":
#     RELEASE_CHECK_TIMEOUT = int(os.environ["NAUTOBOT_RELEASE_CHECK_TIMEOUT"])
# if "NAUTOBOT_RELEASE_CHECK_URL" in os.environ and os.environ["NAUTOBOT_RELEASE_CHECK_URL"] != "":
#     RELEASE_CHECK_URL = os.environ["NAUTOBOT_RELEASE_CHECK_URL"]

# Remote auth backend settings
#
# REMOTE_AUTH_AUTO_CREATE_USER = False
# REMOTE_AUTH_HEADER = "HTTP_REMOTE_USER"

# Job log entry sanitization and similar
#
# SANITIZER_PATTERNS = [
#     # General removal of username-like and password-like tokens
#     (re.compile(r"(https?://)?\S+\s*@", re.IGNORECASE), r"\1{replacement}@"),
#     (
#         re.compile(r"(username|password|passwd|pwd|secret|secrets)([\"']?(?:\s+is.?|:)?\s+)\S+[\"']?", re.IGNORECASE),
#         r"\1\2{replacement}",
#     ),
# ]

# Configure SSO, for more information see docs/configuration/authentication/sso.md
#
# SOCIAL_AUTH_POSTGRES_JSONFIELD = False

# By default uploaded media is stored on the local filesystem. Using Django-storages is also supported. Provide the
# class path of the storage driver in STORAGE_BACKEND and any configuration options in STORAGE_CONFIG.
# These default to None and {} respectively.
#
# STORAGE_BACKEND = 'storages.backends.s3.S3Storage'
# STORAGE_CONFIG = {
#     'AWS_ACCESS_KEY_ID': 'Key ID',
#     'AWS_SECRET_ACCESS_KEY': 'Secret',
#     'AWS_STORAGE_BUCKET_NAME': 'nautobot',
#     'AWS_S3_REGION_NAME': 'eu-west-1',
# }

# Reject invalid UI/API filter parameters, or discard them while logging a warning?
#
# STRICT_FILTERING = is_truthy(os.getenv("NAUTOBOT_STRICT_FILTERING", "True"))

# Custom message to display on 4xx and 5xx error pages. Markdown and HTML are supported.
# Default message directs the user to #nautobot on NTC's Slack community.
#
# if "NAUTOBOT_SUPPORT_MESSAGE" in os.environ and os.environ["NAUTOBOT_SUPPORT_MESSAGE"] != "":
#     SUPPORT_MESSAGE = os.environ["NAUTOBOT_SUPPORT_MESSAGE"]

# UI_RACK_VIEW_TRUNCATE_FUNCTION
#
# def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):
#     """Given device display name, truncate to fit the rack elevation view.
#
#     :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.
#     :type device_display_name: str
#
#     :return: Truncated device name
#     :type: str
#     """
#     return str(device_display_name).split(".")[0]

# A list of strings designating all applications that are enabled in this Django installation.
# Each string should be a dotted Python path to an application configuration class (preferred),
# or a package containing an application.
# https://docs.nautobot.com/projects/core/en/latest/configuration/optional-settings/#extra-applications
# EXTRA_INSTALLED_APPS = []

# Allow users to enable request profiling on their login session
# ALLOW_REQUEST_PROFILING = False



----- FILE: nautobot_core_templates_base_django.html (NEW) -----
{% load static %}
{% load helpers %}
{% load plugins %}

<!DOCTYPE html>
<html lang="en"{% if request.COOKIES|get_item:"theme" == 'dark' %} data-theme="dark"{% endif %}>
<head>
    <title>{% block title %}Home{% endblock %} - {{ settings.BRANDING_TITLE }}</title>
    {% include 'inc/media.html' %}
    {% block extra_styles %}{% endblock %}
</head>
<body>
    {% include 'inc/nav_menu.html' %}
    <div class="container-fluid wrapper" id="main-content">
        <div class="banner-alert-area">
        {% if request.user.is_authenticated %}
            {% if "BANNER_TOP"|settings_or_config %}
                <div class="alert alert-info text-center" role="alert">
                    {{ "BANNER_TOP"|settings_or_config|render_markdown }}
                </div>
            {% endif %}
        {% endif %}
        {% if settings.MAINTENANCE_MODE %}
            <div class="alert alert-warning text-center" role="alert">
                <h4><i class="mdi mdi-alert"></i> Maintenance Mode</h4>
                <p>Nautobot is currently in maintenance mode. Functionality may be limited.</p>
            </div>
        {% endif %}
        {% plugin_banners %}
        {% for message in messages %}
            <div class="alert alert-{{ message.tags }} alert-dismissable" role="alert">
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span>&times;</span>
                </button>
                {{ message }}
            </div>
        {% endfor %}
        </div>
        {% block header %}{% endblock header %}
        {% block content %}{% endblock content %}
        <div class="push"></div>
        {% if request.user.is_authenticated %}
            {% if "BANNER_BOTTOM"|settings_or_config %}
                <div class="alert alert-info text-center banner-bottom" role="alert">
                    {{ "BANNER_BOTTOM"|settings_or_config|render_markdown }}
                </div>
            {% endif %}
        {% endif %}
    </div>
    {% include 'modals/modal_theme.html' with name='theme'%}
    {% include 'inc/footer.html' %}
    {% include 'inc/javascript.html' %}
{% block javascript %}{% endblock %}
</body>
</html>


