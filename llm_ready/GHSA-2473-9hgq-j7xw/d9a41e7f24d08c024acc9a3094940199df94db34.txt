
#################### LLM PATCH ANALYSIS PACKAGE ####################

You are a security patch migration expert.

Your task:
1. Look at the OLD code (vulnerable).
2. Look at the NEW code (patched).
3. Look at the DIFF.
4. Decide whether the patch can be applied to the old version:
   - Yes      → applies cleanly
   - Maybe    → applies with adjustments
   - No       → cannot be applied
5. Provide a short explanation.

IMPORTANT:
Return ONLY JSON of this form:

{
  "portability": "Yes/Maybe/No",
  "reason": "<short explanation>"
}

####################################################################


### PATCH DIFF ###
commit d9a41e7f24d08c024acc9a3094940199df94db34
Author: Matt Westcott <matt@west.co.tt>
Date:   Thu Jul 9 19:08:03 2020 +0100

    Escape help text in form builder forms by default
    
    This can be disabled with the setting WAGTAILFORMS_HELP_TEXT_ALLOW_HTML

diff --git a/docs/reference/settings.rst b/docs/reference/settings.rst
index 00b27683f5..cfdaa71e98 100644
--- a/docs/reference/settings.rst
+++ b/docs/reference/settings.rst
@@ -547,3 +547,16 @@ By default the redirect importer keeps track of the uploaded file as a temp file
 .. code-block:: python
 
    WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'
+
+Form builder
+============
+
+.. versionadded:: 2.7.4/2.9.3
+
+    The ``WAGTAILFORMS_HELP_TEXT_ALLOW_HTML`` option was added.
+
+.. code-block:: python
+
+    WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True
+
+When true, HTML tags in form field help text will be rendered unescaped (default: False).
diff --git a/wagtail/contrib/forms/forms.py b/wagtail/contrib/forms/forms.py
index cbd9802806..3446fe741e 100644
--- a/wagtail/contrib/forms/forms.py
+++ b/wagtail/contrib/forms/forms.py
@@ -1,6 +1,8 @@
 from collections import OrderedDict
 
 import django.forms
+from django.conf import settings
+from django.utils.html import conditional_escape
 from django.utils.translation import gettext_lazy as _
 
 from wagtail.admin.forms import WagtailAdminPageForm
@@ -114,7 +116,10 @@ class FormBuilder:
     def get_field_options(self, field):
         options = {}
         options['label'] = field.label
-        options['help_text'] = field.help_text
+        if getattr(settings, 'WAGTAILFORMS_HELP_TEXT_ALLOW_HTML', False):
+            options['help_text'] = field.help_text
+        else:
+            options['help_text'] = conditional_escape(field.help_text)
         options['required'] = field.required
         options['initial'] = field.default_value
         return options
diff --git a/wagtail/contrib/forms/tests/test_models.py b/wagtail/contrib/forms/tests/test_models.py
index 08523130c9..822078b9b6 100644
--- a/wagtail/contrib/forms/tests/test_models.py
+++ b/wagtail/contrib/forms/tests/test_models.py
@@ -29,9 +29,18 @@ class TestFormSubmission(TestCase):
         self.assertTemplateUsed(response, 'tests/form_page.html')
         self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')
 
+        # HTML in help text should be escaped
+        self.assertContains(response, "&lt;em&gt;please&lt;/em&gt; be polite")
+
         # check that variables defined in get_context are passed through to the template (#1429)
         self.assertContains(response, "<p>hello world</p>")
 
+    @override_settings(WAGTAILFORMS_HELP_TEXT_ALLOW_HTML=True)
+    def test_get_form_without_help_text_escaping(self):
+        response = self.client.get('/contact-us/')
+        # HTML in help text should not be escaped
+        self.assertContains(response, "<em>please</em> be polite")
+
     def test_post_invalid_form(self):
         response = self.client.post('/contact-us/', {
             'your_email': 'bob',
diff --git a/wagtail/contrib/forms/tests/utils.py b/wagtail/contrib/forms/tests/utils.py
index 809ecf0c6f..e212ecce50 100644
--- a/wagtail/contrib/forms/tests/utils.py
+++ b/wagtail/contrib/forms/tests/utils.py
@@ -28,6 +28,7 @@ def make_form_page(**kwargs):
         label="Your message",
         field_type='multiline',
         required=True,
+        help_text="<em>please</em> be polite"
     )
     FormField.objects.create(
         page=form_page,


### CHANGED FILES SUMMARY ###
{
  "changed_files": [
    "docs/reference/settings.rst",
    "wagtail/contrib/forms/forms.py",
    "wagtail/contrib/forms/tests/test_models.py",
    "wagtail/contrib/forms/tests/utils.py"
  ],
  "files_saved": [
    {
      "file": "docs/reference/settings.rst",
      "old": true,
      "new": true
    },
    {
      "file": "wagtail/contrib/forms/forms.py",
      "old": true,
      "new": true
    },
    {
      "file": "wagtail/contrib/forms/tests/test_models.py",
      "old": true,
      "new": true
    },
    {
      "file": "wagtail/contrib/forms/tests/utils.py",
      "old": true,
      "new": true
    }
  ]
}

### OLD VERSION FILES ###

----- FILE: wagtail_contrib_forms_forms.py (OLD) -----
from collections import OrderedDict

import django.forms
from django.utils.translation import gettext_lazy as _

from wagtail.admin.forms import WagtailAdminPageForm
from wagtail.contrib.forms.utils import get_field_clean_name


class BaseForm(django.forms.Form):
    def __init__(self, *args, **kwargs):
        kwargs.setdefault('label_suffix', '')

        self.user = kwargs.pop('user', None)
        self.page = kwargs.pop('page', None)

        super().__init__(*args, **kwargs)


class FormBuilder:
    def __init__(self, fields):
        self.fields = fields

    def create_singleline_field(self, field, options):
        # TODO: This is a default value - it may need to be changed
        options['max_length'] = 255
        return django.forms.CharField(**options)

    def create_multiline_field(self, field, options):
        return django.forms.CharField(widget=django.forms.Textarea, **options)

    def create_date_field(self, field, options):
        return django.forms.DateField(**options)

    def create_datetime_field(self, field, options):
        return django.forms.DateTimeField(**options)

    def create_email_field(self, field, options):
        return django.forms.EmailField(**options)

    def create_url_field(self, field, options):
        return django.forms.URLField(**options)

    def create_number_field(self, field, options):
        return django.forms.DecimalField(**options)

    def create_dropdown_field(self, field, options):
        options['choices'] = map(
            lambda x: (x.strip(), x.strip()),
            field.choices.split(',')
        )
        return django.forms.ChoiceField(**options)

    def create_multiselect_field(self, field, options):
        options['choices'] = map(
            lambda x: (x.strip(), x.strip()),
            field.choices.split(',')
        )
        return django.forms.MultipleChoiceField(**options)

    def create_radio_field(self, field, options):
        options['choices'] = map(
            lambda x: (x.strip(), x.strip()),
            field.choices.split(',')
        )
        return django.forms.ChoiceField(widget=django.forms.RadioSelect, **options)

    def create_checkboxes_field(self, field, options):
        options['choices'] = [(x.strip(), x.strip()) for x in field.choices.split(',')]
        options['initial'] = [x.strip() for x in field.default_value.split(',')]
        return django.forms.MultipleChoiceField(
            widget=django.forms.CheckboxSelectMultiple, **options
        )

    def create_checkbox_field(self, field, options):
        return django.forms.BooleanField(**options)

    def create_hidden_field(self, field, options):
        return django.forms.CharField(widget=django.forms.HiddenInput, **options)

    def get_create_field_function(self, type):
        """
            Takes string of field type and returns a Django Form Field Instance.
            Assumes form field creation functions are in the format:
            'create_fieldtype_field'
        """
        create_field_function = getattr(self, 'create_%s_field' % type, None)
        if create_field_function:
            return create_field_function
        else:
            import inspect
            method_list = [
                f[0] for f in
                inspect.getmembers(self.__class__, inspect.isfunction)
                if f[0].startswith('create_') and f[0].endswith('_field')
            ]
            raise AttributeError(
                "Could not find function matching format \
                create_<fieldname>_field for type: " + type,
                "Must be one of: " + ", ".join(method_list)
            )

    @property
    def formfields(self):
        formfields = OrderedDict()

        for field in self.fields:
            options = self.get_field_options(field)
            create_field = self.get_create_field_function(field.field_type)
            formfields[field.clean_name] = create_field(field, options)

        return formfields

    def get_field_options(self, field):
        options = {}
        options['label'] = field.label
        options['help_text'] = field.help_text
        options['required'] = field.required
        options['initial'] = field.default_value
        return options

    def get_form_class(self):
        return type(str('WagtailForm'), (BaseForm,), self.formfields)


class SelectDateForm(django.forms.Form):
    date_from = django.forms.DateTimeField(
        required=False,
        widget=django.forms.DateInput(attrs={'placeholder': _('Date from')})
    )
    date_to = django.forms.DateTimeField(
        required=False,
        widget=django.forms.DateInput(attrs={'placeholder': _('Date to')})
    )


class WagtailAdminFormPageForm(WagtailAdminPageForm):

    def clean(self):

        super().clean()

        # Check for dupe form field labels - fixes #585
        if 'form_fields' in self.formsets:
            _forms = self.formsets['form_fields'].forms
            for f in _forms:
                f.is_valid()

            for i, form in enumerate(_forms):
                if 'label' in form.changed_data:
                    label = form.cleaned_data.get('label')
                    clean_name = get_field_clean_name(label)
                    for idx, ff in enumerate(_forms):
                        # Exclude self
                        ff_clean_name = get_field_clean_name(ff.cleaned_data.get('label'))
                        if idx != i and clean_name == ff_clean_name:
                            form.add_error(
                                'label',
                                django.forms.ValidationError(_('There is another field with the label %s, please change one of them.' % label))
                            )



----- FILE: wagtail_contrib_forms_tests_test_models.py (OLD) -----
# -*- coding: utf-8 -*-
import json

from django.core import mail
from django.core.checks import Info
from django.test import TestCase, override_settings

from wagtail.contrib.forms.models import FormSubmission
from wagtail.contrib.forms.tests.utils import (
    make_form_page, make_form_page_with_custom_submission, make_form_page_with_redirect,
    make_types_test_form_page)
from wagtail.core.models import Page
from wagtail.tests.testapp.models import (
    CustomFormPageSubmission, ExtendedFormField, FormField, FormFieldWithCustomSubmission,
    FormPageWithCustomFormBuilder, JadeFormPage)
from wagtail.tests.utils import WagtailTestUtils


class TestFormSubmission(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page()

    def test_get_form(self):
        response = self.client.get('/contact-us/')

        # Check response
        self.assertContains(response, """<label for="id_your_email">Your email</label>""")
        self.assertTemplateUsed(response, 'tests/form_page.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

    def test_post_invalid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob',
            'your_message': 'hello world',
            'your_choices': ''
        })

        # Check response
        self.assertContains(response, "Enter a valid email address.")
        self.assertTemplateUsed(response, 'tests/form_page.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # check the default form_submission is added to the context
        self.assertContains(response, "<li>your_email: bob@example.com</li>")

        # Check that an email was sent
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].to, ['to@email.com'])
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())

    def test_post_unicode_characters(self):
        self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'こんにちは、世界',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your message: こんにちは、世界", mail.outbox[0].body)

        # Check the form submission
        submission = FormSubmission.objects.get()
        submission_data = json.loads(submission.form_data)
        self.assertEqual(submission_data['your_message'], 'こんにちは、世界')

    def test_post_multiple_values(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # Check that the three checkbox values were saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        submission = FormSubmission.objects.filter(
            page=form_page, form_data__contains='hello world'
        )
        self.assertIn("foo", submission[0].form_data)
        self.assertIn("bar", submission[0].form_data)
        self.assertIn("baz", submission[0].form_data)

        # Check that the all the multiple checkbox values are serialised in the
        # email correctly
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("bar", mail.outbox[0].body)
        self.assertIn("foo", mail.outbox[0].body)
        self.assertIn("baz", mail.outbox[0].body)

    def test_post_blank_checkbox(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {},
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # Check that the checkbox was serialised in the email correctly
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your choices: ", mail.outbox[0].body)


class TestFormWithCustomSubmission(TestCase, WagtailTestUtils):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_custom_submission()

        self.user = self.login()

    def test_get_form(self):
        response = self.client.get('/contact-us/')

        # Check response
        self.assertContains(response, """<label for="id_your_email">Your email</label>""")
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)
        self.assertContains(response, '<p>Boring intro text</p>', html=True)

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

    def test_get_form_with_anonymous_user(self):
        self.client.logout()

        response = self.client.get('/contact-us/')

        # Check response
        self.assertNotContains(response, """<label for="id_your_email">Your email</label>""")
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertContains(response, '<div>You must log in first.</div>', html=True)
        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

    def test_post_invalid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob',
            'your_message': 'hello world',
            'your_choices': ''
        })

        # Check response
        self.assertContains(response, "Enter a valid email address.")
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # check that the custom form_submission is added to the context
        self.assertContains(response, "<p>Username: test@email.com</p>")

        # Check that an email was sent
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].to, ['to@email.com'])
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())

    def test_post_form_twice(self):
        # First submission
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertContains(response, '<p>Thank you for your patience!</p>', html=True)
        self.assertNotContains(response, '<div>The form is already filled.</div>', html=True)

        # Check that first form submission was saved correctly
        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)
        self.assertEqual(submissions_qs.count(), 1)
        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())

        # Second submission
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertNotContains(response, '<p>Thank you for your patience!</p>', html=True)
        self.assertContains(response, '<div>The form is already filled.</div>', html=True)
        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)
        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)

        # Check that first submission exists and second submission wasn't saved
        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)
        self.assertEqual(submissions_qs.count(), 1)
        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())
        self.assertFalse(submissions_qs.filter(form_data__contains='hello cruel world').exists())

    def test_post_unicode_characters(self):
        self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'こんにちは、世界',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your message: こんにちは、世界", mail.outbox[0].body)

        # Check the form submission
        submission = CustomFormPageSubmission.objects.get()
        submission_data = json.loads(submission.form_data)
        self.assertEqual(submission_data['your_message'], 'こんにちは、世界')

    def test_post_multiple_values(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # Check that the three checkbox values were saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        submission = CustomFormPageSubmission.objects.filter(
            page=form_page, form_data__contains='hello world'
        )
        self.assertIn("foo", submission[0].form_data)
        self.assertIn("bar", submission[0].form_data)
        self.assertIn("baz", submission[0].form_data)

    def test_post_blank_checkbox(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {},
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # Check that the checkbox was serialised in the email correctly
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your choices: None", mail.outbox[0].body)


class TestFormSubmissionWithMultipleRecipients(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page(to_address='to@email.com, another@email.com')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # Check that one email was sent, but to two recipients
        self.assertEqual(len(mail.outbox), 1)

        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')
        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())


class TestFormSubmissionWithMultipleRecipientsAndWithCustomSubmission(TestCase, WagtailTestUtils):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_custom_submission(
            to_address='to@email.com, another@email.com'
        )

        self.user = self.login()

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # Check that one email was sent, but to two recipients
        self.assertEqual(len(mail.outbox), 1)

        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')
        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(
            CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists()
        )


class TestFormWithRedirect(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_redirect(to_address='to@email.com, another@email.com')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertRedirects(response, '/')

        # Check that one email was sent, but to two recipients
        self.assertEqual(len(mail.outbox), 1)

        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')
        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())


class TestFormPageWithCustomFormBuilder(TestCase, WagtailTestUtils):

    def setUp(self):

        home_page = Page.objects.get(url_path='/home/')
        form_page = home_page.add_child(
            instance=FormPageWithCustomFormBuilder(
                title='Support Request',
                slug='support-request',
                to_address='it@jenkins.com',
                from_address='support@jenkins.com',
                subject='Support Request Submitted',
            )
        )
        ExtendedFormField.objects.create(
            page=form_page,
            sort_order=1,
            label='Name',
            field_type='singleline',  # singleline field will be max_length 120
            required=True,
        )
        ExtendedFormField.objects.create(
            page=form_page,
            sort_order=1,
            label='Device IP Address',
            field_type='ipaddress',
            required=True,
        )

    def test_get_form(self):
        response = self.client.get('/support-request/')

        # Check response
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')
        self.assertContains(response, '<title>Support Request</title>', html=True)
        # check that max_length attribute has been passed into form
        self.assertContains(response, '<input type="text" name="name" required maxlength="120" id="id_name" />', html=True)
        # check ip address field has rendered
        self.assertContains(response, '<input type="text" name="device_ip_address" required id="id_device_ip_address" />', html=True)

    def test_post_invalid_form(self):
        response = self.client.post('/support-request/', {
            'name': 'very long name longer than 120 characters' * 3,  # invalid
            'device_ip_address': '192.0.2.30',  # valid
        })
        # Check response with invalid character count
        self.assertContains(response, 'Ensure this value has at most 120 characters (it has 123)')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')

        response = self.client.post('/support-request/', {
            'name': 'Ron Johnson',  # valid
            'device_ip_address': '3300.192.0.2.30',  # invalid
        })
        # Check response with invalid character count
        self.assertContains(response, 'Enter a valid IPv4 or IPv6 address.')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')

    def test_post_valid_form(self):
        response = self.client.post('/support-request/', {
            'name': 'Ron Johnson',
            'device_ip_address': '192.0.2.30',
        })

        # Check response
        self.assertContains(response, 'Thank you for submitting a Support Request.')
        self.assertContains(response, 'Ron Johnson')
        self.assertContains(response, '192.0.2.30')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')


class TestCleanedDataEmails(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_types_test_form_page()

    def test_empty_field_presence(self):
        self.client.post('/contact-us/', {})

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Single line text: ", mail.outbox[0].body)
        self.assertIn("Multiline: ", mail.outbox[0].body)
        self.assertIn("Email: ", mail.outbox[0].body)
        self.assertIn("Number: ", mail.outbox[0].body)
        self.assertIn("URL: ", mail.outbox[0].body)
        self.assertIn("Checkbox: ", mail.outbox[0].body)
        self.assertIn("Checkboxes: ", mail.outbox[0].body)
        self.assertIn("Drop down: ", mail.outbox[0].body)
        self.assertIn("Multiple select: ", mail.outbox[0].body)
        self.assertIn("Radio buttons: ", mail.outbox[0].body)
        self.assertIn("Date: ", mail.outbox[0].body)
        self.assertIn("Datetime: ", mail.outbox[0].body)

    def test_email_field_order(self):
        self.client.post('/contact-us/', {})

        line_beginnings = [
            "Single line text: ",
            "Multiline: ",
            "Email: ",
            "Number: ",
            "URL: ",
            "Checkbox: ",
            "Checkboxes: ",
            "Drop down: ",
            "Multiple select: ",
            "Radio buttons: ",
            "Date: ",
            "Datetime: ",
        ]

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        email_lines = mail.outbox[0].body.split('\n')

        for beginning in line_beginnings:
            message_line = email_lines.pop(0)
            self.assertTrue(message_line.startswith(beginning))

    @override_settings(SHORT_DATE_FORMAT='m/d/Y')
    def test_date_normalization(self):
        self.client.post('/contact-us/', {
            'date': '12/31/17',
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Date: 12/31/2017", mail.outbox[0].body)

        self.client.post('/contact-us/', {
            'date': '12/31/1917',
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 2)
        self.assertIn("Date: 12/31/1917", mail.outbox[1].body)


    @override_settings(SHORT_DATETIME_FORMAT='m/d/Y P')
    def test_datetime_normalization(self):
        self.client.post('/contact-us/', {
            'datetime': '12/31/17 4:00:00',
        })

        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Datetime: 12/31/2017 4 a.m.", mail.outbox[0].body)

        self.client.post('/contact-us/', {
            'datetime': '12/31/1917 21:19',
        })

        self.assertEqual(len(mail.outbox), 2)
        self.assertIn("Datetime: 12/31/1917 9:19 p.m.", mail.outbox[1].body)

        self.client.post('/contact-us/', {
            'datetime': '1910-12-21 21:19:12',
        })

        self.assertEqual(len(mail.outbox), 3)
        self.assertIn("Datetime: 12/21/1910 9:19 p.m.", mail.outbox[2].body)



class TestIssue798(TestCase):
    fixtures = ['test.json']

    def setUp(self):
        self.assertTrue(self.client.login(username='siteeditor', password='password'))
        self.form_page = Page.objects.get(url_path='/home/contact-us/').specific

        # Add a number field to the page
        FormField.objects.create(
            page=self.form_page,
            label="Your favourite number",
            field_type='number',
        )

    def test_post(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''},
            'your_favourite_number': '7.3',
        })

        # Check response
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # Check that form submission was saved correctly
        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='hello world').exists())
        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='7.3').exists())


class TestNonHtmlExtension(TestCase):
    fixtures = ['test.json']

    def test_non_html_extension(self):
        form_page = JadeFormPage(title="test")
        self.assertEqual(form_page.landing_page_template, "tests/form_page_landing.jade")


class TestLegacyFormFieldCleanNameChecks(TestCase):
    fixtures = ['test.json']

    def setUp(self):
        self.assertTrue(self.client.login(username='siteeditor', password='password'))
        self.form_page = Page.objects.get(url_path='/home/contact-us-one-more-time/').specific


    def test_form_field_clean_name_update_on_checks(self):

        fields_before_checks = [
            (field.label, field.clean_name,)
            for field in FormFieldWithCustomSubmission.objects.all()
        ]

        self.assertEqual(fields_before_checks, [
            ('Your email', ''),
            ('Your message', ''),
            ('Your choices', ''),
        ])

        # running checks should show an info message AND update blank clean_name values

        messages = FormFieldWithCustomSubmission.check()

        self.assertEqual(
            messages,
            [Info('Added `clean_name` on 3 form field(s)', obj=FormFieldWithCustomSubmission)]
        )


        fields_after_checks = [
            (field.label, field.clean_name,)
            for field in FormFieldWithCustomSubmission.objects.all()
        ]

        self.assertEqual(fields_after_checks, [
            ('Your email', 'your-email'),  # kebab case, legacy format
            ('Your message', 'your-message'),
            ('Your choices', 'your-choices'),
        ])

        # running checks again should return no messages as fields no longer need changing
        self.assertEqual(FormFieldWithCustomSubmission.check(), [])

        # creating a new field should use the non-legacy clean_name format

        field = FormFieldWithCustomSubmission.objects.create(
            page=self.form_page,
            label="Your FAVOURITE #number",
            field_type='number',
        )

        self.assertEqual(field.clean_name, 'your_favourite_number')



----- FILE: docs_reference_settings.rst (OLD) -----
========
Settings
========

Wagtail makes use of the following settings, in addition to :doc:`Django's core settings <ref/settings>`:

Site Name
=========

.. code-block:: python

  WAGTAIL_SITE_NAME = 'Stark Industries Skunkworks'

This is the human-readable name of your Wagtail install which welcomes users upon login to the Wagtail admin.

.. _append_slash:

Append Slash
============

.. code-block:: python

  # Don't add a trailing slash to Wagtail-served URLs
  WAGTAIL_APPEND_SLASH = False

Similar to Django's ``APPEND_SLASH``, this setting controls how Wagtail will handle requests that don't end in a trailing slash.

When ``WAGTAIL_APPEND_SLASH`` is ``True`` (default), requests to Wagtail pages which omit a trailing slash will be redirected by Django's :class:`~django.middleware.common.CommonMiddleware` to a URL with a trailing slash.

When ``WAGTAIL_APPEND_SLASH`` is ``False``, requests to Wagtail pages will be served both with and without trailing slashes. Page links generated by Wagtail, however, will not include trailing slashes.

.. note::

  If you use the ``False`` setting, keep in mind that serving your pages both with and without slashes may affect search engines' ability to index your site. See `this Google Webmaster Blog post`_ for more details.

.. _this Google Webmaster Blog post: https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html

Search
======

.. code-block:: python

  WAGTAILSEARCH_BACKENDS = {
      'default': {
          'BACKEND': 'wagtail.search.backends.elasticsearch2',
          'INDEX': 'myapp'
      }
  }

Define a search backend. For a full explanation, see :ref:`wagtailsearch_backends`.

.. code-block:: python

  WAGTAILSEARCH_RESULTS_TEMPLATE = 'myapp/search_results.html'
  WAGTAILSEARCH_RESULTS_TEMPLATE_AJAX = 'myapp/includes/search_listing.html'

Override the templates used by the search front-end views.

.. _wagtailsearch_hits_max_age:

.. code-block:: python

  WAGTAILSEARCH_HITS_MAX_AGE = 14

Set the number of days (default 7) that search query logs are kept for; these are used to identify popular search terms for :ref:`promoted search results <editors-picks>`. Queries older than this will be removed by the :ref:`search_garbage_collect` command.

Embeds
======

Wagtail supports generating embed code from URLs to content on an external
providers such as Youtube or Twitter. By default, Wagtail will fetch the embed
code directly from the relevant provider's site using the oEmbed protocol.
Wagtail has a builtin list of the most common providers.

The embeds fetching can be fully configured using the ``WAGTAILEMBEDS_FINDERS``
setting. This is fully documented in :ref:`configuring_embed_finders`.

.. code-block:: python

    WAGTAILEMBEDS_RESPONSIVE_HTML = True

Adds ``class="responsive-object"`` and an inline ``padding-bottom`` style to embeds,
to assist in making them responsive. See :ref:`responsive-embeds` for details.

Dashboard
=========

.. code-block:: python

    WAGTAILADMIN_RECENT_EDITS_LIMIT = 5

This setting lets you change the number of items shown at 'Your most recent edits' on the dashboard.


.. code-block:: python

  WAGTAILADMIN_USER_LOGIN_FORM = 'users.forms.LoginForm'

Allows the default ``LoginForm`` to be extended with extra fields.


.. _wagtail_gravatar_provider_url:

.. code-block:: python

  WAGTAIL_GRAVATAR_PROVIDER_URL = '//www.gravatar.com/avatar'

If a user has not uploaded a profile picture, Wagtail will look for an avatar linked to their email address on gravatar.com. This setting allows you to specify an alternative provider such as like robohash.org, or can be set to ``None`` to disable the use of remote avatars completely.

.. _wagtail_moderation_enabled:

.. code-block:: python

  WAGTAIL_MODERATION_ENABLED = True

Changes whether the Submit for Moderation button is displayed in the action menu.

Images
======

.. code-block:: python

  WAGTAILIMAGES_IMAGE_MODEL = 'myapp.MyImage'

This setting lets you provide your own image model for use in Wagtail, which might extend the built-in ``AbstractImage`` class or replace it entirely.


.. code-block:: python

    WAGTAILIMAGES_MAX_UPLOAD_SIZE = 20 * 1024 * 1024  # i.e. 20MB

This setting lets you override the maximum upload size for images (in bytes). If omitted, Wagtail will fall back to using its 10MB default value.

.. code-block:: python

    WAGTAILIMAGES_MAX_IMAGE_PIXELS = 128000000  # i.e. 128 megapixels

This setting lets you override the maximum number of pixels an image can have. If omitted, Wagtail will fall back to using its 128 megapixels default value. The pixel count takes animation frames into account - for example, a 25-frame animation of size 100x100 is considered to have 100 * 100 * 25 = 250000 pixels.

.. code-block:: python

    WAGTAILIMAGES_FEATURE_DETECTION_ENABLED = True

This setting enables feature detection once OpenCV is installed, see all details on the :ref:`image_feature_detection` documentation.

.. code-block:: python

    WAGTAILIMAGES_INDEX_PAGE_SIZE = 20

Specifies the number of images per page shown on the main Images listing in the Wagtail admin.

.. code-block:: python

    WAGTAILIMAGES_USAGE_PAGE_SIZE = 20

Specifies the number of items per page shown when viewing an image's usage (see :ref:`WAGTAIL_USAGE_COUNT_ENABLED <WAGTAIL_USAGE_COUNT_ENABLED>`).

.. code-block:: python

    WAGTAILIMAGES_CHOOSER_PAGE_SIZE = 12

Specifies the number of images shown per page in the image chooser modal.

Documents
=========

.. _wagtaildocs_serve_method:

.. code-block:: python

  WAGTAILDOCS_SERVE_METHOD = 'redirect'

Determines how document downloads will be linked to and served. Normally, requests for documents are sent through a Django view, to perform permission checks (see :ref:`image_document_permissions`) and potentially other housekeeping tasks such as hit counting. To fully protect against users bypassing this check, it needs to happen in the same request where the document is served; however, this incurs a performance hit as the document then needs to be served by the Django server. In particular, this cancels out much of the benefit of hosting documents on external storage, such as S3 or a CDN.

For this reason, Wagtail provides a number of serving methods which trade some of the strictness of the permission check for performance:

 * ``'direct'`` - links to documents point directly to the URL provided by the underlying storage, bypassing the Django view that provides the permission check. This is most useful when deploying sites as fully static HTML (e.g. using `wagtail-bakery <https://github.com/wagtail/wagtail-bakery>`_ or `Gatsby <https://www.gatsbyjs.org/>`_).
 * ``'redirect'`` - links to documents point to a Django view which will check the user's permission; if successful, it will redirect to the URL provided by the underlying storage to allow the document to be downloaded. This is most suitable for remote storage backends such as S3, as it allows the document to be served independently of the Django server. Note that if a user is able to guess the latter URL, they will be able to bypass the permission check; some storage backends may provide configuration options to generate a random or short-lived URL to mitigate this.
 * ``'serve_view'`` - links to documents point to a Django view which both checks the user's permission, and serves the document. Serving will be handled by `django-sendfile <https://github.com/johnsensible/django-sendfile>`_, if this is installed and supported by your server configuration, or as a streaming response from Django if not. When using this method, it is recommended that you configure your webserver to *disallow* serving documents directly from their location under ``MEDIA_ROOT``, as this would provide a way to bypass the permission check.

If ``WAGTAILDOCS_SERVE_METHOD`` is unspecified or set to ``None``, the default method is ``'redirect'`` when a remote storage backend is in use (i.e. one that exposes a URL but not a local filesystem path), and ``'serve_view'`` otherwise. Finally, some storage backends may not expose a URL at all; in this case, serving will proceed as for ``'serve_view'``.

Password Management
===================

.. code-block:: python

  WAGTAIL_PASSWORD_MANAGEMENT_ENABLED = True

This specifies whether users are allowed to change their passwords (enabled by default).

.. code-block:: python

  WAGTAIL_PASSWORD_RESET_ENABLED = True

This specifies whether users are allowed to reset their passwords. Defaults to the same as ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED``. Password reset emails will be sent from the address specified in Django's ``DEFAULT_FROM_EMAIL`` setting.

.. code-block:: python

  WAGTAILUSERS_PASSWORD_ENABLED = True

This specifies whether password fields are shown when creating or editing users through Settings -> Users (enabled by default). Set this to False (along with ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED`` and ``WAGTAIL_PASSWORD_RESET_ENABLED``) if your users are authenticated through an external system such as LDAP.

.. code-block:: python

  WAGTAILUSERS_PASSWORD_REQUIRED = True

This specifies whether password is a required field when creating a new user. True by default; ignored if ``WAGTAILUSERS_PASSWORD_ENABLED`` is false. If this is set to False, and the password field is left blank when creating a user, then that user will have no usable password; in order to log in, they will have to reset their password (if ``WAGTAIL_PASSWORD_RESET_ENABLED`` is True) or use an alternative authentication system such as LDAP (if one is set up).

.. code-block:: python

  WAGTAIL_EMAIL_MANAGEMENT_ENABLED = True

This specifies whether users are allowed to change their email (enabled by default).

.. _email_notifications:

Email Notifications
===================

.. code-block:: python

  WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = 'wagtail@myhost.io'

Wagtail sends email notifications when content is submitted for moderation, and when the content is accepted or rejected. This setting lets you pick which email address these automatic notifications will come from. If omitted, Wagtail will fall back to using Django's ``DEFAULT_FROM_EMAIL`` setting if set, or ``webmaster@localhost`` if not.

.. code-block:: python

  WAGTAILADMIN_NOTIFICATION_USE_HTML = True

Notification emails are sent in `text/plain` by default, change this to use HTML formatting.

.. code-block:: python

  WAGTAILADMIN_NOTIFICATION_INCLUDE_SUPERUSERS = False

Notification emails are sent to moderators and superusers by default. You can change this to exclude superusers and only notify moderators.

.. _update_notifications:

Wagtail update notifications
============================

.. code-block:: python

  WAGTAIL_ENABLE_UPDATE_CHECK = True

For admins only, Wagtail performs a check on the dashboard to see if newer releases are available. This also provides the Wagtail team with the hostname of your Wagtail site. If you'd rather not receive update notifications, or if you'd like your site to remain unknown, you can disable it with this setting.


Private pages / documents
=========================

.. code-block:: python

  PASSWORD_REQUIRED_TEMPLATE = 'myapp/password_required.html'

This is the path to the Django template which will be used to display the "password required" form when a user accesses a private page. For more details, see the :ref:`private_pages` documentation.

.. code-block:: python

  DOCUMENT_PASSWORD_REQUIRED_TEMPLATE = 'myapp/document_password_required.html'

As above, but for password restrictions on documents. For more details, see the :ref:`private_pages` documentation.

Login page
==========

The basic login page can be customised with a custom template.

.. code-block:: python

  WAGTAIL_FRONTEND_LOGIN_TEMPLATE = 'myapp/login.html'

Or the login page can be a redirect to an external or internal URL.

.. code-block:: python

  WAGTAIL_FRONTEND_LOGIN_URL = '/accounts/login/'

For more details, see the :ref:`login_page` documentation.

Case-Insensitive Tags
=====================

.. code-block:: python

  TAGGIT_CASE_INSENSITIVE = True

Tags are case-sensitive by default ('music' and 'Music' are treated as distinct tags). In many cases the reverse behaviour is preferable.

Multi-word tags
===============

.. code-block:: python

  TAG_SPACES_ALLOWED = False

Tags can only consist of a single word, no spaces allowed. The default setting is ``True`` (spaces in tags are allowed).

Tag limit
=========

.. code-block:: python

  TAG_LIMIT = 5

Limit the number of tags that can be added to (django-taggit) Tag model. Default setting is ``None``, meaning no limit on tags.

Unicode Page Slugs
==================

.. code-block:: python

  WAGTAIL_ALLOW_UNICODE_SLUGS = True

By default, page slugs can contain any alphanumeric characters, including non-Latin alphabets. Set this to False to limit slugs to ASCII characters.

.. _WAGTAIL_AUTO_UPDATE_PREVIEW:

Auto update preview
===================

.. code-block:: python

  WAGTAIL_AUTO_UPDATE_PREVIEW = False

When enabled, data from an edited page is automatically sent to the server
on each change, even without saving. That way, users don’t have to click on
“Preview” to update the content of the preview page. However, the preview page
tab is not refreshed automatically, users have to do it manually.
This behaviour is disabled by default.

Custom User Edit Forms
======================

See :doc:`/advanced_topics/customisation/custom_user_models`.

.. code-block:: python

  WAGTAIL_USER_EDIT_FORM = 'users.forms.CustomUserEditForm'

Allows the default ``UserEditForm`` class to be overridden with a custom form when
a custom user model is being used and extra fields are required in the user edit form.

.. code-block:: python

  WAGTAIL_USER_CREATION_FORM = 'users.forms.CustomUserCreationForm'

Allows the default ``UserCreationForm`` class to be overridden with a custom form when
a custom user model is being used and extra fields are required in the user creation form.

.. code-block:: python

  WAGTAIL_USER_CUSTOM_FIELDS = ['country']

A list of the extra custom fields to be appended to the default list.

.. _WAGTAIL_USAGE_COUNT_ENABLED:

Usage for images, documents and snippets
========================================

.. code-block:: python

    WAGTAIL_USAGE_COUNT_ENABLED = True

When enabled Wagtail shows where a particular image, document or snippet is being used on your site.
This is disabled by default because it generates a query which may run slowly on sites with large numbers of pages.

A link will appear on the edit page (in the rightmost column) showing you how many times the item is used.
Clicking this link takes you to the "Usage" page, which shows you where the snippet, document or image is used.

The link is also shown on the delete page, above the "Delete" button.

.. note::

    The usage count only applies to direct (database) references. Using documents, images and snippets within StreamFields or rich text fields will not be taken into account.

Date and DateTime inputs
========================

.. code-block:: python

    WAGTAIL_DATE_FORMAT = '%d.%m.%Y.'
    WAGTAIL_DATETIME_FORMAT = '%d.%m.%Y. %H:%M'
    WAGTAIL_TIME_FORMAT = '%H:%M'


Specifies the date, time and datetime format to be used in input fields in the Wagtail admin. The format is specified in `Python datetime module syntax <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_, and must be one of the recognised formats listed in the ``DATE_INPUT_FORMATS``, ``TIME_INPUT_FORMATS``, or ``DATETIME_INPUT_FORMATS`` setting respectively (see `DATE_INPUT_FORMATS <https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-DATE_INPUT_FORMATS>`_).

.. _WAGTAIL_USER_TIME_ZONES:

Time zones
==========

Logged-in users can choose their current time zone for the admin interface in the account settings.  If is no time zone selected by the user, then ``TIME_ZONE`` will be used.
(Note that time zones are only applied to datetime fields, not to plain time or date fields.  This is a Django design decision.)

The list of time zones is by default the common_timezones list from pytz.
It is possible to override this list via the ``WAGTAIL_USER_TIME_ZONES`` setting.
If there is zero or one time zone permitted, the account settings form will be hidden.

.. code-block:: python

    WAGTAIL_USER_TIME_ZONES = ['America/Chicago', 'Australia/Sydney', 'Europe/Rome']

.. _WAGTAILADMIN_PERMITTED_LANGUAGES:

Admin languages
===============

Users can choose between several languages for the admin interface
in the account settings. The list of languages is by default all the available
languages in Wagtail with at least 90% coverage. To change it, set ``WAGTAILADMIN_PERMITTED_LANGUAGES``:

.. code-block:: python

    WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),
                                        ('pt', 'Portuguese')]

Since the syntax is the same as Django ``LANGUAGES``, you can do this so users
can only choose between front office languages:

.. code-block:: python

    LANGUAGES = WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),
                                                    ('pt', 'Portuguese')]

Static files
============

.. code-block:: python

    WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS = False

Static file URLs within the Wagtail admin are given a version-specific query string of the form ``?v=1a2b3c4d``, to prevent outdated cached copies of Javascript and CSS files from persisting after a Wagtail upgrade. To disable these, set ``WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS`` to ``False``.

API Settings
============

For full documenation on API configuration, including these settings, see :ref:`api_v2_configuration` documentation.

.. code-block:: python

    WAGTAILAPI_BASE_URL = 'http://api.example.com/'

Required when using frontend cache invalidation, used to generate absolute URLs to document files and invalidating the cache.


.. code-block:: python

    WAGTAILAPI_LIMIT_MAX = 500

Default is 20, used to change the maximum number of results a user can request at a time, set to ``None`` for no limit.


.. code-block:: python

    WAGTAILAPI_SEARCH_ENABLED = False

Default is true, setting this to false will disable full text search on all endpoints.

.. code-block:: python

    WAGTAILAPI_USE_FRONTENDCACHE = True

Requires ``wagtailfrontendcache`` app to be installed, inidicates the API should use the frontend cache.

Frontend cache
==============

For full documenation on frontend cache invalidation, including these settings, see :ref:`frontend_cache_purging`.


.. code-block:: python

    WAGTAILFRONTENDCACHE = {
        'varnish': {
            'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',
            'LOCATION': 'http://localhost:8000',
        },
    }

See documentation linked above for full options available.

.. note::

    ``WAGTAILFRONTENDCACHE_LOCATION`` is no longer the preferred way to set the cache location, instead set the ``LOCATION`` within the ``WAGTAILFRONTENDCACHE`` item.


.. code-block:: python

    WAGTAILFRONTENDCACHE_LANGUAGES = [l[0] for l in settings.LANGUAGES]

Default is an empty list, must be a list of languages to also purge the urls for each language of a purging url. This setting needs ``settings.USE_I18N`` to be ``True`` to work.

.. _WAGTAILADMIN_RICH_TEXT_EDITORS:

Rich text
=========

.. code-block:: python

    WAGTAILADMIN_RICH_TEXT_EDITORS = {
        'default': {
            'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea',
            'OPTIONS': {
                'features': ['h2', 'bold', 'italic', 'link', 'document-link']
            }
        },
        'legacy': {
            'WIDGET': 'wagtail.admin.rich_text.HalloRichTextArea',
        }
    }

Customise the behaviour of rich text fields. By default, ``RichTextField`` and ``RichTextBlock`` use the configuration given under the ``'default'`` key, but this can be overridden on a per-field basis through the ``editor`` keyword argument, e.g. ``body = RichTextField(editor='legacy')``. Within each configuration block, the following fields are recognised:

 * ``WIDGET``: The rich text widget implementation to use. Wagtail provides two implementations: ``wagtail.admin.rich_text.DraftailRichTextArea`` (a modern extensible editor which enforces well-structured markup) and ``wagtail.admin.rich_text.HalloRichTextArea`` (deprecated; works directly at the HTML level). Other widgets may be provided by third-party packages.

 * ``OPTIONS``: Configuration options to pass to the widget. Recognised options are widget-specific, but both ``DraftailRichTextArea`` and ``HalloRichTextArea`` accept a ``features`` list indicating the active rich text features (see :ref:`rich_text_features`).

If a ``'default'`` editor is not specified, rich text fields that do not specify an ``editor`` argument will use the Draftail editor with the default feature set enabled.

.. versionchanged:: 2.10

    Omitting the ``'default'`` editor now leaves the original default editor intact, so it is no longer necessary to redefine ``'default'`` when adding alternative editors.


.. _WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK:

Page locking
============

``WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK`` can be set to ``True`` to prevent users
from editing pages that they have locked.

Redirects
=========

.. code-block:: python

   WAGTAIL_REDIRECTS_FILE_STORAGE = 'tmp_file'

By default the redirect importer keeps track of the uploaded file as a temp file, but on certain environments (load balanced/cloud environments), you cannot keep a shared file between environments. For those cases you can use the built-in cache to store the file instead.

.. code-block:: python

   WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'



----- FILE: wagtail_contrib_forms_tests_utils.py (OLD) -----
# -*- coding: utf-8 -*-
from wagtail.core.models import Page
from wagtail.tests.testapp.models import (
    FormField, FormFieldWithCustomSubmission, FormPage, FormPageWithCustomSubmission,
    FormPageWithRedirect, RedirectFormField)


def make_form_page(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPage(**kwargs))

    FormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


def make_form_page_with_custom_submission(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('intro', "<p>Boring intro text</p>")
    kwargs.setdefault('thank_you_text', "<p>Thank you for your patience!</p>")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))

    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


def make_form_page_with_redirect(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")


    home_page = Page.objects.get(url_path='/home/')
    kwargs.setdefault('thank_you_redirect_page', home_page)
    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))
    # form_page.thank_you_redirect_page = home_page

    RedirectFormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    RedirectFormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    RedirectFormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


def make_types_test_form_page(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPage(**kwargs))

    FormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Single line text",
        field_type='singleline',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Multiline",
        field_type='multiline',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Email",
        field_type='email',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=4,
        label="Number",
        field_type='number',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=5,
        label="URL",
        field_type='url',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=6,
        label="Checkbox",
        field_type='checkbox',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=7,
        label="Checkboxes",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=8,
        label="Drop down",
        field_type='dropdown',
        required=False,
        choices='spam,ham,eggs',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=9,
        label="Multiple select",
        field_type='multiselect',
        required=False,
        choices='qux,quux,quuz,corge',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=10,
        label="Radio buttons",
        field_type='radio',
        required=False,
        choices='wibble,wobble,wubble',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=11,
        label="Date",
        field_type='date',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=12,
        label="Datetime",
        field_type='datetime',
        required=False,
    )

    return form_page


### NEW VERSION FILES ###

----- FILE: wagtail_contrib_forms_forms.py (NEW) -----
from collections import OrderedDict

import django.forms
from django.conf import settings
from django.utils.html import conditional_escape
from django.utils.translation import gettext_lazy as _

from wagtail.admin.forms import WagtailAdminPageForm
from wagtail.contrib.forms.utils import get_field_clean_name


class BaseForm(django.forms.Form):
    def __init__(self, *args, **kwargs):
        kwargs.setdefault('label_suffix', '')

        self.user = kwargs.pop('user', None)
        self.page = kwargs.pop('page', None)

        super().__init__(*args, **kwargs)


class FormBuilder:
    def __init__(self, fields):
        self.fields = fields

    def create_singleline_field(self, field, options):
        # TODO: This is a default value - it may need to be changed
        options['max_length'] = 255
        return django.forms.CharField(**options)

    def create_multiline_field(self, field, options):
        return django.forms.CharField(widget=django.forms.Textarea, **options)

    def create_date_field(self, field, options):
        return django.forms.DateField(**options)

    def create_datetime_field(self, field, options):
        return django.forms.DateTimeField(**options)

    def create_email_field(self, field, options):
        return django.forms.EmailField(**options)

    def create_url_field(self, field, options):
        return django.forms.URLField(**options)

    def create_number_field(self, field, options):
        return django.forms.DecimalField(**options)

    def create_dropdown_field(self, field, options):
        options['choices'] = map(
            lambda x: (x.strip(), x.strip()),
            field.choices.split(',')
        )
        return django.forms.ChoiceField(**options)

    def create_multiselect_field(self, field, options):
        options['choices'] = map(
            lambda x: (x.strip(), x.strip()),
            field.choices.split(',')
        )
        return django.forms.MultipleChoiceField(**options)

    def create_radio_field(self, field, options):
        options['choices'] = map(
            lambda x: (x.strip(), x.strip()),
            field.choices.split(',')
        )
        return django.forms.ChoiceField(widget=django.forms.RadioSelect, **options)

    def create_checkboxes_field(self, field, options):
        options['choices'] = [(x.strip(), x.strip()) for x in field.choices.split(',')]
        options['initial'] = [x.strip() for x in field.default_value.split(',')]
        return django.forms.MultipleChoiceField(
            widget=django.forms.CheckboxSelectMultiple, **options
        )

    def create_checkbox_field(self, field, options):
        return django.forms.BooleanField(**options)

    def create_hidden_field(self, field, options):
        return django.forms.CharField(widget=django.forms.HiddenInput, **options)

    def get_create_field_function(self, type):
        """
            Takes string of field type and returns a Django Form Field Instance.
            Assumes form field creation functions are in the format:
            'create_fieldtype_field'
        """
        create_field_function = getattr(self, 'create_%s_field' % type, None)
        if create_field_function:
            return create_field_function
        else:
            import inspect
            method_list = [
                f[0] for f in
                inspect.getmembers(self.__class__, inspect.isfunction)
                if f[0].startswith('create_') and f[0].endswith('_field')
            ]
            raise AttributeError(
                "Could not find function matching format \
                create_<fieldname>_field for type: " + type,
                "Must be one of: " + ", ".join(method_list)
            )

    @property
    def formfields(self):
        formfields = OrderedDict()

        for field in self.fields:
            options = self.get_field_options(field)
            create_field = self.get_create_field_function(field.field_type)
            formfields[field.clean_name] = create_field(field, options)

        return formfields

    def get_field_options(self, field):
        options = {}
        options['label'] = field.label
        if getattr(settings, 'WAGTAILFORMS_HELP_TEXT_ALLOW_HTML', False):
            options['help_text'] = field.help_text
        else:
            options['help_text'] = conditional_escape(field.help_text)
        options['required'] = field.required
        options['initial'] = field.default_value
        return options

    def get_form_class(self):
        return type(str('WagtailForm'), (BaseForm,), self.formfields)


class SelectDateForm(django.forms.Form):
    date_from = django.forms.DateTimeField(
        required=False,
        widget=django.forms.DateInput(attrs={'placeholder': _('Date from')})
    )
    date_to = django.forms.DateTimeField(
        required=False,
        widget=django.forms.DateInput(attrs={'placeholder': _('Date to')})
    )


class WagtailAdminFormPageForm(WagtailAdminPageForm):

    def clean(self):

        super().clean()

        # Check for dupe form field labels - fixes #585
        if 'form_fields' in self.formsets:
            _forms = self.formsets['form_fields'].forms
            for f in _forms:
                f.is_valid()

            for i, form in enumerate(_forms):
                if 'label' in form.changed_data:
                    label = form.cleaned_data.get('label')
                    clean_name = get_field_clean_name(label)
                    for idx, ff in enumerate(_forms):
                        # Exclude self
                        ff_clean_name = get_field_clean_name(ff.cleaned_data.get('label'))
                        if idx != i and clean_name == ff_clean_name:
                            form.add_error(
                                'label',
                                django.forms.ValidationError(_('There is another field with the label %s, please change one of them.' % label))
                            )



----- FILE: wagtail_contrib_forms_tests_test_models.py (NEW) -----
# -*- coding: utf-8 -*-
import json

from django.core import mail
from django.core.checks import Info
from django.test import TestCase, override_settings

from wagtail.contrib.forms.models import FormSubmission
from wagtail.contrib.forms.tests.utils import (
    make_form_page, make_form_page_with_custom_submission, make_form_page_with_redirect,
    make_types_test_form_page)
from wagtail.core.models import Page
from wagtail.tests.testapp.models import (
    CustomFormPageSubmission, ExtendedFormField, FormField, FormFieldWithCustomSubmission,
    FormPageWithCustomFormBuilder, JadeFormPage)
from wagtail.tests.utils import WagtailTestUtils


class TestFormSubmission(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page()

    def test_get_form(self):
        response = self.client.get('/contact-us/')

        # Check response
        self.assertContains(response, """<label for="id_your_email">Your email</label>""")
        self.assertTemplateUsed(response, 'tests/form_page.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')

        # HTML in help text should be escaped
        self.assertContains(response, "&lt;em&gt;please&lt;/em&gt; be polite")

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

    @override_settings(WAGTAILFORMS_HELP_TEXT_ALLOW_HTML=True)
    def test_get_form_without_help_text_escaping(self):
        response = self.client.get('/contact-us/')
        # HTML in help text should not be escaped
        self.assertContains(response, "<em>please</em> be polite")

    def test_post_invalid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob',
            'your_message': 'hello world',
            'your_choices': ''
        })

        # Check response
        self.assertContains(response, "Enter a valid email address.")
        self.assertTemplateUsed(response, 'tests/form_page.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_landing.html')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # check the default form_submission is added to the context
        self.assertContains(response, "<li>your_email: bob@example.com</li>")

        # Check that an email was sent
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].to, ['to@email.com'])
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())

    def test_post_unicode_characters(self):
        self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'こんにちは、世界',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your message: こんにちは、世界", mail.outbox[0].body)

        # Check the form submission
        submission = FormSubmission.objects.get()
        submission_data = json.loads(submission.form_data)
        self.assertEqual(submission_data['your_message'], 'こんにちは、世界')

    def test_post_multiple_values(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # Check that the three checkbox values were saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        submission = FormSubmission.objects.filter(
            page=form_page, form_data__contains='hello world'
        )
        self.assertIn("foo", submission[0].form_data)
        self.assertIn("bar", submission[0].form_data)
        self.assertIn("baz", submission[0].form_data)

        # Check that the all the multiple checkbox values are serialised in the
        # email correctly
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("bar", mail.outbox[0].body)
        self.assertIn("foo", mail.outbox[0].body)
        self.assertIn("baz", mail.outbox[0].body)

    def test_post_blank_checkbox(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {},
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # Check that the checkbox was serialised in the email correctly
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your choices: ", mail.outbox[0].body)


class TestFormWithCustomSubmission(TestCase, WagtailTestUtils):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_custom_submission()

        self.user = self.login()

    def test_get_form(self):
        response = self.client.get('/contact-us/')

        # Check response
        self.assertContains(response, """<label for="id_your_email">Your email</label>""")
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)
        self.assertContains(response, '<p>Boring intro text</p>', html=True)

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

    def test_get_form_with_anonymous_user(self):
        self.client.logout()

        response = self.client.get('/contact-us/')

        # Check response
        self.assertNotContains(response, """<label for="id_your_email">Your email</label>""")
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertContains(response, '<div>You must log in first.</div>', html=True)
        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

    def test_post_invalid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob',
            'your_message': 'hello world',
            'your_choices': ''
        })

        # Check response
        self.assertContains(response, "Enter a valid email address.")
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # check that the custom form_submission is added to the context
        self.assertContains(response, "<p>Username: test@email.com</p>")

        # Check that an email was sent
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].to, ['to@email.com'])
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())

    def test_post_form_twice(self):
        # First submission
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertContains(response, '<p>Thank you for your patience!</p>', html=True)
        self.assertNotContains(response, '<div>The form is already filled.</div>', html=True)

        # Check that first form submission was saved correctly
        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)
        self.assertEqual(submissions_qs.count(), 1)
        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())

        # Second submission
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission_landing.html')
        self.assertNotContains(response, '<p>Thank you for your patience!</p>', html=True)
        self.assertContains(response, '<div>The form is already filled.</div>', html=True)
        self.assertNotContains(response, '<div>You must log in first.</div>', html=True)
        self.assertNotContains(response, '<p>Boring intro text</p>', html=True)

        # Check that first submission exists and second submission wasn't saved
        submissions_qs = CustomFormPageSubmission.objects.filter(user=self.user, page=self.form_page)
        self.assertEqual(submissions_qs.count(), 1)
        self.assertTrue(submissions_qs.filter(form_data__contains='hello world').exists())
        self.assertFalse(submissions_qs.filter(form_data__contains='hello cruel world').exists())

    def test_post_unicode_characters(self):
        self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'こんにちは、世界',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your message: こんにちは、世界", mail.outbox[0].body)

        # Check the form submission
        submission = CustomFormPageSubmission.objects.get()
        submission_data = json.loads(submission.form_data)
        self.assertEqual(submission_data['your_message'], 'こんにちは、世界')

    def test_post_multiple_values(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': 'on', 'bar': 'on', 'baz': 'on'}
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # Check that the three checkbox values were saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        submission = CustomFormPageSubmission.objects.filter(
            page=form_page, form_data__contains='hello world'
        )
        self.assertIn("foo", submission[0].form_data)
        self.assertIn("bar", submission[0].form_data)
        self.assertIn("baz", submission[0].form_data)

    def test_post_blank_checkbox(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {},
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # Check that the checkbox was serialised in the email correctly
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Your choices: None", mail.outbox[0].body)


class TestFormSubmissionWithMultipleRecipients(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page(to_address='to@email.com, another@email.com')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your feedback.")
        self.assertTemplateNotUsed(response, 'tests/form_page.html')
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # Check that one email was sent, but to two recipients
        self.assertEqual(len(mail.outbox), 1)

        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')
        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())


class TestFormSubmissionWithMultipleRecipientsAndWithCustomSubmission(TestCase, WagtailTestUtils):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_custom_submission(
            to_address='to@email.com, another@email.com'
        )

        self.user = self.login()

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertContains(response, "Thank you for your patience!")
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_submission.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_submission_landing.html')

        # check that variables defined in get_context are passed through to the template (#1429)
        self.assertContains(response, "<p>hello world</p>")

        # Check that one email was sent, but to two recipients
        self.assertEqual(len(mail.outbox), 1)

        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')
        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(
            CustomFormPageSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists()
        )


class TestFormWithRedirect(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_form_page_with_redirect(to_address='to@email.com, another@email.com')

    def test_post_valid_form(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''}
        })

        # Check response
        self.assertRedirects(response, '/')

        # Check that one email was sent, but to two recipients
        self.assertEqual(len(mail.outbox), 1)

        self.assertEqual(mail.outbox[0].subject, "The subject")
        self.assertIn("Your message: hello world", mail.outbox[0].body)
        self.assertEqual(mail.outbox[0].from_email, 'from@email.com')
        self.assertEqual(set(mail.outbox[0].to), {'to@email.com', 'another@email.com'})

        # Check that form submission was saved correctly
        form_page = Page.objects.get(url_path='/home/contact-us/')
        self.assertTrue(FormSubmission.objects.filter(page=form_page, form_data__contains='hello world').exists())


class TestFormPageWithCustomFormBuilder(TestCase, WagtailTestUtils):

    def setUp(self):

        home_page = Page.objects.get(url_path='/home/')
        form_page = home_page.add_child(
            instance=FormPageWithCustomFormBuilder(
                title='Support Request',
                slug='support-request',
                to_address='it@jenkins.com',
                from_address='support@jenkins.com',
                subject='Support Request Submitted',
            )
        )
        ExtendedFormField.objects.create(
            page=form_page,
            sort_order=1,
            label='Name',
            field_type='singleline',  # singleline field will be max_length 120
            required=True,
        )
        ExtendedFormField.objects.create(
            page=form_page,
            sort_order=1,
            label='Device IP Address',
            field_type='ipaddress',
            required=True,
        )

    def test_get_form(self):
        response = self.client.get('/support-request/')

        # Check response
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')
        self.assertContains(response, '<title>Support Request</title>', html=True)
        # check that max_length attribute has been passed into form
        self.assertContains(response, '<input type="text" name="name" required maxlength="120" id="id_name" />', html=True)
        # check ip address field has rendered
        self.assertContains(response, '<input type="text" name="device_ip_address" required id="id_device_ip_address" />', html=True)

    def test_post_invalid_form(self):
        response = self.client.post('/support-request/', {
            'name': 'very long name longer than 120 characters' * 3,  # invalid
            'device_ip_address': '192.0.2.30',  # valid
        })
        # Check response with invalid character count
        self.assertContains(response, 'Ensure this value has at most 120 characters (it has 123)')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')

        response = self.client.post('/support-request/', {
            'name': 'Ron Johnson',  # valid
            'device_ip_address': '3300.192.0.2.30',  # invalid
        })
        # Check response with invalid character count
        self.assertContains(response, 'Enter a valid IPv4 or IPv6 address.')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')

    def test_post_valid_form(self):
        response = self.client.post('/support-request/', {
            'name': 'Ron Johnson',
            'device_ip_address': '192.0.2.30',
        })

        # Check response
        self.assertContains(response, 'Thank you for submitting a Support Request.')
        self.assertContains(response, 'Ron Johnson')
        self.assertContains(response, '192.0.2.30')
        self.assertTemplateNotUsed(response, 'tests/form_page_with_custom_form_builder.html')
        self.assertTemplateUsed(response, 'tests/form_page_with_custom_form_builder_landing.html')


class TestCleanedDataEmails(TestCase):
    def setUp(self):
        # Create a form page
        self.form_page = make_types_test_form_page()

    def test_empty_field_presence(self):
        self.client.post('/contact-us/', {})

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Single line text: ", mail.outbox[0].body)
        self.assertIn("Multiline: ", mail.outbox[0].body)
        self.assertIn("Email: ", mail.outbox[0].body)
        self.assertIn("Number: ", mail.outbox[0].body)
        self.assertIn("URL: ", mail.outbox[0].body)
        self.assertIn("Checkbox: ", mail.outbox[0].body)
        self.assertIn("Checkboxes: ", mail.outbox[0].body)
        self.assertIn("Drop down: ", mail.outbox[0].body)
        self.assertIn("Multiple select: ", mail.outbox[0].body)
        self.assertIn("Radio buttons: ", mail.outbox[0].body)
        self.assertIn("Date: ", mail.outbox[0].body)
        self.assertIn("Datetime: ", mail.outbox[0].body)

    def test_email_field_order(self):
        self.client.post('/contact-us/', {})

        line_beginnings = [
            "Single line text: ",
            "Multiline: ",
            "Email: ",
            "Number: ",
            "URL: ",
            "Checkbox: ",
            "Checkboxes: ",
            "Drop down: ",
            "Multiple select: ",
            "Radio buttons: ",
            "Date: ",
            "Datetime: ",
        ]

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        email_lines = mail.outbox[0].body.split('\n')

        for beginning in line_beginnings:
            message_line = email_lines.pop(0)
            self.assertTrue(message_line.startswith(beginning))

    @override_settings(SHORT_DATE_FORMAT='m/d/Y')
    def test_date_normalization(self):
        self.client.post('/contact-us/', {
            'date': '12/31/17',
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Date: 12/31/2017", mail.outbox[0].body)

        self.client.post('/contact-us/', {
            'date': '12/31/1917',
        })

        # Check the email
        self.assertEqual(len(mail.outbox), 2)
        self.assertIn("Date: 12/31/1917", mail.outbox[1].body)


    @override_settings(SHORT_DATETIME_FORMAT='m/d/Y P')
    def test_datetime_normalization(self):
        self.client.post('/contact-us/', {
            'datetime': '12/31/17 4:00:00',
        })

        self.assertEqual(len(mail.outbox), 1)
        self.assertIn("Datetime: 12/31/2017 4 a.m.", mail.outbox[0].body)

        self.client.post('/contact-us/', {
            'datetime': '12/31/1917 21:19',
        })

        self.assertEqual(len(mail.outbox), 2)
        self.assertIn("Datetime: 12/31/1917 9:19 p.m.", mail.outbox[1].body)

        self.client.post('/contact-us/', {
            'datetime': '1910-12-21 21:19:12',
        })

        self.assertEqual(len(mail.outbox), 3)
        self.assertIn("Datetime: 12/21/1910 9:19 p.m.", mail.outbox[2].body)



class TestIssue798(TestCase):
    fixtures = ['test.json']

    def setUp(self):
        self.assertTrue(self.client.login(username='siteeditor', password='password'))
        self.form_page = Page.objects.get(url_path='/home/contact-us/').specific

        # Add a number field to the page
        FormField.objects.create(
            page=self.form_page,
            label="Your favourite number",
            field_type='number',
        )

    def test_post(self):
        response = self.client.post('/contact-us/', {
            'your_email': 'bob@example.com',
            'your_message': 'hello world',
            'your_choices': {'foo': '', 'bar': '', 'baz': ''},
            'your_favourite_number': '7.3',
        })

        # Check response
        self.assertTemplateUsed(response, 'tests/form_page_landing.html')

        # Check that form submission was saved correctly
        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='hello world').exists())
        self.assertTrue(FormSubmission.objects.filter(page=self.form_page, form_data__contains='7.3').exists())


class TestNonHtmlExtension(TestCase):
    fixtures = ['test.json']

    def test_non_html_extension(self):
        form_page = JadeFormPage(title="test")
        self.assertEqual(form_page.landing_page_template, "tests/form_page_landing.jade")


class TestLegacyFormFieldCleanNameChecks(TestCase):
    fixtures = ['test.json']

    def setUp(self):
        self.assertTrue(self.client.login(username='siteeditor', password='password'))
        self.form_page = Page.objects.get(url_path='/home/contact-us-one-more-time/').specific


    def test_form_field_clean_name_update_on_checks(self):

        fields_before_checks = [
            (field.label, field.clean_name,)
            for field in FormFieldWithCustomSubmission.objects.all()
        ]

        self.assertEqual(fields_before_checks, [
            ('Your email', ''),
            ('Your message', ''),
            ('Your choices', ''),
        ])

        # running checks should show an info message AND update blank clean_name values

        messages = FormFieldWithCustomSubmission.check()

        self.assertEqual(
            messages,
            [Info('Added `clean_name` on 3 form field(s)', obj=FormFieldWithCustomSubmission)]
        )


        fields_after_checks = [
            (field.label, field.clean_name,)
            for field in FormFieldWithCustomSubmission.objects.all()
        ]

        self.assertEqual(fields_after_checks, [
            ('Your email', 'your-email'),  # kebab case, legacy format
            ('Your message', 'your-message'),
            ('Your choices', 'your-choices'),
        ])

        # running checks again should return no messages as fields no longer need changing
        self.assertEqual(FormFieldWithCustomSubmission.check(), [])

        # creating a new field should use the non-legacy clean_name format

        field = FormFieldWithCustomSubmission.objects.create(
            page=self.form_page,
            label="Your FAVOURITE #number",
            field_type='number',
        )

        self.assertEqual(field.clean_name, 'your_favourite_number')



----- FILE: docs_reference_settings.rst (NEW) -----
========
Settings
========

Wagtail makes use of the following settings, in addition to :doc:`Django's core settings <ref/settings>`:

Site Name
=========

.. code-block:: python

  WAGTAIL_SITE_NAME = 'Stark Industries Skunkworks'

This is the human-readable name of your Wagtail install which welcomes users upon login to the Wagtail admin.

.. _append_slash:

Append Slash
============

.. code-block:: python

  # Don't add a trailing slash to Wagtail-served URLs
  WAGTAIL_APPEND_SLASH = False

Similar to Django's ``APPEND_SLASH``, this setting controls how Wagtail will handle requests that don't end in a trailing slash.

When ``WAGTAIL_APPEND_SLASH`` is ``True`` (default), requests to Wagtail pages which omit a trailing slash will be redirected by Django's :class:`~django.middleware.common.CommonMiddleware` to a URL with a trailing slash.

When ``WAGTAIL_APPEND_SLASH`` is ``False``, requests to Wagtail pages will be served both with and without trailing slashes. Page links generated by Wagtail, however, will not include trailing slashes.

.. note::

  If you use the ``False`` setting, keep in mind that serving your pages both with and without slashes may affect search engines' ability to index your site. See `this Google Webmaster Blog post`_ for more details.

.. _this Google Webmaster Blog post: https://webmasters.googleblog.com/2010/04/to-slash-or-not-to-slash.html

Search
======

.. code-block:: python

  WAGTAILSEARCH_BACKENDS = {
      'default': {
          'BACKEND': 'wagtail.search.backends.elasticsearch2',
          'INDEX': 'myapp'
      }
  }

Define a search backend. For a full explanation, see :ref:`wagtailsearch_backends`.

.. code-block:: python

  WAGTAILSEARCH_RESULTS_TEMPLATE = 'myapp/search_results.html'
  WAGTAILSEARCH_RESULTS_TEMPLATE_AJAX = 'myapp/includes/search_listing.html'

Override the templates used by the search front-end views.

.. _wagtailsearch_hits_max_age:

.. code-block:: python

  WAGTAILSEARCH_HITS_MAX_AGE = 14

Set the number of days (default 7) that search query logs are kept for; these are used to identify popular search terms for :ref:`promoted search results <editors-picks>`. Queries older than this will be removed by the :ref:`search_garbage_collect` command.

Embeds
======

Wagtail supports generating embed code from URLs to content on an external
providers such as Youtube or Twitter. By default, Wagtail will fetch the embed
code directly from the relevant provider's site using the oEmbed protocol.
Wagtail has a builtin list of the most common providers.

The embeds fetching can be fully configured using the ``WAGTAILEMBEDS_FINDERS``
setting. This is fully documented in :ref:`configuring_embed_finders`.

.. code-block:: python

    WAGTAILEMBEDS_RESPONSIVE_HTML = True

Adds ``class="responsive-object"`` and an inline ``padding-bottom`` style to embeds,
to assist in making them responsive. See :ref:`responsive-embeds` for details.

Dashboard
=========

.. code-block:: python

    WAGTAILADMIN_RECENT_EDITS_LIMIT = 5

This setting lets you change the number of items shown at 'Your most recent edits' on the dashboard.


.. code-block:: python

  WAGTAILADMIN_USER_LOGIN_FORM = 'users.forms.LoginForm'

Allows the default ``LoginForm`` to be extended with extra fields.


.. _wagtail_gravatar_provider_url:

.. code-block:: python

  WAGTAIL_GRAVATAR_PROVIDER_URL = '//www.gravatar.com/avatar'

If a user has not uploaded a profile picture, Wagtail will look for an avatar linked to their email address on gravatar.com. This setting allows you to specify an alternative provider such as like robohash.org, or can be set to ``None`` to disable the use of remote avatars completely.

.. _wagtail_moderation_enabled:

.. code-block:: python

  WAGTAIL_MODERATION_ENABLED = True

Changes whether the Submit for Moderation button is displayed in the action menu.

Images
======

.. code-block:: python

  WAGTAILIMAGES_IMAGE_MODEL = 'myapp.MyImage'

This setting lets you provide your own image model for use in Wagtail, which might extend the built-in ``AbstractImage`` class or replace it entirely.


.. code-block:: python

    WAGTAILIMAGES_MAX_UPLOAD_SIZE = 20 * 1024 * 1024  # i.e. 20MB

This setting lets you override the maximum upload size for images (in bytes). If omitted, Wagtail will fall back to using its 10MB default value.

.. code-block:: python

    WAGTAILIMAGES_MAX_IMAGE_PIXELS = 128000000  # i.e. 128 megapixels

This setting lets you override the maximum number of pixels an image can have. If omitted, Wagtail will fall back to using its 128 megapixels default value. The pixel count takes animation frames into account - for example, a 25-frame animation of size 100x100 is considered to have 100 * 100 * 25 = 250000 pixels.

.. code-block:: python

    WAGTAILIMAGES_FEATURE_DETECTION_ENABLED = True

This setting enables feature detection once OpenCV is installed, see all details on the :ref:`image_feature_detection` documentation.

.. code-block:: python

    WAGTAILIMAGES_INDEX_PAGE_SIZE = 20

Specifies the number of images per page shown on the main Images listing in the Wagtail admin.

.. code-block:: python

    WAGTAILIMAGES_USAGE_PAGE_SIZE = 20

Specifies the number of items per page shown when viewing an image's usage (see :ref:`WAGTAIL_USAGE_COUNT_ENABLED <WAGTAIL_USAGE_COUNT_ENABLED>`).

.. code-block:: python

    WAGTAILIMAGES_CHOOSER_PAGE_SIZE = 12

Specifies the number of images shown per page in the image chooser modal.

Documents
=========

.. _wagtaildocs_serve_method:

.. code-block:: python

  WAGTAILDOCS_SERVE_METHOD = 'redirect'

Determines how document downloads will be linked to and served. Normally, requests for documents are sent through a Django view, to perform permission checks (see :ref:`image_document_permissions`) and potentially other housekeeping tasks such as hit counting. To fully protect against users bypassing this check, it needs to happen in the same request where the document is served; however, this incurs a performance hit as the document then needs to be served by the Django server. In particular, this cancels out much of the benefit of hosting documents on external storage, such as S3 or a CDN.

For this reason, Wagtail provides a number of serving methods which trade some of the strictness of the permission check for performance:

 * ``'direct'`` - links to documents point directly to the URL provided by the underlying storage, bypassing the Django view that provides the permission check. This is most useful when deploying sites as fully static HTML (e.g. using `wagtail-bakery <https://github.com/wagtail/wagtail-bakery>`_ or `Gatsby <https://www.gatsbyjs.org/>`_).
 * ``'redirect'`` - links to documents point to a Django view which will check the user's permission; if successful, it will redirect to the URL provided by the underlying storage to allow the document to be downloaded. This is most suitable for remote storage backends such as S3, as it allows the document to be served independently of the Django server. Note that if a user is able to guess the latter URL, they will be able to bypass the permission check; some storage backends may provide configuration options to generate a random or short-lived URL to mitigate this.
 * ``'serve_view'`` - links to documents point to a Django view which both checks the user's permission, and serves the document. Serving will be handled by `django-sendfile <https://github.com/johnsensible/django-sendfile>`_, if this is installed and supported by your server configuration, or as a streaming response from Django if not. When using this method, it is recommended that you configure your webserver to *disallow* serving documents directly from their location under ``MEDIA_ROOT``, as this would provide a way to bypass the permission check.

If ``WAGTAILDOCS_SERVE_METHOD`` is unspecified or set to ``None``, the default method is ``'redirect'`` when a remote storage backend is in use (i.e. one that exposes a URL but not a local filesystem path), and ``'serve_view'`` otherwise. Finally, some storage backends may not expose a URL at all; in this case, serving will proceed as for ``'serve_view'``.

Password Management
===================

.. code-block:: python

  WAGTAIL_PASSWORD_MANAGEMENT_ENABLED = True

This specifies whether users are allowed to change their passwords (enabled by default).

.. code-block:: python

  WAGTAIL_PASSWORD_RESET_ENABLED = True

This specifies whether users are allowed to reset their passwords. Defaults to the same as ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED``. Password reset emails will be sent from the address specified in Django's ``DEFAULT_FROM_EMAIL`` setting.

.. code-block:: python

  WAGTAILUSERS_PASSWORD_ENABLED = True

This specifies whether password fields are shown when creating or editing users through Settings -> Users (enabled by default). Set this to False (along with ``WAGTAIL_PASSWORD_MANAGEMENT_ENABLED`` and ``WAGTAIL_PASSWORD_RESET_ENABLED``) if your users are authenticated through an external system such as LDAP.

.. code-block:: python

  WAGTAILUSERS_PASSWORD_REQUIRED = True

This specifies whether password is a required field when creating a new user. True by default; ignored if ``WAGTAILUSERS_PASSWORD_ENABLED`` is false. If this is set to False, and the password field is left blank when creating a user, then that user will have no usable password; in order to log in, they will have to reset their password (if ``WAGTAIL_PASSWORD_RESET_ENABLED`` is True) or use an alternative authentication system such as LDAP (if one is set up).

.. code-block:: python

  WAGTAIL_EMAIL_MANAGEMENT_ENABLED = True

This specifies whether users are allowed to change their email (enabled by default).

.. _email_notifications:

Email Notifications
===================

.. code-block:: python

  WAGTAILADMIN_NOTIFICATION_FROM_EMAIL = 'wagtail@myhost.io'

Wagtail sends email notifications when content is submitted for moderation, and when the content is accepted or rejected. This setting lets you pick which email address these automatic notifications will come from. If omitted, Wagtail will fall back to using Django's ``DEFAULT_FROM_EMAIL`` setting if set, or ``webmaster@localhost`` if not.

.. code-block:: python

  WAGTAILADMIN_NOTIFICATION_USE_HTML = True

Notification emails are sent in `text/plain` by default, change this to use HTML formatting.

.. code-block:: python

  WAGTAILADMIN_NOTIFICATION_INCLUDE_SUPERUSERS = False

Notification emails are sent to moderators and superusers by default. You can change this to exclude superusers and only notify moderators.

.. _update_notifications:

Wagtail update notifications
============================

.. code-block:: python

  WAGTAIL_ENABLE_UPDATE_CHECK = True

For admins only, Wagtail performs a check on the dashboard to see if newer releases are available. This also provides the Wagtail team with the hostname of your Wagtail site. If you'd rather not receive update notifications, or if you'd like your site to remain unknown, you can disable it with this setting.


Private pages / documents
=========================

.. code-block:: python

  PASSWORD_REQUIRED_TEMPLATE = 'myapp/password_required.html'

This is the path to the Django template which will be used to display the "password required" form when a user accesses a private page. For more details, see the :ref:`private_pages` documentation.

.. code-block:: python

  DOCUMENT_PASSWORD_REQUIRED_TEMPLATE = 'myapp/document_password_required.html'

As above, but for password restrictions on documents. For more details, see the :ref:`private_pages` documentation.

Login page
==========

The basic login page can be customised with a custom template.

.. code-block:: python

  WAGTAIL_FRONTEND_LOGIN_TEMPLATE = 'myapp/login.html'

Or the login page can be a redirect to an external or internal URL.

.. code-block:: python

  WAGTAIL_FRONTEND_LOGIN_URL = '/accounts/login/'

For more details, see the :ref:`login_page` documentation.

Case-Insensitive Tags
=====================

.. code-block:: python

  TAGGIT_CASE_INSENSITIVE = True

Tags are case-sensitive by default ('music' and 'Music' are treated as distinct tags). In many cases the reverse behaviour is preferable.

Multi-word tags
===============

.. code-block:: python

  TAG_SPACES_ALLOWED = False

Tags can only consist of a single word, no spaces allowed. The default setting is ``True`` (spaces in tags are allowed).

Tag limit
=========

.. code-block:: python

  TAG_LIMIT = 5

Limit the number of tags that can be added to (django-taggit) Tag model. Default setting is ``None``, meaning no limit on tags.

Unicode Page Slugs
==================

.. code-block:: python

  WAGTAIL_ALLOW_UNICODE_SLUGS = True

By default, page slugs can contain any alphanumeric characters, including non-Latin alphabets. Set this to False to limit slugs to ASCII characters.

.. _WAGTAIL_AUTO_UPDATE_PREVIEW:

Auto update preview
===================

.. code-block:: python

  WAGTAIL_AUTO_UPDATE_PREVIEW = False

When enabled, data from an edited page is automatically sent to the server
on each change, even without saving. That way, users don’t have to click on
“Preview” to update the content of the preview page. However, the preview page
tab is not refreshed automatically, users have to do it manually.
This behaviour is disabled by default.

Custom User Edit Forms
======================

See :doc:`/advanced_topics/customisation/custom_user_models`.

.. code-block:: python

  WAGTAIL_USER_EDIT_FORM = 'users.forms.CustomUserEditForm'

Allows the default ``UserEditForm`` class to be overridden with a custom form when
a custom user model is being used and extra fields are required in the user edit form.

.. code-block:: python

  WAGTAIL_USER_CREATION_FORM = 'users.forms.CustomUserCreationForm'

Allows the default ``UserCreationForm`` class to be overridden with a custom form when
a custom user model is being used and extra fields are required in the user creation form.

.. code-block:: python

  WAGTAIL_USER_CUSTOM_FIELDS = ['country']

A list of the extra custom fields to be appended to the default list.

.. _WAGTAIL_USAGE_COUNT_ENABLED:

Usage for images, documents and snippets
========================================

.. code-block:: python

    WAGTAIL_USAGE_COUNT_ENABLED = True

When enabled Wagtail shows where a particular image, document or snippet is being used on your site.
This is disabled by default because it generates a query which may run slowly on sites with large numbers of pages.

A link will appear on the edit page (in the rightmost column) showing you how many times the item is used.
Clicking this link takes you to the "Usage" page, which shows you where the snippet, document or image is used.

The link is also shown on the delete page, above the "Delete" button.

.. note::

    The usage count only applies to direct (database) references. Using documents, images and snippets within StreamFields or rich text fields will not be taken into account.

Date and DateTime inputs
========================

.. code-block:: python

    WAGTAIL_DATE_FORMAT = '%d.%m.%Y.'
    WAGTAIL_DATETIME_FORMAT = '%d.%m.%Y. %H:%M'
    WAGTAIL_TIME_FORMAT = '%H:%M'


Specifies the date, time and datetime format to be used in input fields in the Wagtail admin. The format is specified in `Python datetime module syntax <https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior>`_, and must be one of the recognised formats listed in the ``DATE_INPUT_FORMATS``, ``TIME_INPUT_FORMATS``, or ``DATETIME_INPUT_FORMATS`` setting respectively (see `DATE_INPUT_FORMATS <https://docs.djangoproject.com/en/stable/ref/settings/#std:setting-DATE_INPUT_FORMATS>`_).

.. _WAGTAIL_USER_TIME_ZONES:

Time zones
==========

Logged-in users can choose their current time zone for the admin interface in the account settings.  If is no time zone selected by the user, then ``TIME_ZONE`` will be used.
(Note that time zones are only applied to datetime fields, not to plain time or date fields.  This is a Django design decision.)

The list of time zones is by default the common_timezones list from pytz.
It is possible to override this list via the ``WAGTAIL_USER_TIME_ZONES`` setting.
If there is zero or one time zone permitted, the account settings form will be hidden.

.. code-block:: python

    WAGTAIL_USER_TIME_ZONES = ['America/Chicago', 'Australia/Sydney', 'Europe/Rome']

.. _WAGTAILADMIN_PERMITTED_LANGUAGES:

Admin languages
===============

Users can choose between several languages for the admin interface
in the account settings. The list of languages is by default all the available
languages in Wagtail with at least 90% coverage. To change it, set ``WAGTAILADMIN_PERMITTED_LANGUAGES``:

.. code-block:: python

    WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),
                                        ('pt', 'Portuguese')]

Since the syntax is the same as Django ``LANGUAGES``, you can do this so users
can only choose between front office languages:

.. code-block:: python

    LANGUAGES = WAGTAILADMIN_PERMITTED_LANGUAGES = [('en', 'English'),
                                                    ('pt', 'Portuguese')]

Static files
============

.. code-block:: python

    WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS = False

Static file URLs within the Wagtail admin are given a version-specific query string of the form ``?v=1a2b3c4d``, to prevent outdated cached copies of Javascript and CSS files from persisting after a Wagtail upgrade. To disable these, set ``WAGTAILADMIN_STATIC_FILE_VERSION_STRINGS`` to ``False``.

API Settings
============

For full documenation on API configuration, including these settings, see :ref:`api_v2_configuration` documentation.

.. code-block:: python

    WAGTAILAPI_BASE_URL = 'http://api.example.com/'

Required when using frontend cache invalidation, used to generate absolute URLs to document files and invalidating the cache.


.. code-block:: python

    WAGTAILAPI_LIMIT_MAX = 500

Default is 20, used to change the maximum number of results a user can request at a time, set to ``None`` for no limit.


.. code-block:: python

    WAGTAILAPI_SEARCH_ENABLED = False

Default is true, setting this to false will disable full text search on all endpoints.

.. code-block:: python

    WAGTAILAPI_USE_FRONTENDCACHE = True

Requires ``wagtailfrontendcache`` app to be installed, inidicates the API should use the frontend cache.

Frontend cache
==============

For full documenation on frontend cache invalidation, including these settings, see :ref:`frontend_cache_purging`.


.. code-block:: python

    WAGTAILFRONTENDCACHE = {
        'varnish': {
            'BACKEND': 'wagtail.contrib.frontend_cache.backends.HTTPBackend',
            'LOCATION': 'http://localhost:8000',
        },
    }

See documentation linked above for full options available.

.. note::

    ``WAGTAILFRONTENDCACHE_LOCATION`` is no longer the preferred way to set the cache location, instead set the ``LOCATION`` within the ``WAGTAILFRONTENDCACHE`` item.


.. code-block:: python

    WAGTAILFRONTENDCACHE_LANGUAGES = [l[0] for l in settings.LANGUAGES]

Default is an empty list, must be a list of languages to also purge the urls for each language of a purging url. This setting needs ``settings.USE_I18N`` to be ``True`` to work.

.. _WAGTAILADMIN_RICH_TEXT_EDITORS:

Rich text
=========

.. code-block:: python

    WAGTAILADMIN_RICH_TEXT_EDITORS = {
        'default': {
            'WIDGET': 'wagtail.admin.rich_text.DraftailRichTextArea',
            'OPTIONS': {
                'features': ['h2', 'bold', 'italic', 'link', 'document-link']
            }
        },
        'legacy': {
            'WIDGET': 'wagtail.admin.rich_text.HalloRichTextArea',
        }
    }

Customise the behaviour of rich text fields. By default, ``RichTextField`` and ``RichTextBlock`` use the configuration given under the ``'default'`` key, but this can be overridden on a per-field basis through the ``editor`` keyword argument, e.g. ``body = RichTextField(editor='legacy')``. Within each configuration block, the following fields are recognised:

 * ``WIDGET``: The rich text widget implementation to use. Wagtail provides two implementations: ``wagtail.admin.rich_text.DraftailRichTextArea`` (a modern extensible editor which enforces well-structured markup) and ``wagtail.admin.rich_text.HalloRichTextArea`` (deprecated; works directly at the HTML level). Other widgets may be provided by third-party packages.

 * ``OPTIONS``: Configuration options to pass to the widget. Recognised options are widget-specific, but both ``DraftailRichTextArea`` and ``HalloRichTextArea`` accept a ``features`` list indicating the active rich text features (see :ref:`rich_text_features`).

If a ``'default'`` editor is not specified, rich text fields that do not specify an ``editor`` argument will use the Draftail editor with the default feature set enabled.

.. versionchanged:: 2.10

    Omitting the ``'default'`` editor now leaves the original default editor intact, so it is no longer necessary to redefine ``'default'`` when adding alternative editors.


.. _WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK:

Page locking
============

``WAGTAILADMIN_GLOBAL_PAGE_EDIT_LOCK`` can be set to ``True`` to prevent users
from editing pages that they have locked.

Redirects
=========

.. code-block:: python

   WAGTAIL_REDIRECTS_FILE_STORAGE = 'tmp_file'

By default the redirect importer keeps track of the uploaded file as a temp file, but on certain environments (load balanced/cloud environments), you cannot keep a shared file between environments. For those cases you can use the built-in cache to store the file instead.

.. code-block:: python

   WAGTAIL_REDIRECTS_FILE_STORAGE = 'cache'

Form builder
============

.. versionadded:: 2.7.4/2.9.3

    The ``WAGTAILFORMS_HELP_TEXT_ALLOW_HTML`` option was added.

.. code-block:: python

    WAGTAILFORMS_HELP_TEXT_ALLOW_HTML = True

When true, HTML tags in form field help text will be rendered unescaped (default: False).



----- FILE: wagtail_contrib_forms_tests_utils.py (NEW) -----
# -*- coding: utf-8 -*-
from wagtail.core.models import Page
from wagtail.tests.testapp.models import (
    FormField, FormFieldWithCustomSubmission, FormPage, FormPageWithCustomSubmission,
    FormPageWithRedirect, RedirectFormField)


def make_form_page(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPage(**kwargs))

    FormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
        help_text="<em>please</em> be polite"
    )
    FormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


def make_form_page_with_custom_submission(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('intro', "<p>Boring intro text</p>")
    kwargs.setdefault('thank_you_text', "<p>Thank you for your patience!</p>")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPageWithCustomSubmission(**kwargs))

    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    FormFieldWithCustomSubmission.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


def make_form_page_with_redirect(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")


    home_page = Page.objects.get(url_path='/home/')
    kwargs.setdefault('thank_you_redirect_page', home_page)
    form_page = home_page.add_child(instance=FormPageWithRedirect(**kwargs))
    # form_page.thank_you_redirect_page = home_page

    RedirectFormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Your email",
        field_type='email',
        required=True,
    )
    RedirectFormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Your message",
        field_type='multiline',
        required=True,
    )
    RedirectFormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Your choices",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )

    return form_page


def make_types_test_form_page(**kwargs):
    kwargs.setdefault('title', "Contact us")
    kwargs.setdefault('slug', "contact-us")
    kwargs.setdefault('to_address', "to@email.com")
    kwargs.setdefault('from_address', "from@email.com")
    kwargs.setdefault('subject', "The subject")

    home_page = Page.objects.get(url_path='/home/')
    form_page = home_page.add_child(instance=FormPage(**kwargs))

    FormField.objects.create(
        page=form_page,
        sort_order=1,
        label="Single line text",
        field_type='singleline',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=2,
        label="Multiline",
        field_type='multiline',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=3,
        label="Email",
        field_type='email',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=4,
        label="Number",
        field_type='number',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=5,
        label="URL",
        field_type='url',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=6,
        label="Checkbox",
        field_type='checkbox',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=7,
        label="Checkboxes",
        field_type='checkboxes',
        required=False,
        choices='foo,bar,baz',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=8,
        label="Drop down",
        field_type='dropdown',
        required=False,
        choices='spam,ham,eggs',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=9,
        label="Multiple select",
        field_type='multiselect',
        required=False,
        choices='qux,quux,quuz,corge',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=10,
        label="Radio buttons",
        field_type='radio',
        required=False,
        choices='wibble,wobble,wubble',
    )
    FormField.objects.create(
        page=form_page,
        sort_order=11,
        label="Date",
        field_type='date',
        required=False,
    )
    FormField.objects.create(
        page=form_page,
        sort_order=12,
        label="Datetime",
        field_type='datetime',
        required=False,
    )

    return form_page


