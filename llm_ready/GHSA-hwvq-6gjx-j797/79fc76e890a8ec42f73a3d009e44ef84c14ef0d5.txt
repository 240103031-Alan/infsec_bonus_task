
#################### LLM PATCH ANALYSIS PACKAGE ####################

You are a security patch migration expert.

Your task:
1. Look at the OLD code (vulnerable).
2. Look at the NEW code (patched).
3. Look at the DIFF.
4. Decide whether the patch can be applied to the old version:
   - Yes      → applies cleanly
   - Maybe    → applies with adjustments
   - No       → cannot be applied
5. Provide a short explanation.

IMPORTANT:
Return ONLY JSON of this form:

{
  "portability": "Yes/Maybe/No",
  "reason": "<short explanation>"
}

####################################################################


### PATCH DIFF ###
commit 79fc76e890a8ec42f73a3d009e44ef84c14ef0d5
Author: Afshin Taylor Darian <git@darian.af>
Date:   Thu Aug 5 18:50:10 2021 +0100

    Merge pull request from GHSA-hwvq-6gjx-j797
    
    * sanitizer fix
    
    * Pass sanitizer options explicitly

diff --git a/bower.json b/bower.json
index 5f72f6ff0..393db02ad 100644
--- a/bower.json
+++ b/bower.json
@@ -9,7 +9,6 @@
     "create-react-class": "https://cdn.jsdelivr.net/npm/create-react-class@15.6.3/create-react-class.min.js",
     "es6-promise": "~1.0",
     "font-awesome": "components/font-awesome#~4.7.0",
-    "google-caja": "5669",
     "jed": "~1.1.1",
     "jquery": "components/jquery#~3.5.0",
     "jquery-typeahead": "~2.10.6",
diff --git a/notebook/static/base/js/namespace.js b/notebook/static/base/js/namespace.js
index 56b1b271c..5eeb1ebd0 100644
--- a/notebook/static/base/js/namespace.js
+++ b/notebook/static/base/js/namespace.js
@@ -73,7 +73,7 @@ define(function(){
     // tree
     jglobal('SessionList','tree/js/sessionlist');
 
-    Jupyter.version = "6.4.0";
+    Jupyter.version = "6.5.0.dev0";
     Jupyter._target = '_blank';
 
     return Jupyter;
diff --git a/notebook/static/base/js/security.js b/notebook/static/base/js/security.js
index 195c0a5cb..7d01321ce 100644
--- a/notebook/static/base/js/security.js
+++ b/notebook/static/base/js/security.js
@@ -3,124 +3,24 @@
 
 define([
     'jquery',
-    'components/google-caja/html-css-sanitizer-minified',
-], function($, sanitize) {
+    'components/sanitizer/index',
+], function($, sanitizer) {
     "use strict";
-    
+
     var noop = function (x) { return x; };
-    
-    var caja;
-    if (window && window.html) {
-        caja = window.html;
-        caja.html4 = window.html4;
-        caja.sanitizeStylesheet = window.sanitizeStylesheet;
-    }
-    
-    var sanitizeAttribs = function (tagName, attribs, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
-        /**
-         * add trusting data-attributes to the default sanitizeAttribs from caja
-         * this function is mostly copied from the caja source
-         */
-        var ATTRIBS = caja.html4.ATTRIBS;
-        for (var i = 0; i < attribs.length; i += 2) {
-            var attribName = attribs[i];
-            if (attribName.substr(0,5) == 'data-') {
-                var attribKey = '*::' + attribName;
-                if (!ATTRIBS.hasOwnProperty(attribKey)) {
-                    ATTRIBS[attribKey] = 0;
-                }
-            }
-        }
-        // Caja doesn't allow data uri for img::src, see
-        // https://github.com/google/caja/issues/1558
-        // This is not a security issue for browser post ie6 though, so we
-        // disable the check
-        // https://www.owasp.org/index.php/Script_in_IMG_tags
-        ATTRIBS['img::src'] = 0;
-        return caja.sanitizeAttribs(tagName, attribs, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
-    };
-    
-    var sanitize_css = function (css, tagPolicy) {
-        /**
-         * sanitize CSS
-         * like sanitize_html, but for CSS
-         * called by sanitize_stylesheets
-         */
-        return caja.sanitizeStylesheet(
-            window.location.pathname,
-            css,
-            {
-                containerClass: null,
-                idSuffix: '',
-                tagPolicy: tagPolicy,
-                virtualizeAttrName: noop
-            },
-            noop
-        );
-    };
-    
-    var sanitize_stylesheets = function (html, tagPolicy) {
-        /**
-         * sanitize just the css in style tags in a block of html
-         * called by sanitize_html, if allow_css is true
-         */
-        var h = $("<div/>").append(html);
-        var style_tags = h.find("style");
-        if (!style_tags.length) {
-            // no style tags to sanitize
-            return html;
-        }
-        style_tags.each(function(i, style) {
-            style.innerHTML = sanitize_css(style.innerHTML, tagPolicy);
-        });
-        return h.html();
-    };
-    
+    var defaultSanitizer = sanitizer.defaultSanitizer;
+
     var sanitize_html = function (html, allow_css) {
         /**
          * sanitize HTML
          * if allow_css is true (default: false), CSS is sanitized as well.
          * otherwise, CSS elements and attributes are simply removed.
          */
-        var html4 = caja.html4;
-
-        if (allow_css) {
-            // allow sanitization of style tags,
-            // not just scrubbing
-            html4.ELEMENTS.style &= ~html4.eflags.UNSAFE;
-            html4.ATTRIBS.style = html4.atype.STYLE;
-        } else {
-            // scrub all CSS
-            html4.ELEMENTS.style |= html4.eflags.UNSAFE;
-            html4.ATTRIBS.style = html4.atype.SCRIPT;
-        }
-        
-        var record_messages = function (msg, opts) {
-            console.log("HTML Sanitizer", msg, opts);
-        };
-        
-        var policy = function (tagName, attribs) {
-            if (!(html4.ELEMENTS[tagName] & html4.eflags.UNSAFE)) {
-                return {
-                    'attribs': sanitizeAttribs(tagName, attribs,
-                        noop, noop, record_messages)
-                    };
-            } else {
-                record_messages(tagName + " removed", {
-                  change: "removed",
-                  tagName: tagName
-                });
-            }
-        };
-        
-        var sanitized = caja.sanitizeWithPolicy(html, policy);
-        
-        if (allow_css) {
-            // sanitize style tags as stylesheets
-            sanitized = sanitize_stylesheets(sanitized, policy);
-        }
-        
-        return sanitized;
+         const options = {};
+         if (!allow_css) {
+             options.allowedStyles = {};
+         }
+        return defaultSanitizer.sanitize(html, options);
     };
 
     var sanitize_html_and_parse = function (html, allow_css) {
@@ -141,9 +41,8 @@ define([
             $.htmlPrefilter = prev_htmlPrefilter;  // Set it back again
         }
     };
-    
+
     var security = {
-        caja: caja,
         sanitize_html_and_parse: sanitize_html_and_parse,
         sanitize_html: sanitize_html
     };
diff --git a/package.json b/package.json
index 52be970ae..6da0a8029 100644
--- a/package.json
+++ b/package.json
@@ -12,14 +12,18 @@
   "scripts": {
     "bower": "bower install",
     "build": "python setup.py js css",
+    "build:webpack": "webpack --mode development",
     "build:watch": "npm run watch",
     "watch": "onchange 'notebook/static/**/!(*.min).js' 'notebook/static/**/*.less' 'bower.json' -- npm run build"
   },
   "devDependencies": {
+    "@jupyterlab/apputils": "^3.1.3",
     "bower": "^1.8.8",
     "less": "~2",
     "onchange": "^6.0.0",
     "po2json": "^0.4.5",
-    "requirejs": "^2.3.6"
+    "requirejs": "^2.3.6",
+    "webpack": "^5.46.0",
+    "webpack-cli": "^4.7.2"
   }
 }
diff --git a/setupbase.py b/setupbase.py
index fb3327da3..8849a85e3 100644
--- a/setupbase.py
+++ b/setupbase.py
@@ -137,7 +137,6 @@ def find_package_data():
         pjoin(components, "font-awesome", "css", "*.css"),
         pjoin(components, "es6-promise", "*.js"),
         pjoin(components, "font-awesome", "fonts", "*.*"),
-        pjoin(components, "google-caja", "html-css-sanitizer-minified.js"),
         pjoin(components, "jed", "jed.js"),
         pjoin(components, "jquery", "jquery.min.js"),
         pjoin(components, "jquery-typeahead", "dist", "jquery.typeahead.min.js"),
@@ -151,6 +150,7 @@ def find_package_data():
         pjoin(components, "requirejs", "require.js"),
         pjoin(components, "requirejs-plugins", "src", "json.js"),
         pjoin(components, "requirejs-text", "text.js"),
+        pjoin(components, "sanitizer", "index.js"),
         pjoin(components, "underscore", "underscore-min.js"),
         pjoin(components, "moment", "moment.js"),
         pjoin(components, "moment", "min", "*.js"),
@@ -374,14 +374,21 @@ class Bower(Command):
     
     bower_dir = pjoin(static, 'components')
     node_modules = pjoin(repo_root, 'node_modules')
+    sanitizer_dir = pjoin(bower_dir, 'sanitizer')
     
     def should_run(self):
         if self.force:
             return True
         if not os.path.exists(self.bower_dir):
             return True
-        
-        return mtime(self.bower_dir) < mtime(pjoin(repo_root, 'bower.json'))
+        if not os.path.exists(self.sanitizer_dir):
+            return True
+
+        bower_stale = mtime(self.bower_dir) < mtime(pjoin(repo_root, 'bower.json'))
+        if bower_stale:
+            return True
+
+        return mtime(self.sanitizer_dir) < mtime(pjoin(repo_root, 'webpack.config.js'))
 
     def should_run_npm(self):
         if not which('npm'):
@@ -415,6 +422,8 @@ class Bower(Command):
             print("You can install js dependencies with `npm install`", file=sys.stderr)
             raise
         # self.npm_components()
+        if not os.path.exists(self.sanitizer_dir):
+            run(['npm', 'run', 'build:webpack'], cwd=repo_root, env=env)
         os.utime(self.bower_dir, None)
         # update package data in case this created new files
         update_package_data(self.distribution)
diff --git a/webpack.config.js b/webpack.config.js
new file mode 100644
index 000000000..eb440b77d
--- /dev/null
+++ b/webpack.config.js
@@ -0,0 +1,10 @@
+const path = require('path');
+
+module.exports = {
+  entry: '@jupyterlab/apputils/lib/sanitizer',
+  output: {
+    filename: 'index.js',
+    path: path.resolve(__dirname, 'notebook/static/components/sanitizer'),
+    libraryTarget: "amd"
+  }
+}


### CHANGED FILES SUMMARY ###
{
  "changed_files": [
    "bower.json",
    "notebook/static/base/js/namespace.js",
    "notebook/static/base/js/security.js",
    "package.json",
    "setupbase.py",
    "webpack.config.js"
  ],
  "files_saved": [
    {
      "file": "bower.json",
      "old": true,
      "new": true
    },
    {
      "file": "notebook/static/base/js/namespace.js",
      "old": true,
      "new": true
    },
    {
      "file": "notebook/static/base/js/security.js",
      "old": true,
      "new": true
    },
    {
      "file": "package.json",
      "old": true,
      "new": true
    },
    {
      "file": "setupbase.py",
      "old": true,
      "new": true
    },
    {
      "file": "webpack.config.js",
      "old": false,
      "new": true
    }
  ]
}

### OLD VERSION FILES ###

----- FILE: notebook_static_base_js_namespace.js (OLD) -----
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


var Jupyter = Jupyter || {};

var jprop = function(name, module_path){
    Object.defineProperty(Jupyter, name, {
      get: function() { 
          console.warn('accessing `'+name+'` is deprecated. Use `requirejs("'+module_path+'")`');
          return requirejs(module_path); 
      },
      enumerable: true,
      configurable: false
    });
}

var jglobal = function(name, module_path){
    Object.defineProperty(Jupyter, name, {
      get: function() { 
          console.warn('accessing `'+name+'` is deprecated. Use `requirejs("'+module_path+'").'+name+'`');
          return requirejs(module_path)[name]; 
      },
      enumerable: true,
      configurable: false
    });
}

define(function(){
    "use strict";

    // expose modules
    
    jprop('utils','base/js/utils')
    jprop('mathjaxutils','base/js/mathjaxutils');

    //Jupyter.load_extensions = Jupyter.utils.load_extensions;
    // 
    jprop('security','base/js/security');
    jprop('keyboard','base/js/keyboard');
    jprop('dialog','base/js/dialog');


    //// exposed constructors
    jglobal('CommManager','services/kernels/comm')
    jglobal('Comm','services/kernels/comm')

    jglobal('NotificationWidget','base/js/notificationwidget');
    jglobal('Kernel','services/kernels/kernel');
    jglobal('Session','services/sessions/session');
    jglobal('LoginWidget','auth/js/loginwidget');
    jglobal('Page','base/js/page');

    // notebook
    jglobal('TextCell','notebook/js/textcell');
    jglobal('OutputArea','notebook/js/outputarea');
    jglobal('KeyboardManager','notebook/js/keyboardmanager');
    jglobal('Completer','notebook/js/completer');
    jglobal('Notebook','notebook/js/notebook');
    jglobal('Tooltip','notebook/js/tooltip');
    jglobal('Toolbar','notebook/js/toolbar');
    jglobal('SaveWidget','notebook/js/savewidget');
    jglobal('Pager','notebook/js/pager');
    jglobal('QuickHelp','notebook/js/quickhelp');
    jglobal('MarkdownCell','notebook/js/textcell');
    jglobal('RawCell','notebook/js/textcell');
    jglobal('Cell','notebook/js/cell');
    jglobal('MainToolBar','notebook/js/maintoolbar');
    jglobal('NotebookNotificationArea','notebook/js/notificationarea');
    jglobal('NotebookTour', 'notebook/js/tour');
    jglobal('MenuBar', 'notebook/js/menubar');

    // tree
    jglobal('SessionList','tree/js/sessionlist');

    Jupyter.version = "6.4.0";
    Jupyter._target = '_blank';

    return Jupyter;
});

// deprecated since 4.0, remove in 5+
var IPython = Jupyter;



----- FILE: setupbase.py (OLD) -----
"""
This module defines the things that are used in setup.py for building the notebook

This includes:

    * Functions for finding things like packages, package data, etc.
    * A function for checking dependencies.
"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import os
import re
import pipes
import shutil
import sys

from distutils import log
from distutils.cmd import Command
from fnmatch import fnmatch
from glob import glob
from multiprocessing.pool import ThreadPool
from subprocess import check_call

if sys.platform == 'win32':
    from subprocess import list2cmdline
else:
    def list2cmdline(cmd_list):
        return ' '.join(map(pipes.quote, cmd_list))

#-------------------------------------------------------------------------------
# Useful globals and utility functions
#-------------------------------------------------------------------------------

# A few handy globals
isfile = os.path.isfile
pjoin = os.path.join
repo_root = os.path.dirname(os.path.abspath(__file__))
is_repo = os.path.isdir(pjoin(repo_root, '.git'))

def oscmd(s):
    print(">", s)
    os.system(s)

# Py3 compatibility hacks, without assuming IPython itself is installed with
# the full py3compat machinery.

try:
    execfile
except NameError:
    def execfile(fname, globs, locs=None):
        locs = locs or globs
        exec(compile(open(fname).read(), fname, "exec"), globs, locs)


#---------------------------------------------------------------------------
# Basic project information
#---------------------------------------------------------------------------

name = 'notebook'

# release.py contains version, authors, license, url, keywords, etc.
version_ns = {}
execfile(pjoin(repo_root, name, '_version.py'), version_ns)

version = version_ns['__version__']


# vendored from pep440 package, we allow `.dev` suffix without trailing number.
loose_pep440re = re.compile(r'^([1-9]\d*!)?(0|[1-9]\d*)(\.(0|[1-9]\d*))*((a|b|rc)(0|[1-9]\d*))?(\.post(0|[1-9]\d*))?(\.dev(0|[1-9]\d*)?)?$')
if not loose_pep440re.match(version):
    raise ValueError('Invalid version number `%s`, please follow pep440 convention or pip will get confused about which package is more recent.' % version)

#---------------------------------------------------------------------------
# Find packages
#---------------------------------------------------------------------------

def find_packages():
    """
    Find all of the packages.
    """
    packages = []
    for dir,subdirs,files in os.walk(name):
        package = dir.replace(os.path.sep, '.')
        if '__init__.py' not in files:
            # not a package
            continue
        packages.append(package)
    return packages

#---------------------------------------------------------------------------
# Find package data
#---------------------------------------------------------------------------

def find_package_data():
    """
    Find package_data.
    """
    # This is not enough for these things to appear in a sdist.
    # We need to muck with the MANIFEST to get this to work
    
    # exclude components and less from the walk;
    # we will build the components separately
    excludes = [
        pjoin('static', 'components'),
        pjoin('static', '*', 'less'),
        pjoin('static', '*', 'node_modules')
    ]

    # walk notebook resources:
    cwd = os.getcwd()
    os.chdir('notebook')
    static_data = []
    for parent, dirs, files in os.walk('static'):
        if any(fnmatch(parent, pat) for pat in excludes):
            # prevent descending into subdirs
            dirs[:] = []
            continue
        for f in files:
            static_data.append(pjoin(parent, f))
    
    # for verification purposes, explicitly add main.min.js
    # so that installation will fail if they are missing
    for app in ['auth', 'edit', 'notebook', 'terminal', 'tree']:
        static_data.append(pjoin('static', app, 'js', 'main.min.js'))
    
    components = pjoin("static", "components")
    # select the components we actually need to install
    # (there are lots of resources we bundle for sdist-reasons that we don't actually use)
    static_data.extend([
        pjoin(components, "backbone", "backbone-min.js"),
        pjoin(components, "bootstrap", "dist", "js", "bootstrap.min.js"),
        pjoin(components, "bootstrap-tour", "build", "css", "bootstrap-tour.min.css"),
        pjoin(components, "bootstrap-tour", "build", "js", "bootstrap-tour.min.js"),
        pjoin(components, "create-react-class", "index.js"),
        pjoin(components, "font-awesome", "css", "*.css"),
        pjoin(components, "es6-promise", "*.js"),
        pjoin(components, "font-awesome", "fonts", "*.*"),
        pjoin(components, "google-caja", "html-css-sanitizer-minified.js"),
        pjoin(components, "jed", "jed.js"),
        pjoin(components, "jquery", "jquery.min.js"),
        pjoin(components, "jquery-typeahead", "dist", "jquery.typeahead.min.js"),
        pjoin(components, "jquery-typeahead", "dist", "jquery.typeahead.min.css"),
        pjoin(components, "jquery-ui", "jquery-ui.min.js"),
        pjoin(components, "jquery-ui", "themes", "smoothness", "jquery-ui.min.css"),
        pjoin(components, "jquery-ui", "themes", "smoothness", "images", "*"),
        pjoin(components, "marked", "lib", "marked.js"),
        pjoin(components, "react", "react.production.min.js"),
        pjoin(components, "react", "react-dom.production.min.js"),
        pjoin(components, "requirejs", "require.js"),
        pjoin(components, "requirejs-plugins", "src", "json.js"),
        pjoin(components, "requirejs-text", "text.js"),
        pjoin(components, "underscore", "underscore-min.js"),
        pjoin(components, "moment", "moment.js"),
        pjoin(components, "moment", "min", "*.js"),
        pjoin(components, "xterm.js", "index.js"),
        pjoin(components, "xterm.js-css", "index.css"),
        pjoin(components, "xterm.js-fit", "index.js"),
        pjoin(components, "text-encoding", "lib", "encoding.js"),
    ])

    # Ship all of Codemirror's CSS and JS
    for parent, dirs, files in os.walk(pjoin(components, 'codemirror')):
        for f in files:
            if f.endswith(('.js', '.css')):
                static_data.append(pjoin(parent, f))

    # Trim mathjax
    mj = lambda *path: pjoin(components, 'MathJax', *path)
    static_data.extend([
        mj('MathJax.js'),
        mj('config', 'TeX-AMS-MML_HTMLorMML-full.js'),
        mj('config', 'Safe.js'),
    ])
    
    trees = []
    mj_out = mj('jax', 'output')
    
    if os.path.exists(mj_out):
        for output in os.listdir(mj_out):
            path = pjoin(mj_out, output)
            static_data.append(pjoin(path, '*.js'))
            autoload = pjoin(path, 'autoload')
            if os.path.isdir(autoload):
                trees.append(autoload)

    for tree in trees + [
        mj('localization'), # limit to en?
        mj('fonts', 'HTML-CSS', 'STIX-Web', 'woff'),
        mj('extensions'),
        mj('jax', 'input', 'TeX'),
        mj('jax', 'output', 'HTML-CSS', 'fonts', 'STIX-Web'),
        mj('jax', 'output', 'SVG', 'fonts', 'STIX-Web'),
        mj('jax', 'element', 'mml'),
    ]:
        for parent, dirs, files in os.walk(tree):
            for f in files:
                static_data.append(pjoin(parent, f))

    os.chdir(os.path.join('tests',))
    js_tests = glob('*.js') + glob('*/*.js')

    os.chdir(cwd)

    package_data = {
        'notebook' : ['templates/*'] + static_data,
        'notebook.tests' : js_tests,
        'notebook.bundler.tests': ['resources/*', 'resources/*/*', 'resources/*/*/.*'],
        'notebook.services.api': ['api.yaml'],
        'notebook.i18n': ['*/LC_MESSAGES/*.*'],
    }
    
    return package_data


def check_package_data(package_data):
    """verify that package_data globs make sense"""
    print("checking package data")
    for pkg, data in package_data.items():
        pkg_root = pjoin(*pkg.split('.'))
        for d in data:
            path = pjoin(pkg_root, d)
            if '*' in path:
                assert len(glob(path)) > 0, "No files match pattern %s" % path
            else:
                assert os.path.exists(path), "Missing package data: %s" % path


def check_package_data_first(command):
    """decorator for checking package_data before running a given command
    
    Probably only needs to wrap build_py
    """
    class DecoratedCommand(command):
        def run(self):
            check_package_data(self.package_data)
            command.run(self)
    return DecoratedCommand

def update_package_data(distribution):
    """update package_data to catch changes during setup"""
    build_py = distribution.get_command_obj('build_py')
    distribution.package_data = find_package_data()
    # re-init build_py options which load package_data
    build_py.finalize_options()

#---------------------------------------------------------------------------
# Notebook related
#---------------------------------------------------------------------------

try:
    from shutil import which
except ImportError:
    ## which() function copied from Python 3.4.3; PSF license
    def which(cmd, mode=os.F_OK | os.X_OK, path=None):
        """Given a command, mode, and a PATH string, return the path which
        conforms to the given mode on the PATH, or None if there is no such
        file.

        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
        of os.environ.get("PATH"), or can be overridden with a custom search
        path.

        """
        # Check that a given file can be accessed with the correct mode.
        # Additionally check that `file` is not a directory, as on Windows
        # directories pass the os.access check.
        def _access_check(fn, mode):
            return (os.path.exists(fn) and os.access(fn, mode)
                    and not os.path.isdir(fn))

        # If we're given a path with a directory part, look it up directly rather
        # than referring to PATH directories. This includes checking relative to the
        # current directory, e.g. ./script
        if os.path.dirname(cmd):
            if _access_check(cmd, mode):
                return cmd
            return None

        if path is None:
            path = os.environ.get("PATH", os.defpath)
        if not path:
            return None
        path = path.split(os.pathsep)

        if sys.platform == "win32":
            # The current directory takes precedence on Windows.
            if not os.curdir in path:
                path.insert(0, os.curdir)

            # PATHEXT is necessary to check on Windows.
            pathext = os.environ.get("PATHEXT", "").split(os.pathsep)
            # See if the given file matches any of the expected path extensions.
            # This will allow us to short circuit when given "python.exe".
            # If it does match, only test that one, otherwise we have to try
            # others.
            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
                files = [cmd]
            else:
                files = [cmd + ext for ext in pathext]
        else:
            # On other platforms you don't have things like PATHEXT to tell you
            # what file suffixes are executable, so just pass on cmd as-is.
            files = [cmd]

        seen = set()
        for dir in path:
            normdir = os.path.normcase(dir)
            if not normdir in seen:
                seen.add(normdir)
                for thefile in files:
                    name = os.path.join(dir, thefile)
                    if _access_check(name, mode):
                        return name
        return None


static = pjoin(repo_root, 'notebook', 'static')

npm_path = os.pathsep.join([
    pjoin(repo_root, 'node_modules', '.bin'),
    os.environ.get("PATH", os.defpath),
])

def mtime(path):
    """shorthand for mtime"""
    return os.stat(path).st_mtime


def run(cmd, *args, **kwargs):
    """Echo a command before running it"""
    log.info('> ' + list2cmdline(cmd))
    kwargs['shell'] = (sys.platform == 'win32')
    return check_call(cmd, *args, **kwargs)

class CompileBackendTranslation(Command):
    description = "compile the .po files into .mo files, that contain the translations."

    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass


    def run(self):
        paths = glob('notebook/i18n/??_??')
        for p in paths:
            LANG = p[-5:]
            for component in ['notebook', 'nbui']:
                run(['pybabel', 'compile',
                     '-D', component,
                     '-f',
                     '-l', LANG,
                     '-i', pjoin('notebook', 'i18n', LANG, 'LC_MESSAGES', component+'.po'),
                     '-o', pjoin('notebook', 'i18n', LANG, 'LC_MESSAGES', component+'.mo')
                    ])

class Bower(Command):
    description = "fetch static client-side components with bower"
    
    user_options = [
        ('force', 'f', "force fetching of bower dependencies"),
    ]
    
    def initialize_options(self):
        self.force = False
    
    def finalize_options(self):
        self.force = bool(self.force)
    
    bower_dir = pjoin(static, 'components')
    node_modules = pjoin(repo_root, 'node_modules')
    
    def should_run(self):
        if self.force:
            return True
        if not os.path.exists(self.bower_dir):
            return True
        
        return mtime(self.bower_dir) < mtime(pjoin(repo_root, 'bower.json'))

    def should_run_npm(self):
        if not which('npm'):
            print("npm unavailable", file=sys.stderr)
            return False
        if not os.path.exists(self.node_modules):
            return True
        return mtime(self.node_modules) < mtime(pjoin(repo_root, 'package.json'))

    def run(self):
        if not self.should_run():
            print("bower dependencies up to date")
            return
        
        if self.should_run_npm():
            print("installing build dependencies with npm")
            run(['npm', 'install'], cwd=repo_root)
            os.utime(self.node_modules, None)
        
        env = os.environ.copy()
        env['PATH'] = npm_path
        
        try:
            run(
                ['bower', 'install', '--allow-root', '--config.interactive=false'],
                cwd=repo_root,
                env=env
            )
        except OSError as e:
            print("Failed to run bower: %s" % e, file=sys.stderr)
            print("You can install js dependencies with `npm install`", file=sys.stderr)
            raise
        # self.npm_components()
        os.utime(self.bower_dir, None)
        # update package data in case this created new files
        update_package_data(self.distribution)


def patch_out_bootstrap_bw_print():
    """Hack! Manually patch out the bootstrap rule that forces printing in B&W.

    We haven't found a way to override this rule with another one.
    """
    print_less = pjoin(static, 'components', 'bootstrap', 'less', 'print.less')
    with open(print_less) as f:
        lines = f.readlines()

    for ix, line in enumerate(lines):
        if 'Black prints faster' in line:
            break
    else:
        return  # Already patched out, nothing to do.

    rmed = lines.pop(ix)
    print("Removed line", ix, "from bootstrap print.less:")
    print("-", rmed)
    print()
    with open(print_less, 'w') as f:
        f.writelines(lines)

class CompileCSS(Command):
    """Recompile Notebook CSS
    
    Regenerate the compiled CSS from LESS sources.
    
    Requires various dev dependencies, such as require and lessc.
    """
    description = "Recompile Notebook CSS"
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    sources = []
    targets = []
    for name in ('ipython', 'style'):
        sources.append(pjoin(static, 'style', '%s.less' % name))
        targets.append(pjoin(static, 'style', '%s.min.css' % name))

    def run(self):
        self.run_command('jsdeps')
        env = os.environ.copy()
        env['PATH'] = npm_path

        patch_out_bootstrap_bw_print()
        
        for src, dst in zip(self.sources, self.targets):
            try:
                run(['lessc',
                    '--source-map',
                    '--include-path=%s' % pipes.quote(static),
                    src,
                    dst,
                ], cwd=repo_root, env=env)
            except OSError as e:
                print("Failed to build css: %s" % e, file=sys.stderr)
                print("You can install js dependencies with `npm install`", file=sys.stderr)
                raise
        # update package data in case this created new files
        update_package_data(self.distribution)


class CompileJS(Command):
    """Rebuild Notebook Javascript main.min.js files and translation files.
    
    Calls require via build-main.js
    """
    description = "Rebuild Notebook Javascript main.min.js files"
    user_options = [
        ('force', 'f', "force rebuilding js targets"),
    ]

    def initialize_options(self):
        self.force = False

    def finalize_options(self):
        self.force = bool(self.force)

    apps = ['notebook', 'tree', 'edit', 'terminal', 'auth']
    targets = [ pjoin(static, app, 'js', 'main.min.js') for app in apps ]
    
    def sources(self, name):
        """Generator yielding .js sources that an application depends on"""
        yield pjoin(repo_root, 'tools', 'build-main.js')
        yield pjoin(static, name, 'js', 'main.js')

        for sec in [name, 'base', 'auth']:
            for f in glob(pjoin(static, sec, 'js', '*.js')):
                if not f.endswith('.min.js'):
                    yield f
        yield pjoin(static, 'services', 'config.js')
        if name == 'notebook':
            for f in glob(pjoin(static, 'services', '*', '*.js')):
                yield f
        for parent, dirs, files in os.walk(pjoin(static, 'components')):
            if os.path.basename(parent) == 'MathJax':
                # don't look in MathJax, since it takes forever to walk it
                dirs[:] = []
                continue
            for f in files:
                yield pjoin(parent, f)
    
    def should_run(self, name, target):
        if self.force or not os.path.exists(target):
            return True
        target_mtime = mtime(target)
        for source in self.sources(name):
            if mtime(source) > target_mtime:
                print(source, target)
                return True
        return False

    def build_main(self, name):
        """Build main.min.js"""
        target = pjoin(static, name, 'js', 'main.min.js')

        if not self.should_run(name, target):
            log.info("%s up to date" % target)
            return
        log.info("Rebuilding %s" % target)
        run(['node', 'tools/build-main.js', name])

    def build_jstranslation(self, trd):
        lang = trd[-5:]
        run([
            pjoin('node_modules', '.bin', 'po2json'),
            '-p', '-F',
            '-f', 'jed1.x',
            '-d', 'nbjs',
            pjoin('notebook', 'i18n', lang, 'LC_MESSAGES', 'nbjs.po'),
            pjoin('notebook', 'i18n', lang, 'LC_MESSAGES', 'nbjs.json'),
        ])

    def run(self):
        self.run_command('jsdeps')
        env = os.environ.copy()
        env['PATH'] = npm_path
        pool = ThreadPool()
        pool.map(self.build_main, self.apps)
        pool.map(self.build_jstranslation, glob('notebook/i18n/??_??'))
        # update package data in case this created new files
        update_package_data(self.distribution)


class JavascriptVersion(Command):
    """write the javascript version to notebook javascript"""
    description = "Write Jupyter version to javascript"
    user_options = []
    
    def initialize_options(self):
        pass
    
    def finalize_options(self):
        pass
    
    def run(self):
        nsfile = pjoin(repo_root, "notebook", "static", "base", "js", "namespace.js")
        with open(nsfile) as f:
            lines = f.readlines()
        with open(nsfile, 'w') as f:
            found = False
            for line in lines:
                if line.strip().startswith("Jupyter.version"):
                    line = '    Jupyter.version = "{0}";\n'.format(version)
                    found = True
                f.write(line)
            if not found:
                raise RuntimeError("Didn't find Jupyter.version line in %s" % nsfile)


def css_js_prerelease(command, strict=False):
    """decorator for building minified js/css prior to another command"""
    class DecoratedCommand(command):
        def run(self):
            self.distribution.run_command('jsversion')
            jsdeps = self.distribution.get_command_obj('jsdeps')
            js = self.distribution.get_command_obj('js')
            css = self.distribution.get_command_obj('css')
            jsdeps.force = js.force = strict

            targets = [ jsdeps.bower_dir ]
            targets.extend(js.targets)
            targets.extend(css.targets)
            missing = [ t for t in targets if not os.path.exists(t) ]

            if not is_repo and not missing:
                # If we're an sdist, we aren't a repo and everything should be present.
                # Don't rebuild js/css in that case.
                command.run(self)
                return

            try:
                self.distribution.run_command('js')
                self.distribution.run_command('css')
                self.distribution.run_command('backendtranslations')
            except Exception as e:
                # refresh missing
                missing = [ t for t in targets if not os.path.exists(t) ]
                if strict or missing:
                    # die if strict or any targets didn't build
                    prefix = os.path.commonprefix([repo_root + os.sep] + missing)
                    missing = [ m[len(prefix):] for m in missing ]
                    log.warn("rebuilding js and css failed. The following required files are missing: %s" % missing)
                    raise e
                else:
                    log.warn("rebuilding js and css failed (not a problem)")
                    log.warn(str(e))

            # check again for missing targets, just in case:
            missing = [ t for t in targets if not os.path.exists(t) ]
            if missing:
                # command succeeded, but targets still missing (?!)
                prefix = os.path.commonprefix([repo_root + os.sep] + missing)
                missing = [ m[len(prefix):] for m in missing ]
                raise ValueError("The following required files are missing: %s" % missing)

            command.run(self)
    return DecoratedCommand



----- FILE: notebook_static_base_js_security.js (OLD) -----
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

define([
    'jquery',
    'components/google-caja/html-css-sanitizer-minified',
], function($, sanitize) {
    "use strict";
    
    var noop = function (x) { return x; };
    
    var caja;
    if (window && window.html) {
        caja = window.html;
        caja.html4 = window.html4;
        caja.sanitizeStylesheet = window.sanitizeStylesheet;
    }
    
    var sanitizeAttribs = function (tagName, attribs, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
        /**
         * add trusting data-attributes to the default sanitizeAttribs from caja
         * this function is mostly copied from the caja source
         */
        var ATTRIBS = caja.html4.ATTRIBS;
        for (var i = 0; i < attribs.length; i += 2) {
            var attribName = attribs[i];
            if (attribName.substr(0,5) == 'data-') {
                var attribKey = '*::' + attribName;
                if (!ATTRIBS.hasOwnProperty(attribKey)) {
                    ATTRIBS[attribKey] = 0;
                }
            }
        }
        // Caja doesn't allow data uri for img::src, see
        // https://github.com/google/caja/issues/1558
        // This is not a security issue for browser post ie6 though, so we
        // disable the check
        // https://www.owasp.org/index.php/Script_in_IMG_tags
        ATTRIBS['img::src'] = 0;
        return caja.sanitizeAttribs(tagName, attribs, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
    };
    
    var sanitize_css = function (css, tagPolicy) {
        /**
         * sanitize CSS
         * like sanitize_html, but for CSS
         * called by sanitize_stylesheets
         */
        return caja.sanitizeStylesheet(
            window.location.pathname,
            css,
            {
                containerClass: null,
                idSuffix: '',
                tagPolicy: tagPolicy,
                virtualizeAttrName: noop
            },
            noop
        );
    };
    
    var sanitize_stylesheets = function (html, tagPolicy) {
        /**
         * sanitize just the css in style tags in a block of html
         * called by sanitize_html, if allow_css is true
         */
        var h = $("<div/>").append(html);
        var style_tags = h.find("style");
        if (!style_tags.length) {
            // no style tags to sanitize
            return html;
        }
        style_tags.each(function(i, style) {
            style.innerHTML = sanitize_css(style.innerHTML, tagPolicy);
        });
        return h.html();
    };
    
    var sanitize_html = function (html, allow_css) {
        /**
         * sanitize HTML
         * if allow_css is true (default: false), CSS is sanitized as well.
         * otherwise, CSS elements and attributes are simply removed.
         */
        var html4 = caja.html4;

        if (allow_css) {
            // allow sanitization of style tags,
            // not just scrubbing
            html4.ELEMENTS.style &= ~html4.eflags.UNSAFE;
            html4.ATTRIBS.style = html4.atype.STYLE;
        } else {
            // scrub all CSS
            html4.ELEMENTS.style |= html4.eflags.UNSAFE;
            html4.ATTRIBS.style = html4.atype.SCRIPT;
        }
        
        var record_messages = function (msg, opts) {
            console.log("HTML Sanitizer", msg, opts);
        };
        
        var policy = function (tagName, attribs) {
            if (!(html4.ELEMENTS[tagName] & html4.eflags.UNSAFE)) {
                return {
                    'attribs': sanitizeAttribs(tagName, attribs,
                        noop, noop, record_messages)
                    };
            } else {
                record_messages(tagName + " removed", {
                  change: "removed",
                  tagName: tagName
                });
            }
        };
        
        var sanitized = caja.sanitizeWithPolicy(html, policy);
        
        if (allow_css) {
            // sanitize style tags as stylesheets
            sanitized = sanitize_stylesheets(sanitized, policy);
        }
        
        return sanitized;
    };

    var sanitize_html_and_parse = function (html, allow_css) {
        /**
         * Sanitize HTML and parse it safely using jQuery.
         *
         * This disable's jQuery's html 'prefilter', which can make invalid
         * HTML valid after the sanitizer has checked it.
         *
         * Returns an array of DOM nodes.
         */
        var sanitized_html = sanitize_html(html, allow_css);
        var prev_htmlPrefilter = $.htmlPrefilter;
        $.htmlPrefilter = function(html) {return html;};  // Don't modify HTML
        try {
            return $.parseHTML(sanitized_html);
        } finally {
            $.htmlPrefilter = prev_htmlPrefilter;  // Set it back again
        }
    };
    
    var security = {
        caja: caja,
        sanitize_html_and_parse: sanitize_html_and_parse,
        sanitize_html: sanitize_html
    };

    return security;
});



----- FILE: bower.json (OLD) -----
{
  "name": "jupyter-notebook-deps",
  "version": "0.0.1",
  "dependencies": {
    "backbone": "components/backbone#~1.2",
    "bootstrap": "bootstrap#~3.4",
    "bootstrap-tour": "0.9.0",
    "codemirror": "components/codemirror#5.56.0+components1",
    "create-react-class": "https://cdn.jsdelivr.net/npm/create-react-class@15.6.3/create-react-class.min.js",
    "es6-promise": "~1.0",
    "font-awesome": "components/font-awesome#~4.7.0",
    "google-caja": "5669",
    "jed": "~1.1.1",
    "jquery": "components/jquery#~3.5.0",
    "jquery-typeahead": "~2.10.6",
    "jquery-ui": "components/jqueryui#~1.12",
    "marked": "~0.7",
    "MathJax": "^2.7.4",
    "moment": "~2.19.3",
    "react": "~16.0.0",
    "requirejs": "~2.2",
    "requirejs-text": "~2.0.15",
    "requirejs-plugins": "~1.0.3",
    "text-encoding": "~0.1",
    "underscore": "components/underscore#~1.8.3",
    "xterm.js": "https://unpkg.com/xterm@~3.1.0/dist/xterm.js",
    "xterm.js-css": "https://unpkg.com/xterm@~3.1.0/dist/xterm.css",
    "xterm.js-fit": "https://unpkg.com/xterm@~3.1.0/dist/addons/fit/fit.js"
  }
}



----- FILE: package.json (OLD) -----
{
  "name": "jupyter-notebook-deps",
  "private": true,
  "version": "4.0.0",
  "description": "Jupyter Notebook nodejs dependencies",
  "author": "Jupyter Developers",
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "https://github.com/jupyter/notebook.git"
  },
  "scripts": {
    "bower": "bower install",
    "build": "python setup.py js css",
    "build:watch": "npm run watch",
    "watch": "onchange 'notebook/static/**/!(*.min).js' 'notebook/static/**/*.less' 'bower.json' -- npm run build"
  },
  "devDependencies": {
    "bower": "^1.8.8",
    "less": "~2",
    "onchange": "^6.0.0",
    "po2json": "^0.4.5",
    "requirejs": "^2.3.6"
  }
}


### NEW VERSION FILES ###

----- FILE: notebook_static_base_js_namespace.js (NEW) -----
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


var Jupyter = Jupyter || {};

var jprop = function(name, module_path){
    Object.defineProperty(Jupyter, name, {
      get: function() { 
          console.warn('accessing `'+name+'` is deprecated. Use `requirejs("'+module_path+'")`');
          return requirejs(module_path); 
      },
      enumerable: true,
      configurable: false
    });
}

var jglobal = function(name, module_path){
    Object.defineProperty(Jupyter, name, {
      get: function() { 
          console.warn('accessing `'+name+'` is deprecated. Use `requirejs("'+module_path+'").'+name+'`');
          return requirejs(module_path)[name]; 
      },
      enumerable: true,
      configurable: false
    });
}

define(function(){
    "use strict";

    // expose modules
    
    jprop('utils','base/js/utils')
    jprop('mathjaxutils','base/js/mathjaxutils');

    //Jupyter.load_extensions = Jupyter.utils.load_extensions;
    // 
    jprop('security','base/js/security');
    jprop('keyboard','base/js/keyboard');
    jprop('dialog','base/js/dialog');


    //// exposed constructors
    jglobal('CommManager','services/kernels/comm')
    jglobal('Comm','services/kernels/comm')

    jglobal('NotificationWidget','base/js/notificationwidget');
    jglobal('Kernel','services/kernels/kernel');
    jglobal('Session','services/sessions/session');
    jglobal('LoginWidget','auth/js/loginwidget');
    jglobal('Page','base/js/page');

    // notebook
    jglobal('TextCell','notebook/js/textcell');
    jglobal('OutputArea','notebook/js/outputarea');
    jglobal('KeyboardManager','notebook/js/keyboardmanager');
    jglobal('Completer','notebook/js/completer');
    jglobal('Notebook','notebook/js/notebook');
    jglobal('Tooltip','notebook/js/tooltip');
    jglobal('Toolbar','notebook/js/toolbar');
    jglobal('SaveWidget','notebook/js/savewidget');
    jglobal('Pager','notebook/js/pager');
    jglobal('QuickHelp','notebook/js/quickhelp');
    jglobal('MarkdownCell','notebook/js/textcell');
    jglobal('RawCell','notebook/js/textcell');
    jglobal('Cell','notebook/js/cell');
    jglobal('MainToolBar','notebook/js/maintoolbar');
    jglobal('NotebookNotificationArea','notebook/js/notificationarea');
    jglobal('NotebookTour', 'notebook/js/tour');
    jglobal('MenuBar', 'notebook/js/menubar');

    // tree
    jglobal('SessionList','tree/js/sessionlist');

    Jupyter.version = "6.5.0.dev0";
    Jupyter._target = '_blank';

    return Jupyter;
});

// deprecated since 4.0, remove in 5+
var IPython = Jupyter;



----- FILE: setupbase.py (NEW) -----
"""
This module defines the things that are used in setup.py for building the notebook

This includes:

    * Functions for finding things like packages, package data, etc.
    * A function for checking dependencies.
"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import os
import re
import pipes
import shutil
import sys

from distutils import log
from distutils.cmd import Command
from fnmatch import fnmatch
from glob import glob
from multiprocessing.pool import ThreadPool
from subprocess import check_call

if sys.platform == 'win32':
    from subprocess import list2cmdline
else:
    def list2cmdline(cmd_list):
        return ' '.join(map(pipes.quote, cmd_list))

#-------------------------------------------------------------------------------
# Useful globals and utility functions
#-------------------------------------------------------------------------------

# A few handy globals
isfile = os.path.isfile
pjoin = os.path.join
repo_root = os.path.dirname(os.path.abspath(__file__))
is_repo = os.path.isdir(pjoin(repo_root, '.git'))

def oscmd(s):
    print(">", s)
    os.system(s)

# Py3 compatibility hacks, without assuming IPython itself is installed with
# the full py3compat machinery.

try:
    execfile
except NameError:
    def execfile(fname, globs, locs=None):
        locs = locs or globs
        exec(compile(open(fname).read(), fname, "exec"), globs, locs)


#---------------------------------------------------------------------------
# Basic project information
#---------------------------------------------------------------------------

name = 'notebook'

# release.py contains version, authors, license, url, keywords, etc.
version_ns = {}
execfile(pjoin(repo_root, name, '_version.py'), version_ns)

version = version_ns['__version__']


# vendored from pep440 package, we allow `.dev` suffix without trailing number.
loose_pep440re = re.compile(r'^([1-9]\d*!)?(0|[1-9]\d*)(\.(0|[1-9]\d*))*((a|b|rc)(0|[1-9]\d*))?(\.post(0|[1-9]\d*))?(\.dev(0|[1-9]\d*)?)?$')
if not loose_pep440re.match(version):
    raise ValueError('Invalid version number `%s`, please follow pep440 convention or pip will get confused about which package is more recent.' % version)

#---------------------------------------------------------------------------
# Find packages
#---------------------------------------------------------------------------

def find_packages():
    """
    Find all of the packages.
    """
    packages = []
    for dir,subdirs,files in os.walk(name):
        package = dir.replace(os.path.sep, '.')
        if '__init__.py' not in files:
            # not a package
            continue
        packages.append(package)
    return packages

#---------------------------------------------------------------------------
# Find package data
#---------------------------------------------------------------------------

def find_package_data():
    """
    Find package_data.
    """
    # This is not enough for these things to appear in a sdist.
    # We need to muck with the MANIFEST to get this to work
    
    # exclude components and less from the walk;
    # we will build the components separately
    excludes = [
        pjoin('static', 'components'),
        pjoin('static', '*', 'less'),
        pjoin('static', '*', 'node_modules')
    ]

    # walk notebook resources:
    cwd = os.getcwd()
    os.chdir('notebook')
    static_data = []
    for parent, dirs, files in os.walk('static'):
        if any(fnmatch(parent, pat) for pat in excludes):
            # prevent descending into subdirs
            dirs[:] = []
            continue
        for f in files:
            static_data.append(pjoin(parent, f))
    
    # for verification purposes, explicitly add main.min.js
    # so that installation will fail if they are missing
    for app in ['auth', 'edit', 'notebook', 'terminal', 'tree']:
        static_data.append(pjoin('static', app, 'js', 'main.min.js'))
    
    components = pjoin("static", "components")
    # select the components we actually need to install
    # (there are lots of resources we bundle for sdist-reasons that we don't actually use)
    static_data.extend([
        pjoin(components, "backbone", "backbone-min.js"),
        pjoin(components, "bootstrap", "dist", "js", "bootstrap.min.js"),
        pjoin(components, "bootstrap-tour", "build", "css", "bootstrap-tour.min.css"),
        pjoin(components, "bootstrap-tour", "build", "js", "bootstrap-tour.min.js"),
        pjoin(components, "create-react-class", "index.js"),
        pjoin(components, "font-awesome", "css", "*.css"),
        pjoin(components, "es6-promise", "*.js"),
        pjoin(components, "font-awesome", "fonts", "*.*"),
        pjoin(components, "jed", "jed.js"),
        pjoin(components, "jquery", "jquery.min.js"),
        pjoin(components, "jquery-typeahead", "dist", "jquery.typeahead.min.js"),
        pjoin(components, "jquery-typeahead", "dist", "jquery.typeahead.min.css"),
        pjoin(components, "jquery-ui", "jquery-ui.min.js"),
        pjoin(components, "jquery-ui", "themes", "smoothness", "jquery-ui.min.css"),
        pjoin(components, "jquery-ui", "themes", "smoothness", "images", "*"),
        pjoin(components, "marked", "lib", "marked.js"),
        pjoin(components, "react", "react.production.min.js"),
        pjoin(components, "react", "react-dom.production.min.js"),
        pjoin(components, "requirejs", "require.js"),
        pjoin(components, "requirejs-plugins", "src", "json.js"),
        pjoin(components, "requirejs-text", "text.js"),
        pjoin(components, "sanitizer", "index.js"),
        pjoin(components, "underscore", "underscore-min.js"),
        pjoin(components, "moment", "moment.js"),
        pjoin(components, "moment", "min", "*.js"),
        pjoin(components, "xterm.js", "index.js"),
        pjoin(components, "xterm.js-css", "index.css"),
        pjoin(components, "xterm.js-fit", "index.js"),
        pjoin(components, "text-encoding", "lib", "encoding.js"),
    ])

    # Ship all of Codemirror's CSS and JS
    for parent, dirs, files in os.walk(pjoin(components, 'codemirror')):
        for f in files:
            if f.endswith(('.js', '.css')):
                static_data.append(pjoin(parent, f))

    # Trim mathjax
    mj = lambda *path: pjoin(components, 'MathJax', *path)
    static_data.extend([
        mj('MathJax.js'),
        mj('config', 'TeX-AMS-MML_HTMLorMML-full.js'),
        mj('config', 'Safe.js'),
    ])
    
    trees = []
    mj_out = mj('jax', 'output')
    
    if os.path.exists(mj_out):
        for output in os.listdir(mj_out):
            path = pjoin(mj_out, output)
            static_data.append(pjoin(path, '*.js'))
            autoload = pjoin(path, 'autoload')
            if os.path.isdir(autoload):
                trees.append(autoload)

    for tree in trees + [
        mj('localization'), # limit to en?
        mj('fonts', 'HTML-CSS', 'STIX-Web', 'woff'),
        mj('extensions'),
        mj('jax', 'input', 'TeX'),
        mj('jax', 'output', 'HTML-CSS', 'fonts', 'STIX-Web'),
        mj('jax', 'output', 'SVG', 'fonts', 'STIX-Web'),
        mj('jax', 'element', 'mml'),
    ]:
        for parent, dirs, files in os.walk(tree):
            for f in files:
                static_data.append(pjoin(parent, f))

    os.chdir(os.path.join('tests',))
    js_tests = glob('*.js') + glob('*/*.js')

    os.chdir(cwd)

    package_data = {
        'notebook' : ['templates/*'] + static_data,
        'notebook.tests' : js_tests,
        'notebook.bundler.tests': ['resources/*', 'resources/*/*', 'resources/*/*/.*'],
        'notebook.services.api': ['api.yaml'],
        'notebook.i18n': ['*/LC_MESSAGES/*.*'],
    }
    
    return package_data


def check_package_data(package_data):
    """verify that package_data globs make sense"""
    print("checking package data")
    for pkg, data in package_data.items():
        pkg_root = pjoin(*pkg.split('.'))
        for d in data:
            path = pjoin(pkg_root, d)
            if '*' in path:
                assert len(glob(path)) > 0, "No files match pattern %s" % path
            else:
                assert os.path.exists(path), "Missing package data: %s" % path


def check_package_data_first(command):
    """decorator for checking package_data before running a given command
    
    Probably only needs to wrap build_py
    """
    class DecoratedCommand(command):
        def run(self):
            check_package_data(self.package_data)
            command.run(self)
    return DecoratedCommand

def update_package_data(distribution):
    """update package_data to catch changes during setup"""
    build_py = distribution.get_command_obj('build_py')
    distribution.package_data = find_package_data()
    # re-init build_py options which load package_data
    build_py.finalize_options()

#---------------------------------------------------------------------------
# Notebook related
#---------------------------------------------------------------------------

try:
    from shutil import which
except ImportError:
    ## which() function copied from Python 3.4.3; PSF license
    def which(cmd, mode=os.F_OK | os.X_OK, path=None):
        """Given a command, mode, and a PATH string, return the path which
        conforms to the given mode on the PATH, or None if there is no such
        file.

        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
        of os.environ.get("PATH"), or can be overridden with a custom search
        path.

        """
        # Check that a given file can be accessed with the correct mode.
        # Additionally check that `file` is not a directory, as on Windows
        # directories pass the os.access check.
        def _access_check(fn, mode):
            return (os.path.exists(fn) and os.access(fn, mode)
                    and not os.path.isdir(fn))

        # If we're given a path with a directory part, look it up directly rather
        # than referring to PATH directories. This includes checking relative to the
        # current directory, e.g. ./script
        if os.path.dirname(cmd):
            if _access_check(cmd, mode):
                return cmd
            return None

        if path is None:
            path = os.environ.get("PATH", os.defpath)
        if not path:
            return None
        path = path.split(os.pathsep)

        if sys.platform == "win32":
            # The current directory takes precedence on Windows.
            if not os.curdir in path:
                path.insert(0, os.curdir)

            # PATHEXT is necessary to check on Windows.
            pathext = os.environ.get("PATHEXT", "").split(os.pathsep)
            # See if the given file matches any of the expected path extensions.
            # This will allow us to short circuit when given "python.exe".
            # If it does match, only test that one, otherwise we have to try
            # others.
            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
                files = [cmd]
            else:
                files = [cmd + ext for ext in pathext]
        else:
            # On other platforms you don't have things like PATHEXT to tell you
            # what file suffixes are executable, so just pass on cmd as-is.
            files = [cmd]

        seen = set()
        for dir in path:
            normdir = os.path.normcase(dir)
            if not normdir in seen:
                seen.add(normdir)
                for thefile in files:
                    name = os.path.join(dir, thefile)
                    if _access_check(name, mode):
                        return name
        return None


static = pjoin(repo_root, 'notebook', 'static')

npm_path = os.pathsep.join([
    pjoin(repo_root, 'node_modules', '.bin'),
    os.environ.get("PATH", os.defpath),
])

def mtime(path):
    """shorthand for mtime"""
    return os.stat(path).st_mtime


def run(cmd, *args, **kwargs):
    """Echo a command before running it"""
    log.info('> ' + list2cmdline(cmd))
    kwargs['shell'] = (sys.platform == 'win32')
    return check_call(cmd, *args, **kwargs)

class CompileBackendTranslation(Command):
    description = "compile the .po files into .mo files, that contain the translations."

    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass


    def run(self):
        paths = glob('notebook/i18n/??_??')
        for p in paths:
            LANG = p[-5:]
            for component in ['notebook', 'nbui']:
                run(['pybabel', 'compile',
                     '-D', component,
                     '-f',
                     '-l', LANG,
                     '-i', pjoin('notebook', 'i18n', LANG, 'LC_MESSAGES', component+'.po'),
                     '-o', pjoin('notebook', 'i18n', LANG, 'LC_MESSAGES', component+'.mo')
                    ])

class Bower(Command):
    description = "fetch static client-side components with bower"
    
    user_options = [
        ('force', 'f', "force fetching of bower dependencies"),
    ]
    
    def initialize_options(self):
        self.force = False
    
    def finalize_options(self):
        self.force = bool(self.force)
    
    bower_dir = pjoin(static, 'components')
    node_modules = pjoin(repo_root, 'node_modules')
    sanitizer_dir = pjoin(bower_dir, 'sanitizer')
    
    def should_run(self):
        if self.force:
            return True
        if not os.path.exists(self.bower_dir):
            return True
        if not os.path.exists(self.sanitizer_dir):
            return True

        bower_stale = mtime(self.bower_dir) < mtime(pjoin(repo_root, 'bower.json'))
        if bower_stale:
            return True

        return mtime(self.sanitizer_dir) < mtime(pjoin(repo_root, 'webpack.config.js'))

    def should_run_npm(self):
        if not which('npm'):
            print("npm unavailable", file=sys.stderr)
            return False
        if not os.path.exists(self.node_modules):
            return True
        return mtime(self.node_modules) < mtime(pjoin(repo_root, 'package.json'))

    def run(self):
        if not self.should_run():
            print("bower dependencies up to date")
            return
        
        if self.should_run_npm():
            print("installing build dependencies with npm")
            run(['npm', 'install'], cwd=repo_root)
            os.utime(self.node_modules, None)
        
        env = os.environ.copy()
        env['PATH'] = npm_path
        
        try:
            run(
                ['bower', 'install', '--allow-root', '--config.interactive=false'],
                cwd=repo_root,
                env=env
            )
        except OSError as e:
            print("Failed to run bower: %s" % e, file=sys.stderr)
            print("You can install js dependencies with `npm install`", file=sys.stderr)
            raise
        # self.npm_components()
        if not os.path.exists(self.sanitizer_dir):
            run(['npm', 'run', 'build:webpack'], cwd=repo_root, env=env)
        os.utime(self.bower_dir, None)
        # update package data in case this created new files
        update_package_data(self.distribution)


def patch_out_bootstrap_bw_print():
    """Hack! Manually patch out the bootstrap rule that forces printing in B&W.

    We haven't found a way to override this rule with another one.
    """
    print_less = pjoin(static, 'components', 'bootstrap', 'less', 'print.less')
    with open(print_less) as f:
        lines = f.readlines()

    for ix, line in enumerate(lines):
        if 'Black prints faster' in line:
            break
    else:
        return  # Already patched out, nothing to do.

    rmed = lines.pop(ix)
    print("Removed line", ix, "from bootstrap print.less:")
    print("-", rmed)
    print()
    with open(print_less, 'w') as f:
        f.writelines(lines)

class CompileCSS(Command):
    """Recompile Notebook CSS
    
    Regenerate the compiled CSS from LESS sources.
    
    Requires various dev dependencies, such as require and lessc.
    """
    description = "Recompile Notebook CSS"
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    sources = []
    targets = []
    for name in ('ipython', 'style'):
        sources.append(pjoin(static, 'style', '%s.less' % name))
        targets.append(pjoin(static, 'style', '%s.min.css' % name))

    def run(self):
        self.run_command('jsdeps')
        env = os.environ.copy()
        env['PATH'] = npm_path

        patch_out_bootstrap_bw_print()
        
        for src, dst in zip(self.sources, self.targets):
            try:
                run(['lessc',
                    '--source-map',
                    '--include-path=%s' % pipes.quote(static),
                    src,
                    dst,
                ], cwd=repo_root, env=env)
            except OSError as e:
                print("Failed to build css: %s" % e, file=sys.stderr)
                print("You can install js dependencies with `npm install`", file=sys.stderr)
                raise
        # update package data in case this created new files
        update_package_data(self.distribution)


class CompileJS(Command):
    """Rebuild Notebook Javascript main.min.js files and translation files.
    
    Calls require via build-main.js
    """
    description = "Rebuild Notebook Javascript main.min.js files"
    user_options = [
        ('force', 'f', "force rebuilding js targets"),
    ]

    def initialize_options(self):
        self.force = False

    def finalize_options(self):
        self.force = bool(self.force)

    apps = ['notebook', 'tree', 'edit', 'terminal', 'auth']
    targets = [ pjoin(static, app, 'js', 'main.min.js') for app in apps ]
    
    def sources(self, name):
        """Generator yielding .js sources that an application depends on"""
        yield pjoin(repo_root, 'tools', 'build-main.js')
        yield pjoin(static, name, 'js', 'main.js')

        for sec in [name, 'base', 'auth']:
            for f in glob(pjoin(static, sec, 'js', '*.js')):
                if not f.endswith('.min.js'):
                    yield f
        yield pjoin(static, 'services', 'config.js')
        if name == 'notebook':
            for f in glob(pjoin(static, 'services', '*', '*.js')):
                yield f
        for parent, dirs, files in os.walk(pjoin(static, 'components')):
            if os.path.basename(parent) == 'MathJax':
                # don't look in MathJax, since it takes forever to walk it
                dirs[:] = []
                continue
            for f in files:
                yield pjoin(parent, f)
    
    def should_run(self, name, target):
        if self.force or not os.path.exists(target):
            return True
        target_mtime = mtime(target)
        for source in self.sources(name):
            if mtime(source) > target_mtime:
                print(source, target)
                return True
        return False

    def build_main(self, name):
        """Build main.min.js"""
        target = pjoin(static, name, 'js', 'main.min.js')

        if not self.should_run(name, target):
            log.info("%s up to date" % target)
            return
        log.info("Rebuilding %s" % target)
        run(['node', 'tools/build-main.js', name])

    def build_jstranslation(self, trd):
        lang = trd[-5:]
        run([
            pjoin('node_modules', '.bin', 'po2json'),
            '-p', '-F',
            '-f', 'jed1.x',
            '-d', 'nbjs',
            pjoin('notebook', 'i18n', lang, 'LC_MESSAGES', 'nbjs.po'),
            pjoin('notebook', 'i18n', lang, 'LC_MESSAGES', 'nbjs.json'),
        ])

    def run(self):
        self.run_command('jsdeps')
        env = os.environ.copy()
        env['PATH'] = npm_path
        pool = ThreadPool()
        pool.map(self.build_main, self.apps)
        pool.map(self.build_jstranslation, glob('notebook/i18n/??_??'))
        # update package data in case this created new files
        update_package_data(self.distribution)


class JavascriptVersion(Command):
    """write the javascript version to notebook javascript"""
    description = "Write Jupyter version to javascript"
    user_options = []
    
    def initialize_options(self):
        pass
    
    def finalize_options(self):
        pass
    
    def run(self):
        nsfile = pjoin(repo_root, "notebook", "static", "base", "js", "namespace.js")
        with open(nsfile) as f:
            lines = f.readlines()
        with open(nsfile, 'w') as f:
            found = False
            for line in lines:
                if line.strip().startswith("Jupyter.version"):
                    line = '    Jupyter.version = "{0}";\n'.format(version)
                    found = True
                f.write(line)
            if not found:
                raise RuntimeError("Didn't find Jupyter.version line in %s" % nsfile)


def css_js_prerelease(command, strict=False):
    """decorator for building minified js/css prior to another command"""
    class DecoratedCommand(command):
        def run(self):
            self.distribution.run_command('jsversion')
            jsdeps = self.distribution.get_command_obj('jsdeps')
            js = self.distribution.get_command_obj('js')
            css = self.distribution.get_command_obj('css')
            jsdeps.force = js.force = strict

            targets = [ jsdeps.bower_dir ]
            targets.extend(js.targets)
            targets.extend(css.targets)
            missing = [ t for t in targets if not os.path.exists(t) ]

            if not is_repo and not missing:
                # If we're an sdist, we aren't a repo and everything should be present.
                # Don't rebuild js/css in that case.
                command.run(self)
                return

            try:
                self.distribution.run_command('js')
                self.distribution.run_command('css')
                self.distribution.run_command('backendtranslations')
            except Exception as e:
                # refresh missing
                missing = [ t for t in targets if not os.path.exists(t) ]
                if strict or missing:
                    # die if strict or any targets didn't build
                    prefix = os.path.commonprefix([repo_root + os.sep] + missing)
                    missing = [ m[len(prefix):] for m in missing ]
                    log.warn("rebuilding js and css failed. The following required files are missing: %s" % missing)
                    raise e
                else:
                    log.warn("rebuilding js and css failed (not a problem)")
                    log.warn(str(e))

            # check again for missing targets, just in case:
            missing = [ t for t in targets if not os.path.exists(t) ]
            if missing:
                # command succeeded, but targets still missing (?!)
                prefix = os.path.commonprefix([repo_root + os.sep] + missing)
                missing = [ m[len(prefix):] for m in missing ]
                raise ValueError("The following required files are missing: %s" % missing)

            command.run(self)
    return DecoratedCommand



----- FILE: webpack.config.js (NEW) -----
const path = require('path');

module.exports = {
  entry: '@jupyterlab/apputils/lib/sanitizer',
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname, 'notebook/static/components/sanitizer'),
    libraryTarget: "amd"
  }
}



----- FILE: notebook_static_base_js_security.js (NEW) -----
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

define([
    'jquery',
    'components/sanitizer/index',
], function($, sanitizer) {
    "use strict";

    var noop = function (x) { return x; };
    var defaultSanitizer = sanitizer.defaultSanitizer;

    var sanitize_html = function (html, allow_css) {
        /**
         * sanitize HTML
         * if allow_css is true (default: false), CSS is sanitized as well.
         * otherwise, CSS elements and attributes are simply removed.
         */
         const options = {};
         if (!allow_css) {
             options.allowedStyles = {};
         }
        return defaultSanitizer.sanitize(html, options);
    };

    var sanitize_html_and_parse = function (html, allow_css) {
        /**
         * Sanitize HTML and parse it safely using jQuery.
         *
         * This disable's jQuery's html 'prefilter', which can make invalid
         * HTML valid after the sanitizer has checked it.
         *
         * Returns an array of DOM nodes.
         */
        var sanitized_html = sanitize_html(html, allow_css);
        var prev_htmlPrefilter = $.htmlPrefilter;
        $.htmlPrefilter = function(html) {return html;};  // Don't modify HTML
        try {
            return $.parseHTML(sanitized_html);
        } finally {
            $.htmlPrefilter = prev_htmlPrefilter;  // Set it back again
        }
    };

    var security = {
        sanitize_html_and_parse: sanitize_html_and_parse,
        sanitize_html: sanitize_html
    };

    return security;
});



----- FILE: bower.json (NEW) -----
{
  "name": "jupyter-notebook-deps",
  "version": "0.0.1",
  "dependencies": {
    "backbone": "components/backbone#~1.2",
    "bootstrap": "bootstrap#~3.4",
    "bootstrap-tour": "0.9.0",
    "codemirror": "components/codemirror#5.56.0+components1",
    "create-react-class": "https://cdn.jsdelivr.net/npm/create-react-class@15.6.3/create-react-class.min.js",
    "es6-promise": "~1.0",
    "font-awesome": "components/font-awesome#~4.7.0",
    "jed": "~1.1.1",
    "jquery": "components/jquery#~3.5.0",
    "jquery-typeahead": "~2.10.6",
    "jquery-ui": "components/jqueryui#~1.12",
    "marked": "~0.7",
    "MathJax": "^2.7.4",
    "moment": "~2.19.3",
    "react": "~16.0.0",
    "requirejs": "~2.2",
    "requirejs-text": "~2.0.15",
    "requirejs-plugins": "~1.0.3",
    "text-encoding": "~0.1",
    "underscore": "components/underscore#~1.8.3",
    "xterm.js": "https://unpkg.com/xterm@~3.1.0/dist/xterm.js",
    "xterm.js-css": "https://unpkg.com/xterm@~3.1.0/dist/xterm.css",
    "xterm.js-fit": "https://unpkg.com/xterm@~3.1.0/dist/addons/fit/fit.js"
  }
}



----- FILE: package.json (NEW) -----
{
  "name": "jupyter-notebook-deps",
  "private": true,
  "version": "4.0.0",
  "description": "Jupyter Notebook nodejs dependencies",
  "author": "Jupyter Developers",
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "https://github.com/jupyter/notebook.git"
  },
  "scripts": {
    "bower": "bower install",
    "build": "python setup.py js css",
    "build:webpack": "webpack --mode development",
    "build:watch": "npm run watch",
    "watch": "onchange 'notebook/static/**/!(*.min).js' 'notebook/static/**/*.less' 'bower.json' -- npm run build"
  },
  "devDependencies": {
    "@jupyterlab/apputils": "^3.1.3",
    "bower": "^1.8.8",
    "less": "~2",
    "onchange": "^6.0.0",
    "po2json": "^0.4.5",
    "requirejs": "^2.3.6",
    "webpack": "^5.46.0",
    "webpack-cli": "^4.7.2"
  }
}


